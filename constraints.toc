
;; TODO: add a Hole constraint to print information

;; TODO: really bad error if this is in there
;; (def int-max)

(def SymbolOrString (any-of Symbol
                            String))

(deftype Location [file line]
  (assert (instance? SymbolOrString file))
  (assert (instance? Integer line))

  Stringable
  (string-list [_]
    (list (either (and (= file 'core)
                       (maybe "core"))
                  (str file))
          ": " (str line)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def default-old-extract-items-constraints)

;; TODO: make this HashMap be some kind of data type that holds info about the type
;; map-keys, static-value, contents, field types, etc.
;; In fact, change TypeConstraint to only apply to user defined types and make
;; specific constraints for core types. Then replace the TypeMap with SumConstraint
(def TypeMap (map-of Integer HashMap))

(def top-type)
(def bottom-type)
(def type-map)

(def always-nothing -1)
(def never-nothing -2)

(deftype Field [sym]
  (assert (instance? Symbol sym))

  Stringable
  (string-list [_]
    (list (str "(c/Field (symbol \"" sym "\"))")))

  Container
  (map [x _]
    x)

  (map [x _ embed]
    (embed x)))

;; Public interface for Constraints
(defprotocol Constraint
  (assertion-path [x])

  ;; Ensure constraint is as small as possible
  (trim [c]
    c)

  (get-type-sym [c])

  (set-path [c new-path]
    (assert (instance? (list-of Vector) new-path))
    (assert-result r (instance? Either r))

    (Right c))

  (reified-field [c indices]
    (assert (instance? (vector-of Integer) indices))
    (assert-result r (instance? Either r))

    (Left nothing))

  (filter-reified-field [c]
    c)

  ;; TODO: remove these two when old-reify-c is removed from toccata.toc
  (reified-fields [c]
    (Right top-type))
  (filter-reified-fields [c]
    c)

  (dynamic-params [c]
    (assert-result r (instance? Vector r))

    [])

  (set-arity [c new-arity]
    c)

  (type-map [new old]
    ;; TODO: change back to TypeMap
    (assert-result r (instance? (maybe-of HashMap) r))

    ;; TODO: c-exprs from Toccata might show up here and we can extract constraint info from them
    ;; but for noew, just ignore them
    nothing)

  (add-to-path [constraint file-name line-number]
    constraint)

  (remove-sym [c]
    (assert-result r (instance? Either r))

    (Right c))

  (contents-constraint [_])

  (collection-of [_]
    ;; extract CollectionOf constraint
    )

  (coll-constraint [_]
    ;; extract the CollectionOf or the InferredInner constraints
    ;; returns either an AllValues or CollectionOf constraint
    )

  (intersect [c1 c2])

  (format-path [x n]
    (assert-result r (instance? (list-of String) r)))

  (restrict-types [c types-map]
    (either (map (para type-map c)
                 (fn [c-type-map]
                   (select-keys types-map (keys c-type-map))))
            types-map))

  (is-collection? [c]
    nothing)

  (get-tail-constraint [c x]
    bottom-type)

  (fixed-items-constraints [c x]
    (assert-result r (instance? Vector r))
    [])

  ;; TODO: still need to replace this
  (old-extract-items-constraints [c n]
    (assert (instance? Integer n))
    (assert-result r (instance? Vector r)))

  (extract-sym [tc]
    (assert-result r (instance? (maybe-of Symbol) r))

    nothing)

  (update-sym [tc new-sym]
    (assert (instance? Symbol new-sym)))

  (extract-var [c]
    (assert-result var (instance? String var)))

  (clear-var [c]
    c)

  (update-var [c new-var]
    (assert (instance? String new-var))
    c)

  (set-type-name [c new-name]
    c)

  ;; This is only used for calls to seq and vec. And there's not enough benefit to
  ;; implementing them with recursion schemes
  (set-type [c tc]
    (trim (intersect c tc)))

  (satisfied-by [c info]
    (assert-result r (instance? Maybe r))

    nothing))

;; (defn extract-collection-of [c]
;;   (let [x (old-extract-collection-of c)
;;         y (cata collection-of c)]
;;     (or (= x y)
;;         (maybe (print-err 'diff-coll-of c "\n\n" x "\n\n" y)))
;;     y))

(defn extract-tail-constraint [c]
  (para (comp trim get-tail-constraint)
        ;; TODO: remove this trim evenutally
        (trim c)))

(defn extract-items-constraints
  ([c]
   (para (comp trim fixed-items-constraints)
         ;; TODO: remove this trim evenutally
         (trim c)))
  ([c n]
   (old-extract-items-constraints c n)))

(defn update-type-name [c new-name]
  (cata (fn [c]
          (set-type-name c new-name))
        c))

(defn extract-collection-of [c]
  (elgot collection-of trim c))

(defn extract-coll-constraint [c]
  (elgot coll-constraint trim c))

(defn extract-contents-constraint [c]
  (apo (fn [c]
         (-> c
             contents-constraint
             (map trim)))
       c))

(defn extract-reified-fields [c]
  (elgot reified-fields filter-reified-fields c))

(defn extract-reified-field [c indices]
  (elgot (fn [inner-c]
           (reified-field inner-c indices))
         filter-reified-field
         c))

(defn replace-path [c new-path]
  (apo (fn [c]
         (set-path c new-path))
       c))

(defn update-path
  ([c loc]
   (assert (instance? Location loc))
   (update-path c (.file loc) (.line loc)))

  ([c file-name line-number]
   (cata (fn [c]
           (add-to-path c file-name line-number))
         c)))

(defn clear-sym [c]
  (apo remove-sym c))

(defn extract-type-map [c]
  (para type-map c))

(defn extract-dynamic-params [c]
  (cata dynamic-params c))

;; TODO: remove unused types
(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -2, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FunctionType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MaybeType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ListType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SymbolType};"))
(def BitmapIndexedType (inline C Integer "(Value *)&(Integer){IntegerType, -2, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ArrayNodeType};"))
(def HashCollisionNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -2, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, OpaqueType};"))
(def TypeConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeConstraintType};"))
(def NoValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, NoValuesType};"))
(def AllValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AllValuesType};"))
(def MultiConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MultiConstraintType};"))
(def ResultConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ResultConstraintType};"))
(def ItemsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ItemsConstraintType};"))
(def InferredInnerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InferredInnerType};"))
(def StaticLengthConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2,
    StaticLengthConstraintType};"))
(def ContentsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ContentsConstraintType};"))
(def HashSetType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashSetType};"))
(def ProtoDispatcherType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ProtoDispatcherType};"))
(def FloatType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FloatType};"))
(def SumConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SumConstraintType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeCount};"))

(defn extract-key-constraint [c]
  (either (flat-map (extract-type-map c)
                    (fn [types-map]
                      (and (or (get types-map BitmapIndexedType)
                               (get types-map ArrayNodeType)
                               (get types-map HashCollisionNodeType))
                           (-> c
                               extract-contents-constraint
                               extract-items-constraints
                               first))))

          top-type))

;; TODO: constraints to add
;; number of args the target of a call takes
;; min count (instead of ItemsConstraint)
;; keys required in a hash map

(defn format-path* [path desired-len]
  (assert (instance? List path))
  (assert (instance? Integer desired-len))

  (either (map (first path)
               (fn [[header]]
                 (let [path (-> (rest path)
                                (remove (fn [[file line]]
                                          (either (and (instance? Symbol file)
                                                       (maybe nothing))
                                                  (or (empty? file)
                                                      (= 0 line)))))
                                (map (fn [[file line]]
                                       (let [file (str file)]
                                         (str (either (-> file
                                                          str
                                                          (split-string (partial = "/"))
                                                          last
                                                          (map (fn [file]
                                                                 (either (and (flat-map (first file)
                                                                                        (partial = "/"))
                                                                              (maybe file))
                                                                         file))))
                                                      file)
                                              ": " line)))))
                       max-width (reduce path (count header)
                                         (fn [max s]
                                           (let [n (count s)]
                                             (either (> max n)
                                                     n))))
                       path (either (and (< (count path) desired-len)
                                         (maybe (comp path (repeat (- desired-len (count path))
                                                                   (spaces max-width)))))
                                    path)]
                   (map (cons header path)
                        (fn [x]
                          (str x (spaces (- max-width (count x)))))))))
          path))

(deftype AllValues [path var]
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "c/top-type"))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (maybe x)))

  Constraint
  (clear-var [c]
    (.var c ""))

  (satisfied-by [_ c] (maybe c))
  (intersect [_ c] c)
  (update-sym [x _] x)
  (add-to-path [x file line]
    (either (for [[top-file top-line] (first (.path x))
                  :when (and (= top-file file)
                             (= top-line line))]
              x)
            (.path x (cons [file line] (.path x)))))
  (extract-var [_] var)
  (update-var [x v] (.var x v)))

(def top-type (AllValues empty-list ""))

(def no-symbol
  (reify
    Stringable
    (string-list [_]
      (list "c/no-symbol"))

    Eq
    (=* [x y]
      (or (instance? Symbol y)
          (and (= (get-type x) (get-type y))
               (maybe x))))

    Hashable
    ;; TODO: remove these impls after HashMapConstraint is implented
    (sha1-update [x ctxt]
      (sha1-update-type x ctxt)
      (sha1-update "no-symbol" ctxt))

    (sha1 [x]
      (let [ctxt (sha1-init)]
        (sha1-update x ctxt)
        (sha1-finalize ctxt)))))

(defn sym-str [s]
  (either (or (map (= no-symbol)
                   str)
              (map s (fn [s]
                       (str "(maybe '" s ")"))))
          "nothing"))

;; InferredInner is a weaker version of CollectionOf
(deftype InferredInner [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/InferredInner\n" (str contents) " (list "
          ;; (either (map (first path) (fn [[f l]]
          ;;                             (str "[\"" f "\" " l "]")))
          ;;         "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (is-collection? [c]
    (maybe c))

  (assertion-path [_] path)

  (format-path [x desired-len]
    (format-path* (cons ["Contents restriction from" ""] path)
                  desired-len)))

;; CollectionOf is a stronger version of InferredInner
(deftype CollectionOf [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/CollectionOf\n" (str contents) " (list "
          ;; (either (map (first path) (fn [[f l]]
          ;;                             (str "[\"" f "\" " l "]")))
          ;;         "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (is-collection? [c]
    (maybe c))

  (update-var [c new-var]
    (.var c new-var))

  (assertion-path [_] path)

  (format-path [x desired-len]
    (format-path* (cons ["Contents from" ""] path)
                  desired-len)))

(def coll-of-any (CollectionOf top-type empty-list nothing ""))

(deftype ItemsConstraint [items-constraints tail-constraint path sym var]
  (assert (instance? Vector items-constraints))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/ItemsConstraint\n[" (to-str (interpose items-constraints "\n"))
          "]\n" (str tail-constraint) "\n(list "
          ;; (either (map (first path) (fn [[f l]]
          ;;                             (str "[\"" f "\" " l "]")))
          ;;         "")
          ") " (sym-str sym) " \"" "\")"))

  Constraint
  (is-collection? [c]
    (maybe c))

  (trim [ic]
    (either (map (instance? ItemsConstraint tail-constraint)
                 (fn [tail-c]
                   (-> ic
                       (.items-constraints (comp items-constraints
                                                 (.items-constraints tail-c)))
                       (.tail-constraint (.tail-constraint tail-c)))))
            ic))

  (set-type [c tc]
    (-> c
        (.tail-constraint (set-type (.tail-constraint c) tc))
        (intersect tc)
        trim))

  (assertion-path [_] path)

  (type-map [_ _]
    (maybe {ListType {}
            VectorType {}}))

  (format-path [x desired-len]
    (format-path* (cons ["Sequence from" ""] path)
                  desired-len)))

(deftype TypeConstraint [type-maps path type-sym sym var]
  ;; TODO: change back to TypeMap
  (assert (instance? HashMap type-maps))
  (assert (instance? (list-of Vector) path))
  ;; 'type-sym' has to be more relaxed so it can accept an ast/tagged-symbol
  ;; (assert (instance? Symbol type-sym))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/TypeConstraint "
          (str type-maps)
          "\n"
          "(list)"
          ;; (str (cons 'list path))
          (str " (symbol \"" type-sym "\")") " " (sym-str sym)
          " \"" (str var) "\")" ))

  Eq
  ;; TODO: equality musth check the field maps as well
  ;; verify this
  (=* [x y]
    (for [_ (instance? TypeConstraint y)
          y-maps (extract-type-map y)
          _ (= type-maps y-maps)]
      x))

  Constraint
  (get-type-sym [c]
    type-sym)

  (set-type-name [c new-name]
    (.type-sym c new-name))

  (assertion-path [_] path)

  (type-map [_ _]
    (maybe type-maps))

  (format-path [x desired-len]
    (format-path* (cons [(str "Type '" type-sym "' from") ""]
                        path)
                  desired-len)))

(def no-int
  (reify
    Stringable
    (string-list [_]
      (list "c/no-static-int"))

    Eq
    (=* [x y]
      (or (instance? Integer y)
          (and (= (get-type x) (get-type y))
               (maybe x))))

    Ord
    (<* [x y]
      (or (instance? Integer y)
          (and (= (get-type x) (get-type y))
               (maybe x))))))

(deftype IntegerConstraint [static-value max min path sym var]
  ;; (assert (instance? (any-of Integer
  ;;                            no-int) static-value))
  ;; (assert (instance? (any-of Integer
  ;;                            no-max-int) max))
  ;; (assert (instance? (any-of Integer
  ;;                            no-min-int) min))
  (assert (instance? (list-of Vector) path))
  ;; (assert (instance? (any-of Symbol
  ;;                            no-symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/IntegerConstraint " (str static-value) " " (str max) " " (str min) " "
          "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? IntegerConstraint y)
         (= static-value (.static-value y))
         (= max (.max y))
         (= min (.min y))
         (maybe x)))

  Constraint
  (get-type-sym [_] 'Integer))

(deftype SymbolConstraint [static-value path sym var]
  ;; (assert (instance? (any-of Symbol
  ;;                            no-symbol) static-value))
  (assert (instance? (list-of Vector) path))
  ;; (assert (instance? (any-of Symbol
  ;;                            no-symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/SymbolConstraint " (str static-value) " "
          "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? SymbolConstraint y)
         (= static-value (.static-value y))
         (maybe x)))

  Constraint
  (get-type-sym [_] 'Symbol))

(def no-string
  (reify
    Stringable
    (string-list [_]
      (list "c/no-string"))

    Eq
    (=* [x y]
      (or (instance? String y)
          (and (= (get-type x) (get-type y))
               (maybe x))))

    Hashable
    ;; TODO: remove these impls after HashMapConstraint is implented
    (sha1-update [x ctxt]
      (sha1-update-type x ctxt)
      (sha1-update "no-symbol" ctxt))

    (sha1 [x]
      (let [ctxt (sha1-init)]
        (sha1-update x ctxt)
        (sha1-finalize ctxt)))))

(deftype StrBuffConstraint [static-value path sym var]
  ;; (assert (instance? (any-of String
  ;;                            no-string) static-value))
  (assert (instance? (list-of Vector) path))
  ;; (assert (instance? (any-of Symbol
  ;;                            no-symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/StrBuffConstraint " (str static-value) " "
          "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? StrBuffConstraint y)
         (= static-value (.static-value y))
         (maybe x)))

  Constraint
  (get-type-sym [_] 'String))

(deftype SubStrConstraint [static-value path sym var]
  ;; (assert (instance? (any-of String
  ;;                            no-string) static-value))
  (assert (instance? (list-of Vector) path))
  ;; (assert (instance? (any-of Symbol
  ;;                            no-symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/SubStrConstraint " (str static-value) " "
          "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? SubStrConstraint y)
         (= static-value (.static-value y))
         (maybe x)))

  Constraint
  (get-type-sym [_] 'String))

(deftype MaybeConstraint [contents path sym var]
  (assert (instance? (list-of Vector) path))
  ;; (assert (instance? (any-of Symbol
  ;;                            no-symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/MaybeConstraint " (str contents) " "
          "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? MaybeConstraint y)
         (= contents (.contents y))
         (maybe x)))

  Constraint
  (get-type-sym [_] 'Maybe))

(deftype AgentConstraint [contents path sym var]
  (assert (instance? (list-of Vector) path))
  ;; (assert (instance? (any-of Symbol
  ;;                            no-symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/AgentConstraint " (str contents) " "
          "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? AgentConstraint y)
         (= contents (.contents y))
         (maybe x)))

  Constraint
  (get-type-sym [_] 'Agent))

(deftype PromiseConstraint [contents path sym var]
  (assert (instance? (list-of Vector) path))
  ;; (assert (instance? (any-of Symbol
  ;;                            no-symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/PromiseConstraint " (str contents) " "
          "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? PromiseConstraint y)
         (= contents (.contents y))
         (maybe x)))

  Constraint
  (get-type-sym [_] 'Promise))

(deftype FnConstraint [arities path sym var]
  (assert (instance? HashMap arities))
  (assert (instance? (list-of Vector) path))
  ;; (assert (instance? (any-of Symbol
  ;;                            no-symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/FnConstraint " (str arities) " "
          "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (identical x y))

  Constraint
  (get-type-sym [_] 'Fn))

(deftype StaticLengthConstraint [length path sym var]
  (assert (instance? Integer length))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [c]
    (list "(c/StaticLengthConstraint " (str length) " (list "
          ;; (either (map (first path) (fn [[f l]]
          ;;                             (str "[\"" f "\" " l "]")))
          ;;         "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (assertion-path [c] path)

  (format-path [x desired-len]
    (format-path* (cons [(str "Length from") ""]
                          (.path x))
                    desired-len))

  (type-map [_ _]
    (maybe {ListType {}
            VectorType {}})))

(def StaticConstraints (any-of StaticLengthConstraint
                               ))

(deftype NoFields []
  Stringable
  (string-list [_]
    (list "<NoFields>")))

(def no-fields (NoFields))

(def StrConstraint (any-of StrBuffConstraint
                           SubStrConstraint))

(def CoreValConstraint (any-of IntegerConstraint
                               SymbolConstraint
                               StrConstraint
                               MaybeConstraint
                               AgentConstraint
                               PromiseConstraint
                               FnConstraint))

;; TODO: add 'typ-sym' and make it a be optional for all constraints
(deftype SumConstraint [alts path sym var]
  (assert (instance? Vector alts))
  (assert (instance? (min-count 1) alts))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? (list-of Vector) path))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list (str "(c/SumConstraint\n" (str alts) " (list"
               ;; (either (map (first path) (fn [[f l]]
               ;;                             (str "[\"" f "\" " l "]")))
               ;;         "")
               ") " (sym-str sym) " "
               (str "\"" var "\"") ")")))

  Eq
  (=* [x y]
    (and (instance? SumConstraint y)
         (= (count alts) (count (.alts y)))
         (every (.alts y) (fn [c]
                            (some alts (partial =* c))))
         (maybe x)))

  Constraint
  (assertion-path [x] path)

  (format-path [c n]
    (let [sum-sym (either (and (every (.alts c) (partial instance? CoreValConstraint))
                               (apply = (map (.alts c) get-type-sym)))
                          "Sum Type")]
      (format-path* (cons [(str sum-sym " from") ""] path)
                    n)))

  (type-map [c _]
    (let [alt-maps (.alts c)]
      ;; TODO: change back to TypeMap
      (assert (instance? (vector-of (maybe-of HashMap)) alt-maps))

      (flat-map (apply (maybe vector)
                       (filter alt-maps identity))
                (fn [alt-maps]
                  (and (first alt-maps)
                       (-> (reduce (for [[type-num fields] (flat-map alt-maps vec)
                                         [field c] (either (and (empty? fields)
                                                                (maybe [[no-fields top-type]]))
                                                           (vec fields))]
                                     [type-num field c])
                                   {}
                                   (fn [m [type-num field c]]
                                     (either (update-in m [type-num field] (fn [cs]
                                                                             (conj cs c)))
                                             (assoc-in m [type-num field] [c]))))
                           (map-vals (fn [fields]
                                       (either (and (get fields no-fields)
                                                    (maybe {}))
                                               (map-vals fields (fn [alts]
                                                                  ;; TODO: what if 'alts' has NoValues in it?
                                                                  ;; what if it's empty?
                                                                  (either (some alts (partial = top-type))
                                                                          (SumConstraint alts path sym var)))))))
                           maybe))))))

  (extract-var [c]
    var)

  (update-var [c new-var]
    (-> c
        (.alts (map (.alts c) (fn [c]
                                (update-var c new-var))))
        (.var new-var)))

  (satisfied-by [c info]
    (or (and (instance? SumConstraint info)
             (every (.alts info)
                    (fn [info-c]
                      (some (.alts c)
                            (fn [c-c]
                              (satisfied-by c-c info-c))))))
        (some alts (fn [c]
                     (satisfied-by c info))))))

(def fn-constraint (FnConstraint {} empty-list no-symbol ""))
(def sym-constraint (SymbolConstraint no-symbol empty-list no-symbol ""))
(def vect-constraint (TypeConstraint {VectorType {}} empty-list 'Vector nothing ""))
(def list-constraint (TypeConstraint {ListType {}} empty-list 'List nothing ""))
(def seq-constraint (TypeConstraint {ListType {} VectorType {}} empty-list 'Sequence nothing ""))
(def substr-constraint (SubStrConstraint no-string empty-list no-symbol ""))
(def strbuff-constraint (StrBuffConstraint no-string empty-list no-symbol ""))
(def string-constraint (SumConstraint [strbuff-constraint substr-constraint]
                                      empty-list nothing ""))
(def hash-coll-constraint (TypeConstraint {HashCollisionNodeType {}}
                                          empty-list 'HashCollisionNode nothing ""))
(def array-constraint (TypeConstraint {ArrayNodeType {}} empty-list 'ArrayNode nothing ""))
(def bitmap-constraint (TypeConstraint {BitmapIndexedType {}} empty-list 'BitmapIndexedNode nothing ""))
(def hashmap-constraint (TypeConstraint {BitmapIndexedType {}
                                         ArrayNodeType {}
                                         HashCollisionNodeType {}}
                                        empty-list 'HashMap nothing ""))
(def int-constraint (IntegerConstraint no-int int-max int-min empty-list no-symbol ""))
(def maybe-constraint  (MaybeConstraint top-type empty-list no-symbol ""))
(def set-constraint (TypeConstraint {HashSetType {(Field 'set-map) hashmap-constraint}}
                                    empty-list 'HashSet  nothing ""))
(def agent-constraint (AgentConstraint top-type empty-list no-symbol ""))
(def promise-constraint (PromiseConstraint top-type empty-list no-symbol ""))
(def future-constraint (TypeConstraint {FutureType {}} empty-list 'Future nothing ""))
(def opaque-constraint (TypeConstraint {OpaqueType {}} empty-list 'Opaque nothing ""))
(def arity-constraint (TypeConstraint {FnArityType {}} empty-list 'FnArity nothing ""))

(def core-type-constraints {'Integer int-constraint
                            'StringBuffer strbuff-constraint
                            'SubString substr-constraint
                            'FnArity arity-constraint
                            'BitmapIndexedNode bitmap-constraint
                            'ArrayNode array-constraint
                            'HashCollisionNode hash-coll-constraint
                            'Fn fn-constraint
                            'List list-constraint
                            'Maybe maybe-constraint
                            'Vector vect-constraint
                            'Symbol sym-constraint
                            'HashMap hashmap-constraint
                            'Promise promise-constraint
                            'Future future-constraint
                            'Agent agent-constraint
                            'Opaque opaque-constraint})

(deftype DynamicFields [type-c fields path sym var]
  (assert (instance? TypeConstraint type-c))
  (assert (instance? (vector-of Field) fields))

  Stringable
  (string-list [_]
    (list "(c/DynamicFields "
          (str " " "(list)" ;; (cons 'list path)
               )
          " " (either (map sym (fn [s]
                                 (str "(maybe '" s ")")))
                      "nothing")
          " " (str "\"" var "\"")
          ")"))

  Eq
  (=* [x y]
    (and (instance? DynamicFields y)
         (maybe x))))

(deftype ParamConstraint [arity param-index item-indices mods path sym var]
  (assert (instance? Vector item-indices))

  Stringable
  (string-list [_]
    (list "(c/ParamConstraint " (str "'" arity) " " (str param-index) " " (str item-indices)
          "\n[" (to-str (interpose mods "\n"))
          "]\n(list)"
          ;; (str " " (cons 'list path))
          " " (either (map sym (fn [s]
                                 (str "(maybe '" s ")")))
                      "nothing")
          " " (str "\"" var "\"")
          ")"))

  Constraint
  (format-path [x desired-len]
    (format-path* (cons ["Parameter from" ""] path)
                  desired-len))

  (dynamic-params [c]
    [c])

  (set-arity [c new-arity]
    (.arity c new-arity))

  Eq
  (=* [x y]
    (and (instance? ParamConstraint y)
         (= param-index (.param-index y))
         (= mods (.mods y))
         (maybe x))))

(defn mod-param [c mod]
  (assert (instance? ParamConstraint c))

  (.mods c (conj (.mods c) mod)))

(deftype DynamicResultConstraint [arity invokable-c num-args path sym var]
  Stringable
  (string-list [_]
    (list "(c/DynamicResultConstraint " (str arity) " " (str invokable-c) " " (str num-args)
          (str " " (cons 'list path)) " " (either (map sym (fn [s]
                                                             (str "(maybe '" s ")")))
                                                  "nothing")
          " " (str "\"" var "\"") ")"))

  Eq
  (=* [x y]
    (and (instance? DynamicResultConstraint y)
         (= invokable-c (.invokable-c y))
         (maybe x)))

  Constraint
  (set-arity [c new-arity]
    (.arity c new-arity))

  (format-path [x desired-len]
    (format-path* (cons ["Dynamic Result at" ""] path)
                  desired-len)))

(deftype ReifiedFields [field-cs path sym var]
  (assert (instance? Vector field-cs))

  Stringable
  (string-list [_]
    (list "(c/ReifiedFields\n" (str "[" (to-str (interpose field-cs "\n")) "]")
          " (list)" ;; (str " " (cons 'list path))
          " " (either (map sym (fn [s]
                                 (str "(maybe '" s ")")))
                      "nothing")
          " " (str "\"" var "\"")
          ")"))

  Eq
  (=* [x y]
    (and (instance? ReifiedFields y)
         (= field-cs (.field-cs y))
         (maybe x))))

(def DynamicConstraint (any-of DynamicFields
                               ReifiedFields
                               ParamConstraint
                               DynamicResultConstraint))

;; Minimum Constraint Implementations
;; (deftype ParamConstraint [param-index]
;;   Stringable
;;   (string-list [_]
;;     (list "(ParamConstraint " (str param-index ")")))

;;   c/Constraint
;;   (c/intersect [c1 c2] c2)
;;   (c/satisfied-by [_ c] (maybe c))
;;   (c/intersect [_ c] c)
;;   (c/old-clear-sym [x] x)
;;   (c/update-sym [x _] x)
;;   (c/update-var [x v] x)
;;   (c/extract-collection-of [x] c/top-type)
;;   (c/old-extract-type-map [_] nothing)
;;   (c/extract-contents-constraint [_] c/top-type)
;;   (c/extract-coll-constraintraint [_] c/top-type)

;;   c/ConstraintOps
;;   (c/intersect-typec [c tc] tc)
;;   (c/intersect-multi [c mc] mc))

(def SymbolConstraints (any-of CoreValConstraint
                               TypeConstraint
                               InferredInner
                               StaticConstraints
                               ItemsConstraint
                               CollectionOf
                               SumConstraint
                               DynamicConstraint))

(deftype NoValues [constraints]
  Stringable
  (string-list [_]
    (list "(c/NoValues\n[" (to-str (interpose constraints "\n")) "])"))

  Constraint
  (intersect [nv _] nv)
  (update-sym [x _] x)
  (update-var [x _] x)

  (trim [c]
    (.constraints c (comp (remove constraints (partial instance? NoValues))
                          (-> constraints
                              (filter (partial instance? NoValues))
                              (flat-map .constraints)))))

  (format-path [c n]
    (let [max-len (-> (trim c)
                      .constraints
                      (map (fn [c] (count (assertion-path c))))
                      (reduce n (fn [max-len path-len]
                                  (either (> max-len path-len)
                                          path-len)))
                      inc)]
      (-> constraints
          (map (fn [c]
                 (format-path c max-len)))
          (list-zipper empty-list)
          (map (fn [strs]
                 (str (to-str (interpose strs "    "))
                      "\n"))))))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (or (and (empty? constraints)
                  (maybe y))
             (maybe x)))))

(def bottom-type (NoValues []))

(deftype MultiConstraint [constraints]
  (assert (instance? Vector constraints))

  Stringable
  (string-list [_]
    (list "(c/MultiConstraint\n[" (to-str (interpose constraints "\n")) "])"))

  Constraint
  (is-collection? [c]
    (some constraints is-collection?))

  (trim [c]
    (let [new-cs (-> constraints
                     (flat-map (fn [c]
                                 (either (map (instance? MultiConstraint c) .constraints)
                                         [c])))
                     ((fn [cs]
                        (and (< 1 (filter cs (partial instance? DynamicConstraint)))
                             (do
                               ;; TODO: remove after it triggers and is analyzed
                               (print-err 'BOOOOOMMMMM _LINE_ c)
                               (abort)
                               nothing))
                        cs))
                     (reduce {} (fn [m c]
                                  (let [c-name (type-name c)
                                        new-c (intersect c (either (get m c-name)
                                                                   top-type))]
                                    (assoc m c-name new-c))))
                     vals
                     (flat-map (fn [c]
                                 (either (map (instance? MultiConstraint c) .constraints)
                                         [c])))
                     vec
                     (remove (partial = top-type)))]
      (either (or (some new-cs (partial = bottom-type))
                  (map (some new-cs (partial instance? SumConstraint))
                       (fn [sum-c]
                         (reduce new-cs sum-c intersect)))
                  (and (empty? new-cs)
                       (maybe top-type))
                  (apply = new-cs))
              (.constraints c new-cs))))

  (reified-field [c _]
    (Right c))

  (filter-reified-field [c]
    (some constraints identity))

  (reified-fields [c]
    (Right c))

  (filter-reified-fields [c]
    (either (some constraints (partial instance? ReifiedFields))
            top-type))

  (dynamic-params [c]
    (either (-> constraints
                (remove empty?)
                first)
            []))

  (set-type [c tc]
    (trim (MultiConstraint (map constraints (fn [inner-c]
                                              (set-type inner-c tc))))))

  (extract-var [_]
    (either (some constraints (fn [c]
                                (let [var (extract-var c)]
                                  (or (and (= "" var)
                                           nothing)
                                      (maybe var)))))
            ""))

  (extract-sym [c]
    (some constraints extract-sym))

  (type-map [mc old-mc]
    ;; TODO: this might be a place to gain some performance back
    (let [types-maps (-> mc
                         .constraints
                         (reduce [] (fn [types-maps types-map]
                                      (either (map types-map (partial conj types-maps))
                                              types-maps))))]
      (for [types-map (first types-maps)]
        (-> types-maps
            rest
            (reduce types-map (fn [types-map m]
                                (select-keys types-map (keys m))))))))

  (update-sym [mc sym]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-sym c sym)))))

  (update-var [mc var]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-var c var)))))

  (format-path [_ n]
    (let [max-len (reduce (map constraints (fn [o]
                                             (either (map (get o .path)
                                                          count)
                                                     0)))
                          n
                          (fn [max-len path-len]
                            (either (> max-len path-len)
                                    path-len)))
          paths (map constraints (fn [c]
                                   (format-path c (inc max-len))))]
      (-> paths
          (list-zipper empty-list)
          (map (fn [strs]
                 (to-str (interpose strs "    ")))))))

  (assertion-path [c]
    (format-path c 0)))

(def ValueConstraint (any-of SymbolConstraints
                             MultiConstraint
                             AllValues))

(deftype ResultConstraint [assertion]
  Stringable
  (string-list [_] (list "(c/ResultConstraint " (str assertion) ")"))

  Constraint
  (update-var [_ new-var]
    (ResultConstraint (update-var assertion new-var)))

  (update-sym [_ new-var]
    (ResultConstraint (update-sym assertion new-var)))

  (type-map [c _]
    ;; TODO: if this is just a bare 'assertion', the types conflict
    (.assertion c)))

(def Constraints (any-of ValueConstraint
                         NoValues
                         ResultConstraint))

;; private operations on Constraints
(defprotocol ConstraintOps
  (is-bottom [c]
    )

  (intersect-fn [c fn-c]
    (assert (instance? FnConstraint fn-c))

    (NoValues [c fn-c]))

  (intersect-int [c int-c]
    (assert (instance? IntegerConstraint int-c))

    (NoValues [c int-c]))

  (intersect-sym [c sym-c]
    (assert (instance? SymbolConstraint sym-c))

    (NoValues [c sym-c]))

  (intersect-promise [c promise-c]
    (assert (instance? PromiseConstraint promise-c))

    (NoValues [c promise-c]))

  (intersect-agent [c agent-c]
    (assert (instance? AgentConstraint agent-c))

    (NoValues [c agent-c]))

  (intersect-str [c str-c]
    (assert (instance? StrConstraint str-c))

    (NoValues [c str-c]))

  (intersect-maybe [c maybe-c]
    (assert (instance? MaybeConstraint maybe-c))

    (NoValues [c maybe-c]))

  (extract-field [c fld]
    (assert (instance? Field fld)))

  (items-satisfied [info c]
    (assert (instance? ValueConstraint info))
    (assert (instance? ItemsConstraint c))
    (assert-result r (instance? (maybe-of ValueConstraint) r))

    nothing)

  (mult-satisfied [info c]
    (assert (instance? ValueConstraint info))
    (assert (instance? MultiConstraint c))
    (assert-result r (instance? (maybe-of ValueConstraint) r))

    (let [types-map (extract-type-map c)]
      (and (or (= nothing types-map)
               (flat-map types-map
                         (fn [types-map]
                           (satisfied-by (TypeConstraint types-map empty-list (symbol "<unknown>") nothing "")
                                         info))))
           (every (.constraints c)
                  (fn [inner-c]
                    (satisfied-by inner-c info)))
           (maybe info))))

  (sum-c-satisfies [info c]
    (assert (instance? ValueConstraint c))
    (assert-result r (instance? (maybe-of (maybe-of ValueConstraint)) r))

    nothing)

  (=-multi [y x]
    (assert (instance? MultiConstraint x))
    (assert-result r (instance? Maybe r))

    nothing)

  (intersect-param [c dyn-c]
    (assert (instance? ParamConstraint dyn-c))

    (mod-param dyn-c c))

  (intersect-result [c rc]
    (assert (instance? ResultConstraint rc))
    nothing)

  (=-result-constraint [y x]
    (assert (instance? ResultConstraint x))
    nothing)

  (intersect-typec [c tc]
    (assert (instance? TypeConstraint tc))
    (assert-result r (instance? Constraints r)))

  (=-contentsc [x y]
    nothing)

  (intersect-coll-of [c cc]
    (assert (instance? CollectionOf cc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var cc)) cc))

  (=-static-str [y x]
    nothing)

  (intersect-reified [c reified]
    (assert (instance? ReifiedFields reified))
    (assert-result r (instance? Maybe r))

    nothing)

  (=-static-len [y x]
    nothing)

  (intersect-static-len [c slc]
    (assert (instance? StaticLengthConstraint slc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var slc)) slc))

  (=-inferred-inner [y x]
    nothing)

  (intersect-sum [c cs]
    (assert (instance? SumConstraint cs))

    (let [goods (-> (.alts cs)
                    (map (partial intersect (update-var c (extract-var cs))))
                    (remove (partial instance? NoValues))
                    (reduce [] (fn [goods c]
                                 (either (and (some goods (partial = c))
                                              (maybe goods))
                                         (conj goods c)))))]
      (either (or (and (empty? goods)
                       (maybe (NoValues [c cs])))
                  (and (= (count goods) 1)
                       (first goods)))
              (.alts cs goods))))

  (intersect-inner [c ic]
    (assert (instance? InferredInner ic))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var ic)) ic))

  (=-items-constraint [y x]
    (assert (instance? ItemsConstraint x))
    nothing)

  (intersect-itemsc [c ic]
    (assert (instance? ItemsConstraint ic))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var ic)) ic))

  (intersect-multi [c mc]
    (assert (instance? MultiConstraint mc))
    (assert-result r (instance? Constraints r))

    ;; TODO: make sure that intersecting each type of constraint results
    ;; in the smallest set of .constraints in the MultiConstraint
    ;; applies to conj-multi as well.
    )

  (conj-multi [c mc]
    (assert (instance? MultiConstraint mc))))

(defn conflicting-assertions [failing-constraint file-name line-number]
  (apply print-err (list* "Conflicting assertions"
                           (either (= "" file-name)
                                   (str "at " file-name ": " line-number))
                           "\n"
                           (-> failing-constraint
                               ;; TODO: add file-name/line-number to empty paths
                               (format-path 0))))
  nothing)

(defn apply-param-mods [c dyn-c]
  (assert (instance? ParamConstraint dyn-c))

  (reduce (.mods dyn-c) c (fn [c mod]
                            (intersect mod c))))

(extend-type Vector
  Constraint
  (trim [v]
    (map v trim))

  (intersect [v c]
    (intersect (ItemsConstraint v coll-of-any empty-list nothing (extract-var c)) c)))

(extend-type Constraints
  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Constraint
  (coll-constraint [x]
    (collection-of x))

  (old-extract-items-constraints [c n]
    (-> c
        extract-items-constraints
        (comp (repeat n top-type))
        (take n)))

  (contents-constraint [_]
    (Right top-type)))

(extend-type NoValues
  ;; TODO: this is wrong and in the wrong place
  ;; Container
  ;; (map [x f]
  ;;   (.constraints x (f (.constraints x))))

  ;; (map [x f embed]
  ;;   (-> (.constraints x)
  ;;       f
  ;;       (map (partial .constraints x))))

  Constraint
  (collection-of [x]
    (Left x))

  ConstraintOps
  (intersect-str [c _] c)
  (intersect-int [c _] c)
  (intersect-sym [c _] c)
  (intersect-maybe [c _] c)
  (intersect-agent [c _] c)
  (intersect-promise [c _] c)
  (intersect-fn [c _] c)
  (is-bottom [c] c)
  (intersect-param [c _] c)
  (intersect-multi [c mc] c)
  (intersect-typec [c _] c)
  (conj-multi [c mc]
    (maybe c)))

(extend-type AllValues
  Constraint
  (collection-of [x]
    (Left x))

  ConstraintOps
  (intersect-str [_ c] c)
  (intersect-int [_ c] c)
  (intersect-sym [_ c] c)
  (intersect-maybe [_ c] c)
  (intersect-agent [_ c] c)
  (intersect-promise [_ c] c)
  (intersect-fn [_ c] c)
  (is-bottom [c] c)
  (extract-field [x _] x)
  (intersect-param [c dyn-c] dyn-c)
  (intersect-sum [c sc] sc)
  (intersect-result [c rc] rc)
  (intersect-typec [c tc] tc)
  (intersect-coll-of [c cc] cc)
  (intersect-static-len [c slc] slc)
  (intersect-inner [c ic] ic)
  (intersect-itemsc [c ic] ic)
  (intersect-multi [c mc] mc)
  (conj-multi [c mc]
    (maybe mc)))

(def map-keys
  (reify
    Stringable
    (string-list [_]
      (list "c/map-keys"))

    ;; TODO: should probably generate these automatically
    Eq
    (=* [x y]
      (and (= (get-type x) (get-type y))
           (maybe x)))

    Hashable
    (sha1-update [x ctxt]
      (sha1-update-type x ctxt)
      (sha1-update "type attribute map keys" ctxt))

    (sha1 [x]
      (let [ctxt (sha1-init)]
        (sha1-update x ctxt)
        (sha1-finalize ctxt)))

    Container
    (map [x _]
      x)

    (map [x _ embed]
      (embed x))

    ConstraintOps
    (is-bottom [x] x)))

(def map-values
  (reify
    Stringable
    (string-list [_]
      (list "c/map-values"))

    ;; TODO: should probably generate these automatically
    Eq
    (=* [x y]
      (and (= (get-type x) (get-type y))
           (maybe x)))

    Hashable
    (sha1-update [x ctxt]
      (sha1-update-type x ctxt)
      (sha1-update "type attribute map vals" ctxt))

    (sha1 [x]
      (let [ctxt (sha1-init)]
        (sha1-update x ctxt)
        (sha1-finalize ctxt)))

    Container
    (map [x _]
      x)

    (map [x _ embed]
      (embed x))

    ConstraintOps
    (is-bottom [x] x)))

(def static-value
  (reify
    Stringable
    (string-list [_]
      (list "c/static-value"))

    ;; TODO: should probably generate these automatically
    Eq
    (=* [x y]
      (and (= (get-type x) (get-type y))
           (maybe x)))

    Hashable
    (sha1-update [x ctxt]
      (sha1-update-type x ctxt)
      (sha1-update "type attribute static value" ctxt))

    (sha1 [x]
      (let [ctxt (sha1-init)]
        (sha1-update x ctxt)
        (sha1-finalize ctxt)))

    ConstraintOps
    (is-bottom [x] x)))

(defn merge-static-values [fields-map attrs1 attrs2]
  (either (or (for [v1 (get attrs1 static-value)
                    v2 (get attrs2 static-value)]
                (cond (= v1 v2)
                      (assoc fields-map static-value v1)
                      (assoc fields-map (Field (symbol "")) bottom-type)))
              (map (or (get attrs1 static-value)
                       (get attrs2 static-value))
                   (partial assoc fields-map static-value)))
         fields-map))

(defn check-hash-map-attrs [fields-map]
  (let [fields-map (either (for [key-c (get fields-map map-keys)
                                 bad-key-c (-> fields-map
                                               keys
                                               (filter (partial instance? Constraints))
                                               (some (fn [k]
                                                       (= bottom-type (intersect key-c k)))))]
                             (assoc fields-map map-keys bad-key-c))
                           fields-map)]
    (either (for [val-c (get fields-map map-values)
                  bad-val-c (-> fields-map
                                (dissoc map-keys map-values)
                                vals
                                (filter (partial instance? Constraints))
                                (some (fn [v]
                                        (= bottom-type (intersect val-c v)))))]
              (assoc fields-map map-values bad-val-c))
            fields-map)))

(defn intersect-attributes-map [attrs1 attrs2]
  (let [flds1 (dissoc attrs1 static-value)
        flds2 (dissoc attrs2 static-value)]
    ;; Order of calls is important
    (-> (merge-with intersect flds1 flds2)
        (merge-static-values attrs1 attrs2)
        check-hash-map-attrs)))

(defn intersect-type-maps [m1 tc]
  (assert (instance? TypeConstraint tc))

  ;; TOOD: this expression is too large. Refactor

  ;; TODO: don't try to pass bottom-type up
  (let [m2 (.type-maps tc)
        prototype-cs (either (or (for [attrs1 (get m1 UnknownType)
                                       attrs2 (get m2 UnknownType)]
                                   (intersect-attributes-map attrs1 attrs2))
                                 (get m1 UnknownType)
                                 (get m2 UnknownType))
                             {})
        required-fields (-> (vec prototype-cs)
                            (filter (fn [[fld _]]
                                      (instance? Field fld))))
        m1 (dissoc m1 UnknownType)
        m2 (dissoc m2 UnknownType)
        new-map (cond (and (empty? m1) (empty? m2))
                      {UnknownType prototype-cs}

                      (empty? m1)
                      m2

                      (empty? m2)
                      m1
                      
                      (merge-with intersect-attributes-map
                                  (select-keys m1 (keys m2))
                                  (select-keys m2 (keys m1))))
        checked-fields (cond (empty? required-fields)
                             (-> new-map
                                 vec
                                 (map (fn [[type-num fields-map]]
                                        (either (some (vals fields-map)
                                                      (partial = bottom-type))
                                                [type-num fields-map]))))

                             (-> (vec new-map)
                                 (map (fn [[type-num fields-map]]
                                        (either (map (every required-fields
                                                            (fn [[req-field fld-c]]
                                                              (map (get fields-map req-field)
                                                                   (fn [val-c]
                                                                     (let [fld-inter (intersect val-c fld-c)]
                                                                       (either (= bottom-type fld-inter)
                                                                               [req-field fld-inter]))))))
                                                     (fn [flds]
                                                       (either (some flds
                                                                     (fn [x]
                                                                       (or (= x bottom-type)
                                                                           (flat-map (second x)
                                                                                     (partial = bottom-type)))))
                                                               [type-num (reduce flds fields-map
                                                                                 (fn [m [k v]]
                                                                                   (assoc m k v)))])))
                                                bottom-type)))))
        final-map (-> checked-fields
                      (remove (partial = bottom-type))
                      (reduce {} (fn [m [type-num fields-map]]
                                   (assoc m type-num fields-map))))]
    (either (or (and (empty? new-map)
                     (maybe bottom-type))
                (and (empty? final-map)
                     (or (-> checked-fields
                             (filter (partial = bottom-type))
                             first)

                         (maybe bottom-type))))
            (.type-maps tc final-map))))

(extend-type SymbolConstraints
  Constraint
  (clear-var [c]
    (.var c ""))

  (set-path [c new-path]
    (Left (.path c new-path)))

  (extract-sym [c]
    (.sym c))

  (collection-of [x]
    (Right top-type))

  (extract-var [c]
    (.var c))

  (add-to-path [constraint file-name line-number]
    (let [new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (either (and (= "" file-name)
                   (maybe constraint))
              (.path constraint new-path))))

  (remove-sym [tc]
    (Left (.sym tc nothing)))

  (update-sym [tc new-sym]
    (.sym tc (maybe new-sym)))

  (update-var [tc new-var]
    (.var tc new-var))

  ConstraintOps
  (is-bottom [c] c)

  (intersect-multi [c mc]
    (assert (instance? MultiConstraint mc))
    (assert-result r (instance? Constraints r))

    (either (or (-> (.constraints mc)
                    (map (partial intersect c))
                    (some (partial instance? NoValues)))
                (and (some (.constraints mc) (partial = c))
                     (maybe mc)))
            (conj mc c)))

  (conj-multi [c mc]
    (assert (instance? MultiConstraint mc))

    (either (and (some (.constraints mc) (partial = c))
                 (maybe mc))
            (MultiConstraint (conj (.constraints mc) c))))

  (intersect-typec [c tc]
    (assert (instance? TypeConstraint tc))
    (assert-result r (instance? Constraints r))

    (either (for [types-map (extract-type-map c)]
              (let [result-c (cata is-bottom (intersect-type-maps types-map tc))]
                (cond (and (= bottom-type result-c)
                           (empty? (.constraints result-c)))
                      (NoValues [c tc])
                      result-c)))
            (intersect (update-var c (extract-var tc)) tc))))

(defn clear-vars [c]
  (cata clear-var c))

(defn sum-type [const-cs]
  (assert (instance? Vector const-cs))

  (either (or (flat-map (every const-cs (partial = bottom-type))
                        (fn [_]
                          (first const-cs)))
              (let [const-cs (remove const-cs (partial = bottom-type))]
                (or (and (= 1 (count const-cs))
                         (first const-cs))
                    (and (empty? const-cs)
                         (maybe top-type))
                    (some const-cs (partial = top-type))
                    (apply = const-cs)
                    (and (every const-cs (partial instance? CollectionOf))
                         (-> const-cs
                             (map .contents)
                             sum-type
                             (CollectionOf empty-list nothing "")
                             maybe))
                    (and (< 1 (count const-cs))
                         (maybe (SumConstraint const-cs empty-list nothing ""))))))
          top-type))

(extend-type CoreValConstraint
  Constraint
  (assertion-path [x] (.path x))

  (format-path [x desired-len]
    (format-path* (cons [(str (get-type-sym x)) " from:" ""] (.path x))
                  desired-len))

  (extract-sym [c]
    (either (and (= (.sym c) no-symbol)
                 (maybe nothing))
            (maybe (.sym c))))

  (remove-sym [tc]
    (Left (.sym tc no-symbol)))

  (update-sym [tc new-sym]
    (.sym tc new-sym))

  ConstraintOps
  (intersect-multi [c mc]
    (assert (instance? MultiConstraint mc))

    (NoValues [c mc]))

  (conj-multi [c mc]
    (assert (instance? MultiConstraint mc))

    (NoValues [c mc]))

  (intersect-typec [c tc]
    (assert (instance? TypeConstraint tc))

    (NoValues [c tc]))

  (intersect-coll-of [c cc]
    (assert (instance? CollectionOf cc))

    (NoValues [c cc]))

  (intersect-static-len [c slc]
    (assert (instance? StaticLengthConstraint slc))

    (NoValues [c slc]))

  (intersect-inner [c ic]
    (assert (instance? InferredInner ic))

    (NoValues [c ic]))

  (intersect-itemsc [c ic]
    (assert (instance? ItemsConstraint ic))

    (NoValues [c ic])))

(extend-type IntegerConstraint
  Constraint
  (intersect [x y]
    (intersect-int y x))

  ConstraintOps
  (intersect-int [y x]
    (let [new-min (either (> (.min x) (.min y))
                          (.min y))
          new-max (either (< (.max x) (.max y))
                          (.max y))
          new-static (or (= no-int (.static-value x) (.static-value y))
                         (flat-map (or (= (.static-value x) (.static-value y))
                                       (= (.static-value y) (.static-value x)))
                                   (fn [new-static]
                                     (and (<= new-min new-static new-max)
                                          (maybe new-static)))))]
      (either (map new-static (fn [new-static]
                                ;; TODO: use the path from the most restrictive constraint
                                ;; determined by satisfied-by
                                (-> x
                                    (.static-value new-static)
                                    (.min new-min)
                                    (.max new-max))))
              (NoValues [x y]))))

  (is-bottom [c] c))

(extend-type SymbolConstraint
  Constraint
  (intersect [x y]
    (intersect-sym y x))

  ConstraintOps
  (intersect-sym [x y]
    (either (map (or (= (.static-value x) (.static-value y))
                     (= (.static-value y) (.static-value x)))
                 ;; TODO: use the path from the most restrictive constraint
                 ;; determined by satisfied-by
                 (partial .static-value x))
            (NoValues [x y])))

  (is-bottom [c] c))

(extend-type StrConstraint
  Constraint
  (intersect [x y]
    (intersect-str y x))

  ConstraintOps
  (intersect-coll-of [str-c c]
    (intersect-str (.contents c) strbuff-constraint))

  (intersect-inner [str-c c]
    (intersect-str (.contents c) strbuff-constraint))

  (intersect-str [y x]
    (either (map (or (= (.static-value x) (.static-value y))
                     (= (.static-value y) (.static-value x)))
                 ;; TODO: use the path from the most restrictive constraint
                 ;; determined by satisfied-by
                 (partial .static-value x))
            (NoValues [x y])))

  (is-bottom [c] c))

(extend-type MaybeConstraint
  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (map (f (.contents x))
         (partial .contents x)))

  Constraint
  (intersect [x y]
    (intersect-maybe y x))

  ConstraintOps
  (intersect-coll-of [x y]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (intersect-inner [x y]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (intersect-maybe [y x]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (intersect-param [c dyn-c]
    (mod-param dyn-c c))

  (is-bottom [c]
    (either (= bottom-type (.contents c))
              c)))

(extend-type PromiseConstraint
  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (map (f (.contents x))
         (partial .contents x)))

  Constraint
  (intersect [x y]
    (intersect-promise y x))

  ConstraintOps
  (intersect-coll-of [x y]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (intersect-inner [x y]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (intersect-promise [y x]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (intersect-param [c dyn-c]
    (mod-param dyn-c c))

  (is-bottom [c]
    (either (= bottom-type (.contents c))
              c)))

(extend-type AgentConstraint
  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (map (f (.contents x))
         (partial .contents x)))

  Constraint
  (intersect [x y]
    (intersect-agent y x))

  ConstraintOps
  (intersect-coll-of [x y]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (intersect-inner [x y]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (intersect-agent [y x]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (intersect-param [c dyn-c]
    (mod-param dyn-c c))

  (is-bottom [c]
    (either (= bottom-type (.contents c))
              c)))

(extend-type ItemsConstraint
  Container
  (map [x f]
    (-> x
        (.tail-constraint (f (.tail-constraint x)))
        (.items-constraints (map (.items-constraints x) f))))

  (map [x f embed]
    (for [new-tail (f (.tail-constraint x))
          new-items (map (.items-constraints x) f embed)]
      (-> x
          (.tail-constraint new-tail)
          (.items-constraints new-items))))

  Eq
  (=* [x y]
    (=-items-constraint y x))

  ConstraintOps
  (is-bottom [c]
    ;; TODO: always choose bottom-type with non-empty constraints if possible
    (either (or (some (.items-constraints c) (partial = bottom-type))
                (= bottom-type (.tail-constraint c)))
            c))

  (items-satisfied [info c]
    (let [c-items (.items-constraints c)
          info-items (extract-items-constraints info (count c-items))]
      (and (<= (count c-items) (count (.items-constraints info)))
           (every (zip-lists c-items info-items)
                  (fn [[c info]]
                    (satisfied-by c info)))
           (satisfied-by (.tail-constraint c) (.tail-constraint info))
           (maybe info))))

  (intersect-coll-of [c cc]
    (let [new-items (map (.items-constraints c)
                         (fn [c]
                           (-> (.contents cc)
                               (intersect c)
                               (update-var (extract-var c)))))
          new-tail (either (= (.tail-constraint c) bottom-type)
                           (intersect cc (.tail-constraint c)))]
      (either (or (some new-items (partial = bottom-type))
                  (cond (= (.tail-constraint c) bottom-type)
                        nothing
                        (= new-tail bottom-type)))
              (-> c
                  (.items-constraints new-items)
                  (.tail-constraint new-tail)))))

  (intersect-static-len [c slc]
    (let [items-count (count (extract-items-constraints c))]
      (cond (or (< (.length slc) items-count)
                (and (< items-count (.length slc))
                     (= bottom-type (.tail-constraint c))))
            (NoValues [slc c])
            ;; TODO: return ItemsConstraint with correct number of items-constraints
            ;; and NoValues tail
            (MultiConstraint [slc c]))))

  (intersect-inner [c ic]
    (let [new-items (map (.items-constraints c)
                         (fn [c]
                           (-> (.contents ic)
                               (intersect c)
                               (update-var (extract-var c)))))
          new-tail (either (= (.tail-constraint c) bottom-type)
                           (intersect ic (.tail-constraint c)))]
      (either (or (some new-items (partial = bottom-type))
                  (cond (= (.tail-constraint c) bottom-type)
                        nothing
                        (= new-tail bottom-type)))
              (-> c
                  (.items-constraints new-items)
                  (.tail-constraint new-tail)))))

  (intersect-typec [c tc]
    (assert (instance? TypeConstraint tc))

    (either (for [types-map (extract-type-map tc)
                  good-type-map (extract-type-map c)
                  :let [new-map (select-keys types-map (keys good-type-map))]
                  :when-not (empty? new-map)]
              (MultiConstraint [(.type-maps tc new-map)
                                (update-var c (extract-var tc))]))
            (NoValues [c tc])))

  (intersect-itemsc [c ic]
    (assert (instance? ItemsConstraint ic))

    (let [c (cata trim c)
          ic (cata trim ic)
          cnt-ic (count (.items-constraints ic))
          cnt-c (count (.items-constraints c))
          max-cnt (either (> cnt-ic cnt-c)
                          cnt-c)
          constraints (map (zip-lists (extract-items-constraints ic max-cnt)
                                      (extract-items-constraints c max-cnt))
                           (fn [[c1 c2]]
                             (intersect c1 c2)))
          new-tail (intersect (.tail-constraint ic)
                              (.tail-constraint c))
          new-ic (-> ic
                     (.tail-constraint new-tail)
                     (.items-constraints (vec constraints)))]
      (either (some constraints (fn [c]
                                  (= c bottom-type)))
              (cond (or (= bottom-type (.tail-constraint ic))
                        (= bottom-type (.tail-constraint c)))
                    new-ic

                    (either (= bottom-type new-tail)
                            new-ic)))))

  (=-items-constraint [y x]
    (and (= (.items-constraints y) (.items-constraints x))
         (= (.tail-constraint y) (.tail-constraint x))
         (maybe x)))

  Constraint
  (get-tail-constraint [c old-ic]
    (.tail-constraint c))

  (fixed-items-constraints [c old-ic]
    (comp (.items-constraints old-ic)
          (.tail-constraint c)))

  (old-extract-items-constraints [c n]
    (either (and (<= n 0)
                 (maybe []))
            (let [needed-tail-items (- n (count (.items-constraints c)))
                  tail-items (-> c
                                 .tail-constraint
                                 (old-extract-items-constraints needed-tail-items))]
              (-> c
                  .items-constraints
                  (comp tail-items (repeat n top-type))
                  (take n)))))

  (contents-constraint [c]
    (Left (-> (.items-constraints c)
              (conj (extract-contents-constraint (.tail-constraint c)))
              sum-type)))

  (satisfied-by [c info]
    (items-satisfied info c))

  (intersect [ic c]
    (either (=-items-constraint c ic)
            (intersect-itemsc c ic))))

(extend-type MultiConstraint
  Container
  (map [x f]
    (.constraints x (map (.constraints x) f)))

  (map [x f embed]
    (-> (.constraints x)
        (map f embed)
        (map (partial .constraints x))))

  Eq
  (=* [x y]
    (=-multi y x))

  Collection
  (conj [mc c]
    (assert (instance? SymbolConstraints c))

    (conj-multi c mc))

  ConstraintOps
  (is-bottom [c]
    ;; TODO: always choose bottom-type with non-empty constraints if possible
    (either (some (.constraints c) (partial = bottom-type))
            c))

  (items-satisfied [info c]
    (flat-map (some (.constraints info) (partial instance? ItemsConstraint))
              (fn [info-itemsc]
                (items-satisfied info-itemsc c))))

  (=-multi [y x]
    (and (every (.constraints x)
                (fn [x]
                  (some (.constraints y)
                        (fn [y]
                          (= x y)))))
         (maybe x)))

  (intersect-sum [c sc]
    (either (= (reduce (.constraints c) sc
                       (fn [x y]
                         (either (= (intersect x y) bottom-type)
                                 x)))
               bottom-type)
            (conj (update-var c (extract-var sc)) sc)))

  (intersect-inner [c ic]
    (either (= (reduce (.constraints c) ic
                       (fn [x y]
                         (either (= (intersect x y) bottom-type)
                                 x)))
               bottom-type)
            (conj c ic)))

  (intersect-typec [c tc]
    (intersect c tc))

  (conj-multi [c mc]
    (reduce (.constraints c) mc conj))

  (intersect-multi [c mc]
    (reduce (.constraints c) mc
            (fn [mc new-c]
              (either (= mc bottom-type)
                      (intersect mc new-c)))))

  (mult-satisfied [mult-info mult-c]
    (let [types-map (extract-type-map mult-c)]
      (and (or (= nothing types-map)
               (flat-map types-map
                         (fn [types-map]
                           (satisfied-by (TypeConstraint types-map empty-list (symbol "<unknown>") nothing "")
                                         mult-info))))
           (every (.constraints mult-c)
                  (fn [inner-c]
                    (some (.constraints mult-info)
                          (partial satisfied-by inner-c))))

           (maybe mult-info))))

  Constraint
  (collection-of [c]
    (Right c))

  (intersect [mc c]
    (intersect-multi c mc))

  (contents-constraint [mc]
    (Left (-> (.constraints mc)
              (filter (fn [c]
                        (or (instance? CollectionOf c)
                            (instance? InferredInner c)
                            (instance? ItemsConstraint c))))
              (map extract-contents-constraint)
              (reduce top-type intersect))))

  (satisfied-by [mult-c info]
    (mult-satisfied info mult-c))

  (get-tail-constraint [mc old-mc]
    (either (map (is-collection? old-mc)
                 (fn [_]
                   (-> (zip-lists (.constraints old-mc) (.constraints mc))
                       (filter (fn [[old-c]]
                                 (is-collection? old-c)))
                       (reduce top-type (fn [final-c [_ curr-c]]
                                          (intersect final-c curr-c))))))
            bottom-type))

  (fixed-items-constraints [mc old-mc]
    (let [coll-c (-> old-mc
                     extract-coll-constraint
                     extract-contents-constraint)
          ics (either (-> (.constraints mc)
                          (some (fn [v]
                                  (and (first v)
                                       (maybe v))))
                          (map (fn [fixed-ic]
                                 (map fixed-ic (fn [c]
                                                 (-> c
                                                     (intersect coll-c)
                                                     (update-var (extract-var c))))))))
                      [])]
      (either (map (some (.constraints old-mc)
                         (partial instance? StaticLengthConstraint))
                   (fn [len-c]
                     (take ics (.length len-c))))
              ics)))

  (old-extract-items-constraints [c n]
    (-> c
        .constraints
        (map (fn [c]
               (old-extract-items-constraints c n)))
        ((partial apply zip-lists))
        (map (fn [cs]
               (reduce cs top-type intersect)))
        vec)))

(extend-type ResultConstraint
  Container
  (map [x f]
    (.assertion x (f (.assertion x))))

  (map [x f embed]
    (-> (.assertion x)
        f
        (map (partial .assertion x))))

  Eq
  (=* [x y]
    (and (or (=-result-constraint y x)
             (=* (.assertion x) y))
         (maybe x)))

  Constraint
  (intersect [rc c]
    (let [intersected (either (intersect-result c rc)
                              (intersect (.assertion rc) c))]
      (either (= intersected bottom-type)
              (ResultConstraint intersected))))

  ConstraintOps
  (is-bottom [c]
    (either (= (.assertion c) bottom-type)
            c))

  (=-result-constraint [y x]
    (=* (.assertion x) (.assertion y)))

  (intersect-result [c rc]
    (maybe (intersect (.assertion rc) (.assertion c)))))

(extend-type TypeConstraint
  Container
  (map [tc f]
    (.type-maps tc (map-vals (.type-maps tc)
                             (fn [type-fields]
                               (-> type-fields
                                   vec
                                   (map (fn [[fld fld-c]]
                                          ;; TODO: when you can use reified values in 'any-of',
                                          ;; change this to instance? LeafFields, etc. etc.
                                          (cond (= static-value fld)
                                                [fld fld-c]
                                                [(f fld) (f fld-c)])))
                                   (reduce {} (fn [m [k v]]
                                                (assoc m k v))))))))

  (map [tc f embed]
    (map (contextual-map-vals (.type-maps tc)
                              (fn [type-fields]
                                (-> type-fields
                                    vec
                                    (map (fn [[fld fld-c]]
                                           (cond (= static-value fld)
                                                 (embed [fld fld-c])
                                                 (for [new-fld (f fld)
                                                       new-c (f fld-c)]
                                                   [new-fld new-c])))
                                         embed)
                                    (map (fn [new-flds]
                                           (reduce new-flds {} (fn [m [k v]]
                                                                 (assoc m k v)))))))
                              embed)
         (partial .type-maps tc)))

  Constraint
  (add-to-path [constraint file-name line-number]
    (let [new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))
          type-maps (map-vals (.type-maps constraint)
                              (fn [fields-map]
                                (map-vals fields-map
                                          (fn [field-c]
                                            (add-to-path field-c file-name line-number)))))]
      (either (and (= "" file-name)
                   (maybe constraint))
              (-> constraint
                  (.type-maps type-maps)
                  (.path new-path)))))

  (contents-constraint [c]
    (Left (either (instance? StrConstraint c)
                  top-type)))

  (set-type [c tc]
    ;; only used to switch ListType to VectorType or vice versa
    ;; TODO: actually, could be used on HashMaps as well. Maybe
    (either (or (and (= top-type tc)
                     (maybe c))
                (for [c-map (extract-type-map c)
                      tc-map (extract-type-map tc)
                      new-map (or (and (get tc-map ListType)
                                       (-> c-map
                                           (dissoc VectorType)
                                           (assoc ListType {})
                                           maybe))
                                  (and (get tc-map VectorType)
                                       (-> c-map
                                           (dissoc ListType)
                                           (assoc VectorType {})
                                           maybe)))]
                  (-> c
                      (.type-maps new-map)
                      (.type-sym (cond (= {ListType {}} new-map)
                                       'List

                                       (= {VectorType {}} new-map)
                                       'Vector

                                       (get new-map ListType)
                                       (symbol "List or something else")

                                       (symbol "Vector or something else"))))))
            top-type))

  (intersect [tc c]
    (intersect-typec c tc))

  (satisfied-by [c info]
    (either (sum-c-satisfies info c)
            (flat-map (extract-type-map info)
                      (fn [value-type-map]
                        (and (< 0 (count value-type-map))
                             (every (keys value-type-map)
                                    (partial get (.type-maps c)))
                             (maybe info))))))

  ConstraintOps
  (is-bottom [c]
    ;; TODO: always choose bottom-type with non-empty constraints if possible
    (either (some (flat-map (vec (.type-maps c))
                            (fn [[_ fld-map]]
                              (flatten (vec fld-map))))
                  (partial = bottom-type))
            c))

  (extract-field [c fld]
    (either (for [types-map (extract-type-map c)
                  alts (apply (maybe vector) (-> types-map
                                                 vals
                                                 (map (fn [fields]
                                                        (get fields fld)))
                                                 (filter identity)))
                  :when-not (empty? alts)]
              (sum-type alts))
            (NoValues [c (TypeConstraint {0 {fld top-type}} empty-list
                                         (symbol (str "field '" (.sym fld) "' required"))
                                         nothing "")])))

  (conj-multi [c mc]
    (intersect-multi c mc))

  (intersect-multi [c mc]
    (assert (instance? MultiConstraint mc))
    (assert-result r (instance? Constraints r))

    (either (or (= (reduce (.constraints mc) c
                           (fn [x y]
                             (either (= (intersect x y) bottom-type)
                                     x)))
                   bottom-type)
                (flat-map (extract-type-map mc)
                          (fn [new-map]
                            (and (> (count new-map) 1)
                                 (= (intersect-typec c (.type-maps c new-map))
                                    bottom-type))))
                (and (some (.constraints mc) (partial = c))
                     (maybe mc)))
            (MultiConstraint (conj (.constraints mc) c))))

  (intersect-coll-of [c ic]
    (let [new-type-map (.type-maps c)]
      (either (or (and (empty? new-type-map)
                       (maybe (NoValues [ic c])))
                  (= bottom-type (intersect (extract-contents-constraint c)
                                            (.contents ic))))
              (MultiConstraint [ic (-> c
                                       (.type-maps new-type-map)
                                       (update-var (extract-var ic)))]))))

  (intersect-inner [c ic]
    (let [new-type-map (.type-maps c)]
      (either (or (and (empty? new-type-map)
                       (maybe (NoValues [ic c])))
                  (= bottom-type (intersect (extract-contents-constraint c)
                                            (.contents ic))))
              (MultiConstraint [ic (-> c
                                       (.type-maps new-type-map)
                                       (update-var (extract-var ic)))])))))

(defn core-containers [c]
  (SumConstraint [(TypeConstraint {VectorType {}
                                   ListType {}
                                   BitmapIndexedType {}
                                   ArrayNodeType {}
                                   HashCollisionNodeType {}}
                                  (.path c) 'CoreContainers (.sym c) (extract-var c))
                  (AgentConstraint top-type (.path c) (.sym c) (extract-var c))
                  (PromiseConstraint top-type (.path c) (.sym c) (extract-var c))
                  (MaybeConstraint top-type (.path c) (.sym c) (extract-var c))]
                 (.path c) (.sym c) (extract-var c)))

(extend-type InferredInner
  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (-> (.contents x)
        f
        (map (partial .contents x))))

  Eq
  (=* [x y]
    (=-inferred-inner y x))

  Constraint
  (old-extract-items-constraints [c n]
    (either (and (flat-map (extract-type-map c) empty?)
                 (maybe []))
            (vec (repeat n (.contents c)))))

  (satisfied-by [c coll-info]
    (assert-result r (instance? (maybe-of ValueConstraint) r))

    (and (or (and (= (.contents c) top-type)
                  (satisfied-by (core-containers c) coll-info))
             (satisfied-by (.contents c) (extract-contents-constraint coll-info)))
         (maybe coll-info)))

  (coll-constraint [c]
    (Left (CollectionOf (.contents c) (.path c) (.sym c) (extract-var c))))

  (contents-constraint [c]
    (Left (.contents c)))

  (intersect [ic c]
    (intersect-inner c ic))

  ConstraintOps
  (is-bottom [c]
    (either (= (.contents c) bottom-type)
            c))

  (intersect-str [c str-c]
    (intersect-inner str-c c))

  (intersect-promise [c promise-c]
    (intersect-inner promise-c c))

  (intersect-agent [c agent-c]
    (intersect-inner agent-c c))

  (intersect-maybe [c maybe-c]
    (intersect-inner maybe-c c))

  (intersect-multi [c mc]
    (let [new-c (intersect (.contents c)
                           (extract-contents-constraint mc))]
      (either (or (= new-c bottom-type)
                  (and (= new-c top-type)
                       (maybe mc)))
              (-> mc
                  (.constraints (remove (.constraints mc)
                                        (partial instance? InferredInner)))
                  (conj (.contents c new-c))))))

  (intersect-coll-of [c cc]
    (let [new-inner (intersect (.contents cc) (.contents c))]
      (either (= new-inner bottom-type)
              (.contents cc new-inner))))

  (intersect-static-len [c slc]
    (MultiConstraint [slc c]))

  (=-inferred-inner [y x]
    (and (= (.contents x) (.contents y))
         (maybe x)))

  (intersect-inner [c ic]
    (let [new-c (intersect (.contents ic) (.contents c))]
      (either (= new-c bottom-type)
              (.contents ic new-c)))))

(extend-type StaticLengthConstraint
  Eq
  (=* [x y]
    (=-static-len y x))

  Constraint
  (satisfied-by [c info]
    (and (or (and (instance? StaticLengthConstraint info)
                  (<= (.length c) (.length info)))
             (and (instance? ItemsConstraint info)
                  (<= (.length c) (count (.items-constraints info)))))
         (maybe info)))

  (intersect [slc c]
    (intersect-static-len c slc))

  ConstraintOps
  (items-satisfied [info c]
    (and (every (extract-items-constraints c (.length info))
                (partial = top-type))
         (maybe info)))

  (intersect-coll-of [c cc]
    (MultiConstraint [cc (update-var c (extract-var cc))]))

  (intersect-static-len [c slc]
    (either (= slc c)
            (NoValues [slc c])))

  (=-static-len [y x]
    (and (= (.length x) (.length y))
         (maybe x))))

(extend-type CollectionOf
  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (-> (.contents x)
        f
        (map (partial .contents x))))

  Eq
  (=* [x y]
    (=-contentsc y x))

  Constraint
  (coll-constraint [c]
    (Left c))

  (satisfied-by [c coll-info]
    (assert-result r (instance? (maybe-of ValueConstraint) r))

    (and (or (and (= (.contents c) top-type)
                  (satisfied-by (core-containers c) coll-info))
             (satisfied-by (.contents c) (extract-contents-constraint coll-info)))
         (maybe coll-info)))

  (contents-constraint [c]
    (Left (.contents c)))

  (collection-of [x]
    (Left x))

  (old-extract-items-constraints [c n]
    (either (and (flat-map (extract-type-map c) empty?)
                 (maybe []))
            (vec (repeat n (.contents c)))))

  (type-map [c _]
    (maybe {ListType {}
            BitmapIndexedType {}
            ArrayNodeType {}
            HashCollisionNodeType {}
            HashSetType {(Field 'set-map) hashmap-constraint}
            FutureType {}
            FunctionType {}
            VectorType {}}))

  (intersect [cc c]
    (intersect-coll-of c cc))

  ConstraintOps
  (intersect-str [c str-c]
    (intersect-coll-of str-c c))

  (intersect-maybe [c maybe-c]
    (intersect-coll-of maybe-c c))

  (intersect-promise [c promise-c]
    (intersect-coll-of promise-c c))

  (intersect-agent [c agent-c]
    (intersect-coll-of agent-c c))

  (is-bottom [c]
    (either (= (.contents c) bottom-type)
            c))

  (intersect-typec [c tc]
    (intersect-coll-of tc c))

  (intersect-multi [c mc]
    (let [inters (map (.constraints mc) (partial intersect c))]
      (either (some inters (partial instance? NoValues))
              (-> mc
                  (.constraints (remove (.constraints mc)
                                        (partial instance? CollectionOf)))
                  (conj (-> (.constraints mc)
                            (filter (partial instance? CollectionOf))
                            (reduce c intersect)))))))

  (intersect-inner [c ic]
    (let [new-c (intersect (.contents c) (.contents ic))]
      (either (= new-c bottom-type)
              (.contents c new-c))))

  (intersect-static-len [c slc]
    (MultiConstraint [slc c]))

  (intersect-coll-of [c cc]
    (let [new-cs (intersect (.contents cc) (.contents c))]
      (either (or (= new-cs bottom-type)
                  (= cc c))
              (.contents cc new-cs))))

  (=-contentsc [x y]
    (and (= (.contents x) (.contents y))
         (maybe x))))

(extend-type SumConstraint
  Container
  (map [x f]
    (.alts x (map (.alts x) f)))

  (map [x f embed]
    (-> (.alts x)
        (map f embed)
        (map (partial .alts x))))

  Constraint
  (trim [c]
    (let [all-alts (flat-map (.alts c) (fn [c]
                                         (either (map (instance? SumConstraint c) .alts)
                                                 [c])))
          trimmed (-> (sum-type all-alts)
                      (update-var (.var c))
                      ((fn [new-c]
                         (either (map (.sym c)
                                      (partial update-sym new-c))
                                 new-c))))]
      (either (map (instance? SumConstraint trimmed)
                   (fn [_]
                     (replace-path trimmed (.path c))))
              trimmed)))

  (dynamic-params [c]
    (comp* [] (seq (.alts c))))

  (set-type [c tc]
    (-> c
        (.alts (-> (.alts c)
                   (map (fn [inner-c]
                          (set-type inner-c tc)))
                   (remove (partial = bottom-type))))
        trim))

  (intersect [sc c]
    (intersect-sum c sc))

  (fixed-items-constraints [c old-sumc]
    (-> old-sumc
        (extract-items-constraints (-> (.alts c)
                                       (reduce 0 (fn [max cs]
                                                   (let [n (count cs)]
                                                     (either (> max n)
                                                             n))))))
        (map (fn [c]
               (update-var c "")))))

  (old-extract-items-constraints [c n]
    (-> (apply zip-lists (map (.alts c) (fn [alt]
                                          (old-extract-items-constraints alt n))))
        (map (fn [new-alts]
               (either (or (some new-alts (partial = top-type))
                           (apply = new-alts))
                       (.alts c (vec new-alts)))))
        vec
        (map (fn [c]
               (update-var c "")))))

  (contents-constraint [c]
    (Right c))

  ConstraintOps
  (is-bottom [c]
    ;; TODO: always choose bottom-type with non-empty constraints if possible
    (either (some (.alts c) (partial = bottom-type))
            c))

  (intersect-int [sum-c c]
    (intersect-sum c sum-c))

  (intersect-fn [sum-c c]
    (intersect-sum c sum-c))

  (intersect-sym [sum-c c]
    (intersect-sum c sum-c))

  (intersect-str [sum-c c]
    (intersect-sum c sum-c))

  (intersect-maybe [sum-c c]
    (intersect-sum c sum-c))

  (intersect-promise [sum-c c]
    (intersect-sum c sum-c))

  (intersect-agent [sum-c c]
    (intersect-sum c sum-c))

  (extract-field [c fld]
    (either (for [types-map (extract-type-map c)
                  alts (apply (maybe vector) (-> types-map
                                                 vals
                                                 (map (fn [fields]
                                                        (get fields fld)))
                                                 (filter identity)))
                  :when-not (empty? alts)]
              (sum-type alts))
            (NoValues [c (TypeConstraint {0 {fld top-type}} empty-list
                                         (symbol (str "field '" (.sym fld) "' required"))
                                         nothing "")])))

  (mult-satisfied [c mult-c]
    (either (sum-c-satisfies c mult-c)
            nothing))

  (sum-c-satisfies [info c]
    (maybe (and (every (.alts info) (partial satisfied-by c))
                (maybe c))))

  (intersect-sum [c1 c2]
    (let [new-alts (for [a1 (.alts c1)
                         a2 (.alts c2)
                         :let [new-alt (intersect a1 a2)]
                         :when-not (= bottom-type new-alt)]
                     new-alt)
          new-alts (reduce new-alts [] (fn [new-alts alt]
                                         (either (and (some new-alts (partial =* alt))
                                                      (maybe new-alts))
                                                 (conj new-alts alt))))]
      (either (or (and (empty? new-alts)
                       (maybe (NoValues [c1 c2])))
                  (and (= 1 (count new-alts))
                       (first new-alts)))
              (-> c1
                  (update-var (extract-var c2))
                  (.alts new-alts))))))

(extend-type DynamicConstraint
  Constraint
  (assertion-path [c]
    (.path c))

  (intersect [c1 c2]
    (either (or (and (= top-type c2)
                     (maybe c1))
                (= c1 c2)
                (map (instance? MultiConstraint c2)
                     (partial intersect-multi c1)))
            (MultiConstraint [c1 c2])))

  (satisfied-by [_ c] (maybe c))
  (update-sym [x sym] (.sym x (maybe sym)))
  (update-var [x v] (.var x v))
  (collection-of [x] (Left top-type))
  (set-type [c _] c)

  ConstraintOps
  (intersect-typec [c tc]
    (MultiConstraint [c tc]))

  (intersect-multi [c mc]
    (either (and (some (.constraints mc) (partial = c))
                 (maybe mc))
            (MultiConstraint (conj (.constraints mc) c)))))

(deftype SetType [tc]
  (assert (instance? TypeConstraint tc))

  Stringable
  (string-list [_]
    (list "(c/SetType " (str tc) ")"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  ConstraintOps
  (is-bottom [c] c))

(extend-type ParamConstraint
  Container
  (map [x f]
    (.mods x (map (.mods x) f)))

  (map [x f embed]
    (map (map (.mods x) f embed)
         (fn [new-mods]
           (.mods x new-mods))))

  Constraint
  (reified-field [c indices]
    (-> c
        (.item-indices (comp (.item-indices c)
                             indices))
        maybe
        Left))

  (set-arity [c new-arity]
    (.arity c new-arity))

  (set-type [c tc]
    (mod-param c (SetType tc)))

  (intersect [c1 c2]
    (intersect-param c2 c1))

  ConstraintOps
  (is-bottom [c]
    ;; TODO: need this?
    ;; (either (some (.mods c) (partial = bottom-type)))
    c)

  (intersect-int [pc int-c]
    (mod-param pc int-c))

  (intersect-fn [pc fn-c]
    (mod-param pc fn-c))

  (intersect-sym [pc sym-c]
    (mod-param pc sym-c))

  (intersect-str [pc str-c]
    (mod-param pc str-c))

  (intersect-maybe [pc maybe-c]
    (mod-param pc maybe-c))

  (intersect-promise [pc promise-c]
    (mod-param pc promise-c))

  (intersect-agent [pc agent-c]
    (mod-param pc agent-c))

  (intersect-param [c dyn-c]
    (either (or (= c dyn-c)
                (and (= (.arity c) (.arity dyn-c))
                     (= (.param-index c) (.param-index dyn-c))
                     (cond (empty? (.mods c))
                           (maybe dyn-c)

                           (and (empty? (.mods dyn-c))
                                (maybe c)))))
            (do
              ;; TODO: this should only be called when two params have the same
              ;; symbol in a function. Replace the old paramconstraint instead of intersecting
              ;; (print-err 'intersecting-at _FILE_ _LINE_
              ;;            "\n" 'c c
              ;;            "\n\n" 'dyn-c dyn-c)
              (mod-param dyn-c c))))

  (intersect-sum [c cs]
    (mod-param c cs))

  (intersect-typec [c tc]
    (mod-param c tc))

  (intersect-multi [c mc]
    (mod-param c mc)))


(extend-type DynamicResultConstraint
  Container
  (map [x f]
    (.invokable-c x (f (.invokable-c x))))

  (map [x f embed]
    (-> (.invokable-c x)
        f
        (map (partial .invokable-c x))))

  Constraint
  (set-arity [c new-arity]
    (.arity c new-arity))

  ConstraintOps
  (is-bottom [c] c))

(extend-type ReifiedFields
  Container
  (map [x f]
    (.field-cs x (map (.field-cs x) f)))

  (map [x f embed]
    (-> (.field-cs x)
        (map f embed)
        (map (partial .field-cs x))))

  Constraint
  (reified-field [c indices]
    (either (for [index (first indices)
                  field (get-in c [.field-cs index])]
              (cond (= 1 (count indices))
                    (Left (maybe field))
                    (Left (extract-reified-field field (rest indices)))))
            (Left (maybe c))))

  (reified-fields [c]
    (Left c))


  Constraint
  (intersect [reified c]
    (cond (instance? ReifiedFields c)
          top-type

          (either (intersect-reified c reified)
                  reified)))

  ConstraintOps
  (is-bottom [c] c)

  (intersect-multi [c mc]
    ;; TODO: remove after it triggers and is analyzed
    (print-err 'wut c)
    (cond (some (.constraints mc) (partial = c))
          (.constraints mc (.constraints mc))

          (.constraints mc (conj (.constraints mc) c)))))

(deftype SetField [fld fld-c]
  Stringable
  (string-list [_]
    (list "(c/SetField " (str fld) " " (str fld-c) ")"))

  Container
  (map [x f]
    (let [new-fld (f (.fld x))]
      (SetField (cond (= top-type new-fld)
                      (.fld x)
                      new-fld)
                (f (.fld-c x)))))

  (map [x f embed]
    (for [new-fld (f (.fld x))
          new-c (f (.fld-c x))]
      (SetField (cond (= top-type new-fld)
                      (.fld x)
                      new-fld)
                new-c)))

  Constraint
  (intersect [c1 c2]
    (cond (or (instance? MultiConstraint c2)
              (instance? SumConstraint c2)
              (instance? ParamConstraint c2)
              (instance? TypeConstraint c2))
          (intersect c2 c1)
          c2))

  ConstraintOps
  (is-bottom [c]
    ;; TODO: always choose bottom-type with non-empty constraints if possible
    (either (or (= (.fld c) bottom-type)
                (= (.fld-c c) bottom-type))
            c))

  (intersect-param [c dyn-c]
    (mod-param dyn-c c))

  (intersect-typec [c tc]
    (let [new-tc (cond (instance? Field fld)
                       (intersect tc (TypeConstraint {UnknownType {fld top-type}} empty-list
                                                     (symbol (str fld)) nothing ""))
                       tc)]
      (either (= bottom-type new-tc)
              (cata is-bottom (.type-maps tc (-> (.type-maps tc)
                                                 (dissoc UnknownType)
                                                 (map-vals (fn [fld-map]
                                                             (either (and (or (instance? SymbolConstraints fld)
                                                                              (and (instance? Field fld)
                                                                                   (get fld-map fld)))
                                                                          (-> (assoc fld-map fld fld-c)
                                                                              check-hash-map-attrs
                                                                              maybe))
                                                                     fld-map)))))))))

  (intersect-multi [c mc]
    (cata is-bottom (-> (.constraints mc)
                        (map (partial intersect c))
                        trim))))

(defn set-field [fld c]
  (SetField fld c))

(deftype GetField [fld]
  Stringable
  (string-list [_]
    (list "(c/GetField " (str fld) ")"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Constraint
  (intersect [c1 c2]
    ;; TODO handle case where 'fld' is a Constraint
    (cond (instance? Field fld)
          (extract-field c2 fld)
          top-type))

  ConstraintOps
  (is-bottom [c]
    (either (= (.fld c) bottom-type)
            c))

  (intersect-param [c dyn-c]
    ;; TODO handle case where 'fld' is a Constraint
    (cond (instance? Field fld)
          (mod-param dyn-c c)
          dyn-c))

  (intersect-typec [c tc]
    ;; TODO handle case where 'fld' is a Constraint
    (cond (instance? Field fld)
          (extract-field tc fld)
          top-type))

  (intersect-multi [c mc]
    ;; TODO handle case where 'fld' is a Constraint
    (cond (instance? Field fld)
          (extract-field mc fld)
          top-type)))

(defn get-field [fld]
  (GetField fld))

(deftype fn-arity [param-consts result-const]
  Stringable
  (string-list [_]
    (list "(c/fn-arity " (str param-consts) "\n" (str result-const) ")")))

(deftype CallValue [args]
  Stringable
  (string-list [_]
    (list "(c/CallValue " (to-str (interpose args "\n")) ")"))

  Container
  (map [x f]
    (.args x (map args f)))

  (map [x f embed]
    (map (map args f embed)
         (partial .args x)))

  Constraint
  (intersect [c1 c2]
    (cond (instance? ParamConstraint c2)
          (intersect c2 c1)

          (instance? FnConstraint c2)
          (do
            ;; (print-err "Intersecting CallValue")
            ;; (print-err 'c1 c1)
            ;; (print-err 'c2 c2)
            (either (for [arity-info (or (get-in c2 [.arities (count args)])
                                         ;; TODO: handle variadic
                                         )]
                      (let [checked-params (-> (zip-lists (extract-items-constraints (.param-consts arity-info))
                                                          args)
                                               (some (fn [[param arg]]
                                                       (= bottom-type (intersect param arg)))))]
                        ;; (print-err 'result (.result-const arity-info))
                        (either (flat-map checked-params
                                          (partial = bottom-type))
                                (.result-const arity-info))))
                    (NoValues [c1 c2])))

          top-type))

  ConstraintOps
  (is-bottom [c]
    ;; TODO: always choose bottom-type with non-empty constraints if possible
    (either (some args (partial = bottom-type))
            c))

  (intersect-fn [y x]
    (intersect y x))

  (intersect-param [c dyn-c]
    (mod-param dyn-c c))

  (intersect-typec [c tc]
    (print-err 'calling-typec _FILE_ _LINE_ c "\n\n" 'tc tc)
    top-type)

  (intersect-multi [c mc]
    (print-err 'calling-multi _FILE_ _LINE_ c "\n\n" 'mc mc)
    top-type))

(extend-type FnConstraint
  Constraint
  (intersect [x y]
    (intersect-fn y x))

  ConstraintOps
  (intersect-fn [y x]
    (either (or (=* x y)
                (and (empty? (.arities x))
                     (maybe y))
                (and (empty? (.arities y))
                     (maybe x)))
            (NoValues [x y])))

  (is-bottom [c] c))

(extend-type ParamConstraint
  ConstraintOps
  (extract-field [dyn-c fld]
    (mod-param dyn-c (GetField fld))))

(extend-type Field
  ConstraintOps
  (is-bottom [x] x))

(defn full-param-consraint [c]
  (trim (cata (fn [c]
                (either (map (instance? ParamConstraint c)
                             (fn [dyn-c]
                               (-> (.mods dyn-c)
                                   reverse
                                   (reduce top-type (fn [c mod]
                                                      (cond (instance? ParamConstraint mod)
                                                            top-type

                                                            (instance? SetField mod)
                                                            (TypeConstraint
                                                             {UnknownType {(.fld mod) top-type}}
                                                             empty-list
                                                             (symbol (str (.fld mod)))
                                                             nothing "")

                                                            (instance? GetField mod)
                                                            (TypeConstraint
                                                             {UnknownType {(.fld mod) c}}
                                                             empty-list
                                                             (symbol (str (.fld mod)))
                                                             nothing "")

                                                            (instance? SetType mod)
                                                            ;; TODO: needs completion
                                                            top-type

                                                            (intersect mod c)))))))
                        c))
              c)))

(defn compose-constraints [file-name line-number x y]
  (assert (instance? Constraints x))
  (assert (instance? Constraints y))

  (let [z (intersect x y)]
    (either (and (= bottom-type z)
                 (let [z (either (and (flat-map (get z .constraints)
                                                (fn [constraints]
                                                  (< 1 (count constraints))))
                                      (maybe z))
                                 (NoValues [x y]))]
                   ;; (print-err 'x x)
                   ;; (print-err 'y y)
                   ;; (print-err 'z z)
                   (maybe (conflicting-assertions z file-name line-number))))
            (maybe z))))

(def empty-items-constraint (ItemsConstraint []
                                             (NoValues [])
                                             empty-list nothing ""))


;; AllValues                 extract-field
;; NoValues                  
;; InferredInner             
;; CollectionOf              
;; ItemsConstraint           
;; TypeConstraint            extract-field
;; SumConstraint             extract-field
;; ParamConstraint           extract-field
;; MultiConstraint           
;; StaticLengthConstraint
;; DynamicFields
;; ReifiedFields
;; GetField                  extract-field
;; SetField                  extract-field
;; SetType
