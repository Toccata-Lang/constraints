
(def default-extract-items-constraints)

(def TypeMap (map-of Integer (set-of Symbol)))

;; Public interface for Constraints
(defprotocol Constraint
  (assertion-path [x])

  (format-path [x n]
    (assert-result r (instance? (list-of String) r)))

  (replace-path [c new-path]
    (assert (instance? (list-of Vector) new-path)))

  (intersect [c1 c2])

  (restrict-types [c type-map]
    (either (map (extract-type-map c)
                 (fn [c-type-map]
                   (select-keys type-map (keys c-type-map))))
            type-map))

  (extract-type-map [_]
    (assert-result r (instance? (maybe-of TypeMap) r)))

  (extract-items-constraints [_]
    (assert-result r (instance? Vector r))
    [])

  (extract-contents-constraint [_])

  (extract-items-constraints [c n]
    (assert (instance? Integer n))
    (assert-result r (instance? Vector r))

    (default-extract-items-constraints c n))

  (extract-key-constraint [_]
    ;; extract the constraint a key value must satisfy
    )

  (extract-collection-of [_]
    ;; extract CollectionOf constraint
    )

  (extract-coll-constraint [_]
    ;; extract the CollectionOf or the InferredInner constraints
    ;; returns either an AllValues or CollectionOf constraint
    )

  (update-path [constraint file-name line-number]
    constraint)

  (extract-sym [tc]
    (assert-result r (instance? (maybe-of Symbol) r))

    nothing)

  (update-sym [tc new-sym]
    (assert (instance? Symbol new-sym)))

  (clear-sym [tc])

  (extract-var [c]
    (assert-result var (instance? String var)))

  (update-var [c new-var]
    (assert (instance? String new-var)))

  (update-type-name [c new-name]
    c)

  (set-type [c tc]
    (intersect c tc))

  (satisfied-by [c info]
    (assert-result r (instance? Maybe r))

    nothing))

(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -2, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FunctionType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MaybeType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ListType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SymbolType};"))
(def BitmapIndexedType (inline C Integer "(Value *)&(Integer){IntegerType, -2, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ArrayNodeType};"))
(def HashCollisionNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -2, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, OpaqueType};"))
(def TypeConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeConstraintType};"))
(def NoValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, NoValuesType};"))
(def AllValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AllValuesType};"))
(def MultiConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MultiConstraintType};"))
(def ResultConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ResultConstraintType};"))
(def ItemsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ItemsConstraintType};"))
(def FieldConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FieldConstraintType};"))
(def StaticIntConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StaticIntConstraintType};"))
(def MinValueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MinValueType};"))
(def MaxValueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MaxValueType};"))
(def InferredInnerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InferredInnerType};"))
(def StaticLengthConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2,
    StaticLengthConstraintType};"))
(def StaticStrConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StaticStrConstraintType};"))
(def ContentsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ContentsConstraintType};"))
(def HashSetType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashSetType};"))
(def ProtoDispatcherType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ProtoDispatcherType};"))
(def FloatType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FloatType};"))
(def SumConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SumConstraintType};"))
(def KeysConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, KeysConstraintType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeCount};"))

;; TODO: constraints to add
;; number of args the target of a call takes
;; min count (instead of ItemsConstraint)
;; keys required in a hash map

(defn format-path* [path desired-len]
  (assert (instance? List path))
  (assert (instance? Integer desired-len))

  (either (map (first path)
               (fn [[header]]
                 (let [path (-> (rest path)
                                (remove (fn [[file line]]
                                          (either (and (instance? Symbol file)
                                                       (maybe nothing))
                                                  (or (empty? file)
                                                      (= 0 line)))))
                                (map (fn [[file line]]
                                       (let [file (str file)]
                                         (str (either (map (> (count file) 30)
                                                           (fn [len]
                                                             (subs file (- len 15))))
                                                      file)
                                              ": " line)))))
                       max-width (reduce path 0 (fn [max s]
                                                  (let [n (count s)]
                                                    (either (> max n)
                                                            n))))
                       path (either (and (< (count path) desired-len)
                                         (maybe (comp path (repeat (- desired-len (count path))
                                                                   (spaces max-width)))))
                                    path)]
                   (map (cons header path)
                        (fn [x]
                          (str x (spaces (- max-width (count x)))))))))
          path))

(deftype AllValues [var]
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(AllValues " (str "\"" var "\"") ")"))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (maybe x)))

  Constraint
  (satisfied-by [_ c] (maybe c))
  (intersect [_ c] c)
  (clear-sym [x] x)
  (update-sym [x _] x)
  (extract-var [_] var)
  (update-var [x v] (AllValues v))
  (extract-collection-of [x] x)
  (extract-type-map [_] nothing))

(def top-type (AllValues ""))

(defn default-extract-items-constraints [c n]
  (assert (instance? Integer n))
  (assert-result r (instance? Vector r))

  (take (comp (extract-items-constraints c)
              (repeat n top-type))
        n))

(defn sym-str [s]
  (either (map s (fn [s]
                   (str "(maybe '" s ")")))
          "nothing"))

;; InferredInner is a weaker version of CollectionOf
(deftype InferredInner [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(InferredInner " (str contents) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (extract-items-constraints [c n]
    (vec (repeat n contents)))

  (extract-type-map [_]
    nothing)

  (assertion-path [_]
    path)

  (format-path [x desired-len]
    (format-path* (cons ["Contents restriction from" ""] path)
                  desired-len)))

;; CollectionOf is a stronger version of InferredInner
(deftype CollectionOf [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(CollectionOf " (str contents) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (update-var [c new-var]
    (.var c new-var))

  (extract-type-map [_]
    nothing)

  (assertion-path [_]
    path)

  (format-path [x desired-len]
    (format-path* (cons ["Contents from" ""] path)
                  desired-len)))

(def coll-of-any (CollectionOf top-type empty-list nothing ""))

(deftype ItemsConstraint [items-constraints tail-constraint path sym var]
  (assert (instance? Vector items-constraints))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(ItemsConstraint [" (to-str (interpose items-constraints "\n"))
          "]\n" (str tail-constraint) "\n(list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" "\")"))

  Constraint
  (set-type [c tc]
    (-> c
        (.tail-constraint (set-type (.tail-constraint c) tc))
        (intersect tc)))

  (extract-items-constraints [_]
    (comp items-constraints
          (extract-items-constraints tail-constraint)))

  (extract-items-constraints [c n]
    (either (and (<= n 0)
                 (maybe []))
            (take (comp items-constraints
                        (extract-items-constraints tail-constraint (- n (count items-constraints)))
                        (repeat n top-type))
                  n)))

  (assertion-path [_]
    path)

  (extract-type-map [_]
    (maybe {ListType #{}
            VectorType #{}}))

  (format-path [x desired-len]
    (format-path* (cons ["Sequence from" ""] path)
                  desired-len)))

(deftype TypeConstraint [type-maps path type-sym sym var]
  (assert (instance? TypeMap type-maps))
  (assert (instance? (list-of Vector) path))
  ;; 'type-sym' has to be more relaxed so it can accept an ast/tagged-symbol
  ;; (assert (instance? Symbol type-sym))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(TypeConstraint "  (str type-maps) " (list"
          (either (map (first path) (fn [[f l]]
                                      (let [f (str f)]
                                        (str "[\"" (either (map (> (count f) 15)
                                                                (fn [len]
                                                                  (subs f (- len 15))))
                                                           f)
                                             "\" " l "]"))))
                  "")
          ") "
          (str "'" type-sym) " " (sym-str sym)
          " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (for [_ (instance? TypeConstraint y)
          y-maps (get y .type-maps)
          _ (= type-maps y-maps)]
      x))

  Constraint
  (update-type-name [c new-name]
    (.type-sym c new-name))

  (assertion-path [_] path)

  (extract-type-map [_]
    (maybe type-maps))

  (extract-contents-constraint [c]
    (either (and (or (get type-maps StringBufferType)
                     (get type-maps SubStringType))
                 (maybe c))
            top-type))

  (format-path [x desired-len]
    (format-path* (cons [(str "Type '" type-sym "' from") ""]
                        path)
                  desired-len)))

(deftype FieldConstraint [field field-var path sym var]
  (assert (instance? Symbol field))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(FieldConstraint (symbol \"" (str field) "\") \"" (str field-var) "\" (list"
          (either (map (first path) (fn [[f l]]
                                      (let [f (str f)]
                                        (str "[\"" (either (map (> (count f) 15)
                                                                (fn [len]
                                                                  (subs f (- len 15))))
                                                           f)
                                             "\" " l "]"))))
                  "")
          ") " (sym-str sym)
          " \"" (str var) "\")"))

  Constraint
  (assertion-path [_]
    path)

  (extract-type-map [_]
    nothing)

  (restrict-types [c type-map]
    (reduce (seq type-map) {}
            (fn [type-map [type-num field-set]]
              (either (map (field-set field)
                           (fn [_] (assoc type-map type-num field-set)))
                      type-map))))

  (format-path [x desired-len]
    (format-path* (cons [(str "Field '" (subs (str field) 1) "' required from") ""]
                        path)
                  desired-len)))

(deftype StaticIntConstraint [val path sym var]
  (assert (instance? Integer val))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(StaticIntConstraint " (str val) " (list"
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (satisfied-by [c info]
    (= c info))

  (assertion-path [c]
    path)

  (format-path [x desired-len]
    (format-path* (cons ["Integer from" ""] path)
                  desired-len))

  (extract-type-map [_]
    (maybe {IntegerType #{}})))

(deftype MinValue [min path sym var]
  (assert (instance? Integer min))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(MinValue " (str min) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (assertion-path [_]
    path)

  (extract-type-map [_]
    (maybe {IntegerType #{}}))

  (format-path [x desired-len]
    (format-path* (cons [(str "Min value of " min " from") ""] path)
                  desired-len))

  (update-var [c new-var]
    (.var c new-var))

  (intersect [mvc c]
    (either (= mvc c)
            (intersect (update-var c (extract-var mvc)) mvc))))

(deftype MaxValue [max path sym var]
  (assert (instance? Integer max))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(MaxValue " (str max) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (assertion-path [_]
    path)

  (extract-type-map [_]
    (maybe {IntegerType #{}}))

  (format-path [x desired-len]
    (format-path* (cons [(str "Max value of " max " from") ""] path)
                  desired-len)))

(deftype StaticLengthConstraint [length path sym var]
  (assert (instance? Integer length))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [c]
    (list "(StaticLengthConstraint " (str length) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (assertion-path [c]
    path)

  (format-path [x desired-len]
    (format-path* (cons [(str "Length from") ""]
                          (.path x))
                    desired-len))

  (extract-type-map [_]
    (maybe {ListType #{}
            VectorType #{}})))

(deftype StaticStrConstraint [val path sym var]
  (assert (instance? String val))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(StaticStrConstraint " val " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (satisfied-by [c info]
    (= c info))

  (format-path [x desired-len]
    (format-path* (cons ["String from" ""] path)
                  desired-len))

  (extract-type-map [_]
    (maybe {StringBufferType #{}
            SubStringType #{}}))

  (assertion-path [c]
    path))

(def StaticConstraints (any-of StaticLengthConstraint
                               StaticStrConstraint
                               StaticIntConstraint))

;; TODO: add 'typ-sym' and make it a be optional for all constraints
(deftype SumConstraint [alts path sym var]
  (assert (instance? (min-count 1) alts))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? (list-of Vector) path))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list (str "(SumConstraint " (str alts) " " (str path) " " (either (map sym str) 'nothing) " "
               var ")")))

  Eq
  (=* [x y]
    (and (instance? SumConstraint y)
         (= (count alts) (count (.alts y)))
         (every (.alts y) (fn [c]
                            (some alts (partial =* c))))
         (maybe x)))

  Constraint
  (update-type-name [c new-name]
    (.alts c (map (.alts c) (fn [alt]
                              (update-type-name alt new-name)))))

  (assertion-path [x]
    path)

  (format-path [_ n]
    (format-path* (cons ["Sum Type from" ""] path)
                  n))

  (extract-type-map [_]
    (reduce alts nothing (fn [m c]
                           (let [c-m (extract-type-map c)]
                             (or (apply (maybe comp) [m c-m])
                                 c-m
                                 m)))))

  (update-path [constraint file-name line-number]
    (-> constraint
        (.path (cons [file-name line-number] path))
        (.alts (map alts
                    (fn [c]
                      (update-path c file-name line-number))))))

  (extract-sym [tc]
    sym)

  (update-sym [tc new-sym]
    (.sym tc (maybe new-sym)))

  (clear-sym [tc]
    (.sym tc nothing))

  (extract-var [c]
    var)

  (update-var [c new-var]
    (-> c
        (.alts (map (.alts c) (fn [c]
                                (update-var c new-var))))
        (.var new-var)))

  (satisfied-by [c info]
    (or (and (instance? SumConstraint info)
             (every (.alts info)
                    (fn [info-c]
                      (some (.alts c)
                            (fn [c-c]
                              (satisfied-by c-c info-c))))))
        (some alts (fn [c]
                     (satisfied-by c info))))))

(defn sum-type [cs]
  (either (or (and (empty? cs)
                   (maybe top-type))
              (some cs (partial = top-type))
              (apply = cs))
          (let [type-constraints (vec (filter cs (partial instance? TypeConstraint)))
                tc (either (empty? type-constraints)
                           [(TypeConstraint (comp* {} (map type-constraints .type-maps))
                                             empty-list
                                             (either (apply = (map type-constraints .type-sym))
                                                     (symbol "<unknown>"))
                                             nothing "")])
                new-cs (reduce (remove cs (partial instance? TypeConstraint)) tc
                               (fn [new-cs curr]
                                 (either (and (some new-cs (fn [c]
                                                             (= c (intersect c curr))))
                                              (maybe new-cs))
                                         (conj new-cs curr))))]
            (either (and (= 1 (count new-cs))
                         (first new-cs))
                    (SumConstraint new-cs empty-list nothing "")))))

(deftype KeysConstraint [constraint path sym var]
  (assert (instance? List path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list (str "(KeysConstraint " (str constraint) " "
               (str path) " " (str sym) " " (str "\"" var "\"") ")")))

  Constraint
  (assertion-path [x]
    path)

  (format-path [x n]
    (format-path* (cons ["Key Type from" ""] path)
                  n))

  (extract-type-map [_]
    (maybe {BitmapIndexedType #{}
            ArrayNodeType #{}
            HashCollisionNodeType #{}}))

  (update-path [c file-name line-number]
    (.path c (cons [file-name line-number] path)))

  (extract-sym [tc]
    sym)

  (update-sym [tc new-sym]
    (.sym tc (maybe new-sym)))

  (clear-sym [tc]
    (.sym tc nothing))

  (extract-var [c]
    var)

  (update-var [c new-var]
    (.var c new-var))

  (satisfied-by [c info]
    (and (instance? KeysConstraint info)
         (satisfied-by (.constraint c) (.constraint info)))))

(deftype DynamicParamConstraint [param-index path sym var]
  Stringable
  (string-list [_]
    (list "(DynamicParamConstraint " (str param-index)
          (either (map (first path) (fn [[f l]]
                                      (str " [\"" f "\" " l "]")))
                  "")
          ")")))

(deftype DynamicClosureConstraint [closure-index path sym var]
  Stringable
  (string-list [_]
    (list "(DynamicClosureConstraint " (str closure-index)
          (either (map (first path) (fn [[f l]]
                                      (str " [\"" f "\" " l "]")))
                  "")
          ")")))

(def DynamicConstraint (any-of DynamicParamConstraint
                               DynamicClosureConstraint))

;; Minimum Constraint Implementations
;; (deftype DynamicParamConstraint [param-index]
;;   Stringable
;;   (string-list [_]
;;     (list "(DynamicParamConstraint " (str param-index ")")))

;;   c/Constraint
;;   (c/intersect [c1 c2] c2)
;;   (c/satisfied-by [_ c] (maybe c))
;;   (c/intersect [_ c] c)
;;   (c/clear-sym [x] x)
;;   (c/update-sym [x _] x)
;;   (c/update-var [x v] x)
;;   (c/extract-collection-of [x] c/top-type)
;;   (c/extract-type-map [_] nothing)
;;   (c/extract-contents-constraint [_] c/top-type)
;;   (c/extract-coll-constraint [_] c/top-type)

;;   c/ConstraintOps
;;   (c/intersect-typec [c tc] tc)
;;   (c/intersect-multi [c mc] mc))

(def SymbolConstraints (any-of TypeConstraint
                               MinValue
                               MaxValue
                               InferredInner
                               StaticConstraints
                               ItemsConstraint
                               CollectionOf
                               FieldConstraint
                               SumConstraint
                               KeysConstraint
                               DynamicConstraint))

(deftype NoValues [constraints]
  (assert (instance? (vector-of (any-of SymbolConstraints
                                        Symbol))
                     constraints))

  Stringable
  (string-list [_]
    (list "(NoValues [" (to-str (interpose constraints "\n")) "])"))

  Constraint
  (intersect [nv _] nv)
  (clear-sym [x] x)
  (update-sym [x _] x)
  (update-var [x _] x)
  (extract-collection-of [x] x)

  (format-path [_ n]
    (let [max-len (reduce (map constraints (fn [c] (count (assertion-path c))))
                          n
                          (fn [max-len path-len]
                            (either (> max-len path-len)
                                    path-len)))
          paths (map constraints (fn [c]
                                   (format-path c (inc max-len))))]
      (-> paths
          (list-zipper empty-list)
          (map (fn [strs]
                 (str (to-str (interpose strs "    "))
                      "\n"))))))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (or (and (empty? constraints)
                  (maybe y))
             (maybe x)))))

(def bottom-type (NoValues []))

(extend-type Integer
  Constraint
  (intersect [x c]
    (intersect (StaticIntConstraint x empty-list nothing (extract-var c)) c)))

(extend-type String
  Constraint
  (intersect [x c]
    (intersect (StaticStrConstraint x empty-list nothing (extract-var c)) c)))

(extend-type Vector
  Constraint
  (intersect [v c]
    (intersect (ItemsConstraint v coll-of-any empty-list nothing (extract-var c)) c)))

(extend-type Symbol
  Constraint
  (assertion-path [_]
    empty-list)

  (format-path [_ desired-len]
    (format-path* (list ["Symbol from" ""])
                  desired-len))

  (extract-type-map [_]
    (maybe {SymbolType #{}}))

  (intersect [slc c]
    (either (or (= slc c)
                (and (instance? Symbol c)
                     (maybe (NoValues [slc c])))
                (for [type-map (extract-type-map c)
                      :when (get type-map SymbolType)]
                  slc))
            (NoValues [slc c]))))

(deftype MultiConstraint [constraints]
  (assert (instance? (vector-of SymbolConstraints) constraints))

  Stringable
  (string-list [_] (list "(MultiConstraint [" (to-str (interpose constraints "\n")) "])"))

  Constraint
  (update-type-name [c new-name]
    (.constraints c (map (.constraints c) (fn [inner-c]
                                            (update-type-name inner-c new-name)))))

  (set-type [c tc]
    (MultiConstraint (map constraints (fn [inner-c]
                                        (set-type inner-c tc)))))

  (extract-var [_]
    (either (some constraints (fn [c]
                                (let [var (extract-var c)]
                                  (or (and (= "" var)
                                           nothing)
                                      (maybe var)))))
            ""))

  (extract-sym [c]
    (some constraints extract-sym))

  (extract-type-map [mc]
    (reduce (.constraints mc) nothing
            (fn [type-map c]
              (or (map type-map (partial restrict-types c))
                  (extract-type-map c)))))

  (clear-sym [mc]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (clear-sym c)))))

  (update-sym [mc sym]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-sym c sym)))))

  (update-var [mc var]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-var c var)))))

  (format-path [_ n]
    (let [max-len (reduce (map constraints (fn [o]
                                             (count (.path o))))
                          n
                          (fn [max-len path-len]
                            (either (> max-len path-len)
                                    path-len)))
          paths (map constraints (fn [c]
                                   (format-path c (inc max-len))))]
      (-> paths
          (list-zipper empty-list)
          (map (fn [strs]
                 (to-str (interpose strs "    ")))))))

  (assertion-path [c]
    (format-path c 0))

  (update-path [mc file-name line-number]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-path c file-name line-number))))))

(def ValueConstraint (any-of SymbolConstraints
                             MultiConstraint
                             AllValues))

(deftype ResultConstraint [assertion]
  (assert (instance? ValueConstraint assertion))

  Stringable
  (string-list [_] (list "(ResultConstraint " (str assertion) ")"))

  Constraint
  (update-var [_ new-var]
    (ResultConstraint (update-var assertion new-var)))

  (clear-sym [_]
    (ResultConstraint (clear-sym assertion)))

  (update-sym [_ new-var]
    (ResultConstraint (update-sym assertion new-var)))

  (extract-type-map [_]
    (extract-type-map assertion)))

(def Constraints (any-of ValueConstraint
                         NoValues
                         ResultConstraint))

;; private operations on Constraints
(defprotocol ConstraintOps
  (intersect-keyc [c kc]
    (assert (instance? KeysConstraint kc))
    (intersect (update-var c (extract-var kc)) kc))

  (items-satisfied [info c]
    (assert (instance? ValueConstraint info))
    (assert (instance? ItemsConstraint c))
    (assert-result r (instance? (maybe-of ValueConstraint) r))

    nothing)

  (mult-satisfied [info c]
    (assert (instance? ValueConstraint info))
    (assert (instance? MultiConstraint c))
    (assert-result r (instance? (maybe-of ValueConstraint) r))

    (let [type-map (extract-type-map c)]
      (and (or (= nothing type-map)
               (flat-map type-map
                         (fn [type-map]
                           (satisfied-by (TypeConstraint type-map empty-list (symbol "<unknown>") nothing "")
                                         info))))
           (every (.constraints c)
                  (fn [inner-c]
                    (satisfied-by inner-c info)))
           (maybe info))))

  (sum-c-satisfies [info c]
    (assert (instance? ValueConstraint c))
    (assert-result r (instance? (maybe-of ValueConstraint) r))

    nothing)

  (=-multi [y x]
    (assert (instance? MultiConstraint x))
    (assert-result r (instance? Maybe r))

    nothing)

  (intersect-result [c rc]
    (assert (instance? ResultConstraint rc))
    nothing)

  (=-result-constraint [y x]
    (assert (instance? ResultConstraint x))
    nothing)

  (intersect-typec [c tc]
    (assert (instance? TypeConstraint tc))
    (assert-result r (instance? Constraints r)))

  (=-contentsc [x y]
    nothing)

  (intersect-coll-of [c cc]
    (assert (instance? CollectionOf cc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var cc)) cc))

  (=-static-str [y x]
    nothing)

  (intersect-static-str [c slc]
    (assert (instance? StaticStrConstraint slc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var slc)) slc))

  (=-static-len [y x]
    nothing)

  (intersect-static-len [c slc]
    (assert (instance? StaticLengthConstraint slc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var slc)) slc))

  (=-inferred-inner [y x]
    nothing)

  (intersect-sum [c cs]
    (assert (instance? SumConstraint cs))

    (let [inters (map (.alts cs) (partial intersect (update-var c (extract-var cs))))
          goods (remove inters (partial instance? NoValues))]
      (either (and (empty? goods)
                   (maybe (NoValues [c cs])))
              (.alts cs goods))))

  (intersect-inner [c ic]
    (assert (instance? InferredInner ic))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var ic)) ic))

  (=-max-value [y x]
    (assert (instance? MaxValue x))
    nothing)

  (intersect-max-value [c mvc]
    (assert (instance? MaxValue mvc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var mvc)) mvc))

  (=-min-value [y x]
    (assert (instance? MinValue x))
    nothing)

  (intersect-min-value [c mvc]
    (assert (instance? MinValue mvc))
    (assert-result r (instance? Constraints r))

    (intersect c mvc))

  (=-static-int [y x]
    (assert (instance? StaticIntConstraint x))
    nothing)

  (intersect-static-int [c slc]
    (assert (instance? StaticIntConstraint slc))
    (intersect (update-var c (extract-var slc)) slc))

  (=-field-constraint [y x]
    (assert (instance? FieldConstraint x))
    nothing)

  (fieldc-satisfied [info c]
    (assert (instance? FieldConstraint c))
    (assert-result r (instance? (maybe-of ValueConstraint) r))

    (flat-map (extract-type-map info)
              (fn [type-map]
                (and (< 0 (count (restrict-types c type-map)))
                     (maybe info)))))

  (intersect-fieldc [c fc]
    (assert (instance? FieldConstraint fc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var fc)) fc))

  (=-items-constraint [y x]
    (assert (instance? ItemsConstraint x))
    nothing)

  (intersect-itemsc [c ic]
    (assert (instance? ItemsConstraint ic))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var ic)) ic))

  (intersect-multi [c mc]
    (assert (instance? MultiConstraint mc))
    (assert-result r (instance? Constraints r))

    ;; TODO: make sure that intersecting each type of constraint results
    ;; in the smallest set of .constraints in the MultiConstraint
    ;; applies to conj-multi as well.
    )

  (conj-multi [c mc]
    (assert (instance? MultiConstraint mc))))

(extend-type NoValues
  ConstraintOps
  (conj-multi [c mc]
    (maybe c))

  (intersect-typec [c _]
    c))

(extend-type AllValues
  ConstraintOps
  (intersect-sum [c sc] sc) 
  (intersect-result [c rc] rc) 
  (intersect-typec [c tc] tc) 
  (intersect-coll-of [c cc] cc) 
  (intersect-static-str [c slc] slc) 
  (intersect-static-len [c slc] slc) 
  (intersect-inner [c ic] ic) 
  (intersect-max-value [c mvc] mvc) 
  (intersect-min-value [c mvc] mvc) 
  (intersect-static-int [c slc] slc) 
  (intersect-fieldc [c fc] fc) 
  (intersect-itemsc [c ic] ic) 
  (intersect-multi [c mc] mc) 
  (conj-multi [c mc]
    (maybe mc)))

(extend-type SymbolConstraints
  Constraint
  (replace-path [c new-path]
    (.path c new-path))

  (extract-sym [c]
    (.sym c))

  (extract-var [c]
    (.var c))

  (extract-collection-of [_]
    top-type)

  (update-path [constraint file-name line-number]
    (let [new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (either (and (= "" file-name)
                   (maybe constraint))
              (.path constraint new-path))))

  (clear-sym [tc]
    (.sym tc nothing))

  (update-sym [tc new-sym]
    (.sym tc (maybe new-sym)))

  (update-var [tc new-var]
    (.var tc new-var))

  ConstraintOps
  (intersect-multi [c mc]
    (assert (instance? MultiConstraint mc))
    (assert-result r (instance? Constraints r))

    (either (or (-> (.constraints mc)
                    (map (partial intersect c))
                    (some (partial instance? NoValues)))
                (and (some (.constraints mc) (partial = c))
                     (maybe mc)))
            (conj mc c)))

  (conj-multi [c mc]
    (assert (instance? MultiConstraint mc))

    (either (and (some (.constraints mc) (partial = c))
                 (maybe c))
            (MultiConstraint (conj (.constraints mc) c))))

  (intersect-typec [c tc]
    (assert (instance? TypeConstraint tc))
    (assert-result r (instance? Constraints r))

    (either (flat-map (extract-type-map c)
                      (fn [type-map]
                        (or (and (empty? (select-keys (.type-maps tc) (keys type-map)))
                                 (maybe (NoValues [tc c])))
                            (maybe (MultiConstraint [tc (update-var c (extract-var tc))])))))
            (intersect (update-var c (extract-var tc)) tc))))

(extend-type Constraints
  Constraint
  (extract-key-constraint [_]
    top-type)

  (extract-contents-constraint [_]
    top-type)

  (extract-coll-constraint [_]
    top-type))

(extend-type ItemsConstraint
  Eq
  (=* [x y]
    (=-items-constraint y x))

  ConstraintOps
  (items-satisfied [info c]
    (let [c-items (.items-constraints c)
          info-items (extract-items-constraints info (count c-items))]
      (and (<= (count c-items) (count (.items-constraints info)))
           (every (zip-lists c-items info-items)
                  (fn [[c info]]
                    (satisfied-by c info)))
           (satisfied-by (.tail-constraint c) (.tail-constraint info))
           (maybe info))))

  (intersect-coll-of [c cc]
    (either (or (= (reduce (.items-constraints c)
                           top-type
                           (fn [r c]
                             (either (= r bottom-type)
                                     (-> (.contents cc)
                                         (intersect c)
                                         (update-var (extract-var c))))))
                   bottom-type)
                (= (intersect cc (.tail-constraint c))
                   bottom-type))
            (MultiConstraint [cc (update-var c (extract-var cc))])))

  (intersect-static-str [c slc]
    (either (and (< (count slc) (count (extract-items-constraints c)))
                 (maybe (NoValues [slc c])))
            (MultiConstraint [slc c])))

  (intersect-static-len [c slc]
    (either (and (< (.length slc) (count (extract-items-constraints c)))
                 (maybe (NoValues [slc c])))
            (MultiConstraint [slc c])))

  (intersect-inner [c ic]
    (either (or (-> (.items-constraints c)
                    (map (fn [c2]
                           (intersect (.contents ic) c2)))
                    (some (fn [c]
                            (= c bottom-type))))
                (= (intersect (.tail-constraint c) ic)
                   bottom-type))
            (MultiConstraint [ic (update-var c (extract-var ic))])))

  (intersect-typec [c tc]
    (assert (instance? TypeConstraint tc))

    (MultiConstraint [tc (update-var c (extract-var tc))]))

  (intersect-max-value [c mvc]
    (NoValues [mvc c]))

  (intersect-static-int [c slc]
    (NoValues [slc c]))

  (intersect-itemsc [c ic]
    (assert (instance? ItemsConstraint ic))

    (let [cnt-ic (count (.items-constraints ic))
          cnt-c (count (.items-constraints c))
          max-cnt (either (> cnt-ic cnt-c)
                          cnt-c)
          constraints (map (zip-lists (extract-items-constraints ic max-cnt)
                                      (extract-items-constraints c max-cnt))
                           (fn [[c1 c2]]
                             (intersect c1 c2)))
          new-tail (intersect (.tail-constraint ic)
                              (.tail-constraint c))]
      (either (or (some constraints (fn [c]
                                      (= c bottom-type)))
                  (= new-tail bottom-type))
              (-> ic
                  (.tail-constraint new-tail)
                  (.items-constraints (vec constraints))))))

  (intersect-fieldc [c fc]
    (NoValues [fc c]))

  (intersect-min-value [c mvc]
    (NoValues [mvc c]))

  (=-items-constraint [y x]
    (and (= (.items-constraints y) (.items-constraints x))
         (= (.tail-constraint y) (.tail-constraint x))
         (maybe x)))

  Constraint
  (extract-contents-constraint [c]
    (-> (.items-constraints c)
        (conj (extract-contents-constraint (.tail-constraint c)))
        sum-type))

  (satisfied-by [c info]
    (items-satisfied info c))

  (intersect [ic c]
    (either (=-items-constraint c ic)
            (intersect-itemsc c ic)))

  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (ItemsConstraint (map (.items-constraints constraint)
                            (fn [constraints]
                              (update-path constraints file-name line-number)))
                       (update-path (.tail-constraint constraint) file-name line-number)
                       new-path
                       (.sym constraint) (extract-var constraint)))))

(extend-type MultiConstraint
  Eq
  (=* [x y]
    (=-multi y x))

  Collection
  (conj [mc c]
    (assert (instance? SymbolConstraints c))

    (conj-multi c mc))

  ConstraintOps
  (items-satisfied [info c]
    (flat-map (some (.constraints info) (partial instance? ItemsConstraint))
              (fn [info-itemsc]
                (items-satisfied info-itemsc c))))

  (=-multi [y x]
    (and (every (.constraints x)
                (fn [x]
                  (some (.constraints y)
                        (fn [y]
                          (= x y)))))
         (maybe x)))

  (intersect-sum [c sc]
    (either (= (reduce (.constraints c) sc
                       (fn [x y]
                         (either (= (intersect x y) bottom-type)
                                 x)))
               bottom-type)
            (conj (update-var c (extract-var sc)) sc)))

  (intersect-inner [c ic]
    (either (= (reduce (.constraints c) ic
                       (fn [x y]
                         (either (= (intersect x y) bottom-type)
                                 x)))
               bottom-type)
            (conj c ic)))

  (intersect-typec [c tc]
    (intersect c tc))

  (conj-multi [c mc]
    (reduce (.constraints c) mc conj))

  (intersect-multi [c mc]
    (reduce (.constraints c) mc
            (fn [mc new-c]
              (either (= mc bottom-type)
                      (intersect mc new-c)))))

  (mult-satisfied [mult-info mult-c]
    (let [type-map (extract-type-map mult-c)]
      (and (or (= nothing type-map)
               (flat-map type-map
                         (fn [type-map]
                           (satisfied-by (TypeConstraint type-map empty-list (symbol "<unknown>") nothing "")
                                         mult-info))))
           (every (.constraints mult-c)
                  (fn [inner-c]
                    (some (.constraints mult-info)
                          (partial satisfied-by inner-c))))

           (maybe mult-info))))

  Constraint
  (replace-path [mc new-path]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (replace-path c new-path)))))

  (intersect [mc c]
    (intersect-multi c mc))

  (extract-key-constraint [mc]
    (-> (.constraints mc)
        (map extract-key-constraint)
        (reduce top-type intersect)))

  (extract-contents-constraint [mc]
    (either (map (some (.constraints mc) (partial instance? StaticLengthConstraint))
                 (fn [len-c]
                   (-> mc
                       (extract-items-constraints (.length len-c))
                       sum-type)))
            (-> (.constraints mc)
                (filter (fn [c]
                          (or (instance? CollectionOf c)
                              (instance? InferredInner c)
                              (instance? ItemsConstraint c))))
                (map extract-contents-constraint)
                (reduce top-type intersect))))

  (extract-collection-of [mc]
    (-> (.constraints mc)
        (map extract-collection-of)
        (reduce top-type intersect)))

  (extract-coll-constraint [mc]
    (-> (.constraints mc)
        (map extract-coll-constraint)
        (reduce top-type intersect)))

  (satisfied-by [mult-c info]
    (mult-satisfied info mult-c))

  (extract-items-constraints [mc]
    (let [coll-c (-> mc
                     extract-coll-constraint
                     extract-contents-constraint)
          ics (either (-> (.constraints mc)
                          (some (partial instance? ItemsConstraint))
                          (map (fn [ic]
                                 (-> (extract-items-constraints ic)
                                     (map (fn [c]
                                            (-> c
                                                (intersect coll-c)
                                                (update-var (extract-var c)))))))))
                      [])]
      (either (map (some (.constraints mc)
                         (partial instance? StaticLengthConstraint))
                   (fn [len-c]
                     (take ics (.length len-c))))
            ics))))

(extend-type ResultConstraint
  Eq
  (=* [x y]
    (and (or (=-result-constraint y x)
             (=* (.assertion x) y))
         (maybe x)))

  Constraint
  (intersect [rc c]
    (let [intersected (either (intersect-result c rc)
                              (intersect (.assertion rc) c))]
      (either (= intersected bottom-type)
              (ResultConstraint intersected))))

  ConstraintOps
  (=-result-constraint [y x]
    (=* (.assertion x) (.assertion y)))

  (intersect-result [c rc]
    (maybe (intersect (.assertion rc) (.assertion c)))))

(extend-type TypeConstraint
  Constraint
  (set-type [c tc]
    (either (for [c-map (extract-type-map c)
                  tc-map (extract-type-map tc)
                  new-c (or (and (= {ListType #{}} tc-map)
                                 (= {VectorType #{}} c-map))
                            (and (= {VectorType #{}} tc-map)
                                 (= {ListType #{}} c-map)))]
              (.type-maps c tc-map))
            top-type))

  (intersect [tc c]
    (intersect-typec c tc))

  (satisfied-by [c info]
    (or (sum-c-satisfies info c)
        (flat-map (extract-type-map info)
                  (fn [value-type-map]
                    (and (< 0 (count value-type-map))
                         (every (keys value-type-map)
                                (partial get (.type-maps c)))
                         (maybe info))))))

  ConstraintOps
  (conj-multi [c mc]
    (intersect-multi c mc))

  (intersect-multi [c mc]
    (assert (instance? MultiConstraint mc))
    (assert-result r (instance? Constraints r))

    (either (or (= (reduce (.constraints mc) c
                           (fn [x y]
                             (either (= (intersect x y) bottom-type)
                                     x)))
                   bottom-type)
                (flat-map (extract-type-map mc)
                          (fn [new-map]
                            (= (intersect-typec c (.type-maps c new-map))
                               bottom-type)))
                (and (some (.constraints mc) (partial = c))
                     (maybe mc)))
            (MultiConstraint (conj (.constraints mc) c))))

  (intersect-coll-of [c ic]
    (let [new-type-map (dissoc (.type-maps c) IntegerType SymbolType)]
      (either (or (and (empty? new-type-map)
                       (maybe (NoValues [ic c])))
                  (= bottom-type (intersect (extract-contents-constraint c)
                                            (.contents ic))))
              (MultiConstraint [ic (-> c
                                       (.type-maps new-type-map)
                                       (update-var (extract-var ic)))]))))

  (intersect-inner [c ic]
    (let [new-type-map (dissoc (.type-maps c) IntegerType SymbolType)]
      (either (or (and (empty? new-type-map)
                       (maybe (NoValues [ic c])))
                  (= bottom-type (intersect (extract-contents-constraint c)
                                            (.contents ic))))
              (MultiConstraint [ic (-> c
                                       (.type-maps new-type-map)
                                       (update-var (extract-var ic)))]))))

  (intersect-fieldc [c fc]
    (let [field (.field fc)
          new-map (reduce (seq (.type-maps c))
                          {}
                          (fn [type-map [type-num fields]]
                            (either (map (fields field) (fn [_]
                                                          (assoc type-map type-num fields)))
                                    type-map)))]
      (either (and (empty? new-map)
                   (maybe (NoValues [fc c])))
              (MultiConstraint [fc (-> c
                                       (.type-maps new-map)
                                       (update-var (extract-var fc)))]))))

  (intersect-typec [c tc]
    (either (or (= tc c)
                (and (empty? (select-keys (.type-maps tc) (keys (.type-maps c))))
                     (maybe (NoValues [tc c]))))
            (.type-maps tc (filter-keys (.type-maps tc)
                                        (fn [k]
                                          (get (.type-maps c) k)))))))

(extend-type FieldConstraint
  Eq
  (=* [x y]
    (=-field-constraint y x))

  Constraint
  (satisfied-by [c info]
    (or (sum-c-satisfies info c)
        (fieldc-satisfied info c)))

  (intersect [fc c]
    (intersect-fieldc c fc))

  ConstraintOps
  (intersect-coll-of [c cc]
    (MultiConstraint [cc (update-var c (extract-var cc))]))

  (intersect-static-str [c slc]
    (NoValues [slc c]))

  (intersect-static-len [c slc]
    (NoValues [slc c]))

  (intersect-inner [c ic]
    (MultiConstraint [ic (update-var c (extract-var ic))]))

  (intersect-max-value [c mvc]
    (NoValues [mvc c]))

  (=-field-constraint [y x]
    (and (= (.field y) (.field y))
         (maybe x)))

  (fieldc-satisfied [info c]
    (and (= (.field info) (.field c))
         (maybe info)))

  (intersect-fieldc [c fc]
    (either (= c fc)
            (MultiConstraint [fc (update-var c (extract-var fc))])))

  (intersect-static-int [c slc]
    (NoValues [slc c]))

  (intersect-min-value [c mvc]
    (NoValues [mvc c])))

(extend-type StaticIntConstraint
  Eq
  (=* [x y]
    (=-static-int y x))

  Constraint
  (intersect [slc c]
    (intersect-static-int c slc))

  ConstraintOps
  (intersect-coll-of [c cc]
    (NoValues [cc c]))

  (intersect-static-str [c slc]
    (NoValues [slc c]))

  (intersect-static-len [c slc]
    (NoValues [slc c]))

  (intersect-inner [c ic]
    (NoValues [ic c]))

  (=-static-int [y x]
    (and (= (.val y) (.val x))
         (maybe x)))

  (intersect-max-value [c mvc]
    (either (and (<= (.val c) (.max mvc))
                 (maybe c))
            (NoValues [mvc c])))

  (intersect-static-int [c slc]
    (either (= slc c)
            (NoValues [slc c])))

  (intersect-min-value [c mvc]
    (either (and (< (.val c) (.min mvc))
                 (maybe (NoValues [mvc c])))
            c)))

(extend-type MinValue
  Eq
  (=* [x y]
    (=-min-value y x))

  Constraint
  (intersect [mvc c]
    (intersect-min-value c mvc))

  ConstraintOps
  (intersect-static-len [c ic]
    (NoValues [ic c]))

  (intersect-static-str [c ic]
    (NoValues [ic c]))

  (intersect-inner [c ic]
    (NoValues [ic c]))

  (intersect-max-value [c mvc]
    (either (and (<= (.min c) (.max mvc))
                 (maybe (MultiConstraint [c mvc])))
            (NoValues [mvc c])))

  (=-min-value [y x]
    (and (= (.min y) (.min x))
         (maybe x)))

  (intersect-min-value [c mvc]
    (either (=* c mvc)
            (.min mvc (either (< (.min mvc) (.min c))
                              (.min c))))))

(defn core-containers [c]
  (TypeConstraint {VectorType #{}
                   MaybeType #{}
                   ListType #{}
                   BitmapIndexedType #{}
                   ArrayNodeType #{}
                   HashCollisionNodeType #{}}
                  (.path c) 'CoreContainers (.sym c) (extract-var c)))

(extend-type InferredInner
  Eq
  (=* [x y]
    (=-inferred-inner y x))

  Constraint
  (satisfied-by [c coll-info]
    (assert-result r (instance? (maybe-of ValueConstraint) r))

    (and (or (and (= (.contents c) top-type)
                  (satisfied-by (core-containers c) coll-info))
             (satisfied-by (.contents c) (extract-contents-constraint coll-info)))
         (maybe coll-info)))

  (extract-contents-constraint [c]
    (.contents c))

  (intersect [ic c]
    (intersect-inner c ic))

  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (-> constraint
          (.contents (update-path (.contents constraint) file-name line-number))
          (.path new-path))))

  (extract-coll-constraint [c]
    (CollectionOf (.contents c) (.path c) (.sym c) (extract-var c)))

  ConstraintOps
  (intersect-multi [c mc]
    (let [new-c (intersect (.contents c)
                           (extract-contents-constraint mc))]
      (either (or (= new-c bottom-type)
                  (and (= new-c top-type)
                       (maybe mc)))
              (-> mc
                  (.constraints (remove (.constraints mc)
                                        (partial instance? InferredInner)))
                  (conj (.contents c new-c))))))

  (intersect-coll-of [c cc]
    (let [new-inner (intersect (.contents cc) (.contents c))]
      (either (= new-inner bottom-type)
              (.contents cc new-inner))))

  (intersect-static-str [c slc]
    (either (= (intersect (.contents c) (TypeConstraint {StringBufferType #{} SubStringType #{}}
                                                     (.path slc) 'String (.sym slc) (extract-var slc)))
               bottom-type)
            slc))

  (intersect-static-len [c slc]
    (MultiConstraint [slc c]))

  (=-inferred-inner [y x]
    (and (= (.contents x) (.contents y))
         (maybe x)))

  (intersect-inner [c ic]
    (let [new-c (intersect (.contents ic) (.contents c))]
      (either (= new-c bottom-type)
              (.contents ic new-c)))))

(extend-type MaxValue
  Eq
  (=* [x y]
    (=-max-value y x))

  ConstraintOps
  (intersect-coll-of [c cc]
    (NoValues [cc c]))

  (intersect-static-str [c slc]
    (NoValues [slc c]))

  (intersect-static-len [c slc]
    (NoValues [slc c]))

  (intersect-inner [c ic]
    (NoValues [ic c]))

  (=-max-value [y x]
    (and (= (.max x) (.max y))
         (maybe x)))

  (intersect-max-value [c mvc]
    (.max mvc (either (< (.max mvc) (.max c))
                      (.max c))))

  Constraint
  (intersect [mvc c]
    (intersect-max-value c mvc)))

(extend-type StaticLengthConstraint
  Eq
  (=* [x y]
    (=-static-len y x))

  Constraint
  (satisfied-by [c info]
    (and (or (and (instance? StaticLengthConstraint info)
                  (<= (.length c) (.length info)))
             (and (instance? ItemsConstraint info)
                  (<= (.length c) (count (.items-constraints info)))))
         (maybe info)))

  (intersect [slc c]
    (intersect-static-len c slc))

  ConstraintOps
  (items-satisfied [info c]
    (and (every (extract-items-constraints c (.length info))
                (partial = top-type))
         (maybe info)))

  (intersect-coll-of [c cc]
    (MultiConstraint [cc (update-var c (extract-var cc))]))

  (intersect-static-str [c slc]
    (MultiConstraint [slc c]))

  (intersect-static-len [c slc]
    (either (= slc c)
            (NoValues [slc c])))

  (=-static-len [y x]
    (and (= (.length x) (.length y))
         (maybe x))))

(extend-type StaticStrConstraint
  Eq
  (=* [x y]
    (=-static-str y x))

  Constraint
  (intersect [slc c]
    (intersect-static-str c slc))

  ConstraintOps
  (=-static-str [y x]
    (and (= (.val x) (.val y))
         (maybe x)))

  (intersect-static-str [c slc]
    (either (= slc c)
            (NoValues [slc c]))))

(extend-type CollectionOf
  Eq
  (=* [x y]
    (=-contentsc y x))

  Constraint
  (satisfied-by [c coll-info]
    (assert-result r (instance? (maybe-of ValueConstraint) r))

    (and (or (and (= (.contents c) top-type)
                  (satisfied-by (core-containers c) coll-info))
             (satisfied-by (.contents c) (extract-contents-constraint coll-info)))
         (maybe coll-info)))

  (extract-coll-constraint [c]
    c)

  (extract-contents-constraint [c]
    (.contents c))

  (extract-collection-of [x]
    x)

  (extract-items-constraints [c n]
    (repeat n (.contents c)))

  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (CollectionOf (update-path (.contents constraint) file-name line-number)
                    new-path
                    (.sym constraint) (extract-var constraint))))


  (extract-type-map [c]
    (maybe {ListType #{}
            MaybeType #{}
            BitmapIndexedType #{}
            ArrayNodeType #{}
            HashCollisionNodeType #{}
            PromiseType #{}
            HashSetType #{'set-map}
            FutureType #{}
            AgentType #{}
            FunctionType #{}
            VectorType #{}}))

  (intersect [cc c]
    (intersect-coll-of c cc))

  ConstraintOps
  (intersect-multi [c mc]
    (let [inters (map (.constraints mc) (partial intersect c))]
      (either (some inters (partial instance? NoValues))
              (-> mc
                  (.constraints (remove (.constraints mc)
                                        (partial instance? CollectionOf)))
                  (conj (-> (.constraints mc)
                            (filter (partial instance? CollectionOf))
                            (reduce c intersect)))))))

  (intersect-inner [c ic]
    (let [new-c (intersect (.contents c) (.contents ic))]
      (either (= new-c bottom-type)
              (.contents c new-c))))

  (intersect-static-str [c slc]
    (either (= (intersect (.contents c) (TypeConstraint {StringBufferType #{} SubStringType #{}}
                                                           (.path slc) 'String (.sym slc) (extract-var slc)))
               bottom-type)
            slc))

  (intersect-static-len [c slc]
    (MultiConstraint [slc c]))

  (intersect-coll-of [c cc]
    (let [new-cs (intersect (.contents cc) (.contents c))]
      (either (or (= new-cs bottom-type)
                  (= cc c))
              (.contents cc new-cs))))

  (=-contentsc [x y]
    (and (= (.contents x) (.contents y))
         (maybe x))))

(extend-type SumConstraint
  Constraint
  (set-type [c tc]
    (.alts c (-> (.alts c) 
                 (map (fn [inner-c]
                        (set-type inner-c tc)))
                 (remove (partial = bottom-type)))))

  (intersect [sc c]
    (intersect-sum c sc))

  (extract-key-constraint [c]
    (let [new-alts (map (.alts c) extract-key-constraint)]
      (either (some new-alts (partial = top-type))
              (.alts c new-alts))))

  (extract-items-constraints [c]
    (extract-items-constraints c (-> (.alts c)
                                     (map extract-items-constraints)
                                     (reduce 0 (fn [max cs]
                                                 (let [n (count cs)]
                                                   (either (> max n)
                                                           n)))))))

  (extract-items-constraints [c n]
    (-> (apply zip-lists (map (.alts c) (fn [alt]
                                          (extract-items-constraints alt n))))
        (map (fn [new-alts]
               (either (or (some new-alts (partial = top-type))
                           (apply = new-alts))
                       (.alts c new-alts))))
        vec))

  (extract-contents-constraint [c]
    (let [new-alts (map (.alts c) extract-contents-constraint)]
      (either (some new-alts (partial = top-type))
              (.alts c new-alts))))

  (extract-collection-of [c]
    (let [new-alts (map (.alts c) extract-collection-of)]
      (either (some new-alts (partial = top-type))
              (.alts c new-alts))))

  (extract-coll-constraint [c]
    (let [new-alts (map (.alts c) extract-coll-constraint)]
      (either (some new-alts (partial = top-type))
              (.alts c new-alts))))

  ConstraintOps
  (mult-satisfied [c mult-c]
    (sum-c-satisfies c mult-c))

  (sum-c-satisfies [info c]
    (and (every (.alts info) (partial satisfied-by c))
         (maybe c)))

  (intersect-sum [c1 c2]
    (let [new-alts (for [a1 (.alts c1)
                         a2 (.alts c2)
                         :let [new-alt (intersect a1 a2)]
                         :when-not (= bottom-type new-alt)]
                     new-alt)
          new-alts (reduce new-alts [] (fn [new-alts alt]
                                         (either (and (some new-alts (partial =* alt))
                                                      (maybe new-alts))
                                                 (conj new-alts alt))))]
      (either (or (and (empty? new-alts)
                       (maybe (NoValues [c1 c2])))
                  (and (= 1 (count new-alts))
                       (first new-alts)))
              (-> c1
                  (update-var (extract-var c2))
                  (.alts new-alts))))))

(extend-type DynamicConstraint
  Constraint
  (intersect [c1 c2] c2)
  (satisfied-by [_ c] (maybe c))
  (intersect [_ c] c)
  (clear-sym [x] x)
  (update-sym [x _] x)
  (update-var [x v] x)
  (extract-collection-of [x] top-type)
  (extract-type-map [_] nothing)
  (extract-contents-constraint [_] top-type)
  (extract-coll-constraint [_] top-type)

  ConstraintOps
  (intersect-typec [c tc] tc)
  (intersect-multi [c mc] mc))

(extend-type KeysConstraint
  Constraint
  (intersect [sc c]
    (intersect-keyc c sc))

  (extract-key-constraint [c]
    (.constraint c))

  (satisfied-by [c info]
    (and (instance? KeysConstraint info)
         (satisfied-by (.constraint c) (.constraint info))))

  ConstraintOps
  (intersect-keyc [c1 c2]
    (let [new-c (intersect (.constraint c1) (.constraint c2))]
      (either (= new-c bottom-type)
              (.constraint c1 new-c))))

  (intersect-coll-of [c cc]
    (assert (instance? CollectionOf cc))
    (assert-result r (instance? Constraints r))

    (MultiConstraint [(update-var c (extract-var cc)) cc]))

  (intersect-static-str [c slc]
    (assert (instance? StaticStrConstraint slc))
    (assert-result r (instance? Constraints r))

    (NoValues [(update-var c (extract-var slc)) slc]))

  (intersect-static-len [c slc]
    (assert (instance? StaticLengthConstraint slc))
    (assert-result r (instance? Constraints r))

    (MultiConstraint [(update-var c (extract-var slc)) slc]))

  (intersect-sum [c cs]
    (assert (instance? SumConstraint cs))

    (let [inters (map (.alts cs) (partial intersect c))
          goods (remove inters (partial instance? NoValues))]
      (either (and (empty? goods)
                   (maybe (NoValues [c cs])))
              (.alts cs goods))))

  (intersect-inner [c ic]
    (assert (instance? InferredInner ic))
    (assert-result r (instance? Constraints r))

    (MultiConstraint [(update-var c (extract-var ic)) ic]))

  (intersect-max-value [c mvc]
    (assert (instance? MaxValue mvc))
    (assert-result r (instance? Constraints r))

    (NoValues [(update-var c (extract-var mvc)) mvc]))

  (intersect-min-value [c mvc]
    (assert (instance? MinValue mvc))
    (assert-result r (instance? Constraints r))

    (NoValues [(update-var c (extract-var mvc)) mvc]))

  (intersect-static-int [c slc]
    (assert (instance? StaticIntConstraint slc))

    (NoValues [(update-var c (extract-var slc)) slc]))

  (fieldc-satisfied [info c]
    (assert (instance? FieldConstraint c))
    nothing)

  (intersect-fieldc [c fc]
    (assert (instance? FieldConstraint fc))
    (assert-result r (instance? Constraints r))

    (NoValues [(update-var c (extract-var fc)) fc]))

  (intersect-itemsc [c ic]
    (assert (instance? ItemsConstraint ic))
    (assert-result r (instance? Constraints r))

    (NoValues [(update-var c (extract-var ic)) ic]))

  (intersect-multi [c mc]
    (assert (instance? MultiConstraint mc))
    (assert-result r (instance? Constraints r))

    (let [new-c (-> (.constraints mc)
                    (filter (partial instance? KeysConstraint))
                    (reduce c intersect))]
      (either (= new-c bottom-type)
              (.constraints mc (conj (remove (.constraints mc)
                                             (partial instance? KeysConstraint))
                                     new-c)))))

  (conj-multi [c mc]
    (intersect-multi c mc)))

(defn conflicting-assertions [failing-constraint file-name line-number]
  (apply print-err (list* "Conflicting assertions"
                           (either (= "" file-name)
                                   (str "at " file-name ": " line-number))
                           "\n"
                           (format-path failing-constraint 0)))
  nothing)

(defn compose-constraints [file-name line-number x y]
  (assert (instance? Constraints x))
  (assert (instance? Constraints y))

  (let [z (intersect x y)]
    (either (and (= bottom-type z)
                 (let [z (either (and (flat-map (get z .constraints)
                                                (fn [constraints]
                                                  (< 1 (count constraints))))
                                      (maybe z))
                                 (NoValues [x y]))]
                   ;; (print-err 'x x)
                   ;; (print-err 'y y)
                   ;; (print-err 'z z)
                   (maybe (conflicting-assertions z file-name line-number))))
            (maybe z))))

(def empty-items-constraint (ItemsConstraint []
                                             (CollectionOf (TypeConstraint {} empty-list 'no-type nothing "")
                                                           empty-list nothing "")
                                             empty-list nothing ""))
