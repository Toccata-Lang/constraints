
;; TODO: don't need this
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ListType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorType};"))

;; TODO: another hack workaround
(def satisfied-by)

(defprotocol Constraint
  (assertion-path [x])

  (format-path [x n])

  (intersect [c1 c2])

  (restrict-types [c type-map]
    type-map)

  (extract-type-map [_]
    (assert-result r (instance? Maybe r)))

  (extract-items-constraints [_]
    (assert-result r (instance? Vector r))
    [])

  (update-path [constraint file-name line-number]
    constraint)

  (update-sym [tc new-sym]
    (assert (instance? Tagged new-sym)))

  (update-var [tc new-var]
    (assert (instance? String new-var)))

  (satisfied-by [c info]
    (assert-result r (instance? Maybe r))
    nothing))

(defn format-path* [path desired-len]
  (either (empty? path)
          (let [path (map path
                          (fn [[file line]]
                            (str file ": " line)))
                max-width (reduce path 0 (fn [max s]
                                           (let [n (count s)]
                                             (either (> max n)
                                                     n))))
                path (either (and (< (count path) desired-len)
                                  (maybe (comp path (repeat (- desired-len (count path))
                                                            (spaces max-width)))))
                             path)]
            (map path
                 (fn [x]
                   (str x (spaces (- max-width (count x)))))))))

(deftype NoValues [constraints]
  Stringable
  (string-list [_]
    (list "<NoValues>"))

  Constraint
  (intersect [nv _] nv)
  (update-sym [x _] x)
  (update-var [x _] x)

  (format-path [_ n]
    (let [max-len (reduce (map constraints (fn [c] (count (assertion-path c)))) n
                          (fn [max-len path-len]
                            (either (> max-len path-len)
                                    path-len)))
          paths (map constraints (fn [c]
                                   (format-path c max-len)))]
      (-> paths
          (list-zipper empty-list)
          (map (fn [strs]
                 (str (to-str (interpose strs "    "))
                      "\n"))))))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (or (and (< (count (.constraints x)) (count (.constraints y)))
                  (maybe y))
             (maybe x))))

  Composition
  (comp* [nv-type _]
    nv-type))

(deftype AllValues []
  Stringable
  (string-list [_]
    (list "<AllValues>"))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (maybe x)))

  Constraint
  (intersect [_ c] c)
  (update-sym [x _] x)

  (update-var [x _] x)
  (extract-type-map [_] nothing)

  Composition
  (comp* [av-type constraints]
    (either (map (first constraints)
                 (fn [constraint]
                   (comp* constraint (rest constraints))))
            av-type)))

(def bottom-type (NoValues []))
(def top-type (AllValues))

(deftype ResultConstraint [assertion]
  (assert (instance? ValueConstraint assertion))

  Stringable
  (string-list [_] (list "<ResultConstraint " (str assertion) ">"))

  Constraint
  (update-var [_ new-var]
    (ResultConstraint (update-var assertion new-var)))

  (update-sym [_ new-var]
    (ResultConstraint (update-sym assertion new-var)))

  (extract-type-map [_]
    (extract-type-map assertion))

  (intersect [rc c]
    (let [intersected (either (and (instance? ResultConstraint c)
                                   (maybe (intersect assertion (.assertion c))))
                              (intersect assertion c))]
      (either (= bottom-type intersected)
              (ResultConstraint intersected))))

  Eq
  (=* [x y]
    (and (or (and (instance? ResultConstraint y)
                  (=* assertion (.assertion y)))
             (=* assertion y))
         (maybe x))))

(deftype TypeConstraint [type-maps path type-sym sym var]
  (assert (instance? HashMap type-maps))
  (assert (instance? List path))
  (assert (instance? Tagged type-sym))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "<TypeConstraint " (str type-sym) " " (str type-maps)
          " " (str sym) " '" (str var) "'>"))

  Eq
  (=* [x y]
    (and (instance? TypeConstraint y)
         (= type-maps (.type-maps y))
         (maybe x)))

  Constraint
  (assertion-path [_] path)

  (satisfied-by [c info]
    (map (extract-type-map info)
         (fn [value-type-map]
           (subset (set (keys type-maps))
                   (set (keys value-type-map))))))

  (extract-type-map [_]
    (maybe type-maps))

  (format-path [x desired-len]
    (format-path* (cons [(str "Type '" type-sym "' From") ""]
                        path)
                  desired-len)))

(deftype ItemsConstraint [items-constraints path sym var]
  (assert (instance? Vector items-constraints))
  (assert (instance? List path))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Collection
  (empty? [_]
    (every items-constraints empty?))

  Eq
  (=* [x y]
    (and (instance? ItemsConstraint y)
         (= items-constraints (.items-constraints y))
         (maybe x)))

  Stringable
  (string-list [_]
    (list "<ItemsConstraint " (str items-constraints) " " (str sym) ">"))

  Constraint
  (extract-type-map [_]
    (maybe {ListType #{}
            VectorType #{}}))

  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (ItemsConstraint (map (.items-constraints constraint)
                            (fn [constraints]
                              (update-path constraints file-name line-number)))
                       new-path
                       (.sym constraint) (.var constraint))))

  (extract-items-constraints [_]
    items-constraints)

  (format-path [x desired-len]
    (format-path* (cons ["Sequence from" ""] path)
                  desired-len)))

(deftype MultiConstraint [constraints]
  (assert (instance? Vector constraints))

  Stringable
  (string-list [_] (list "<MultiConstraint \n" (to-str (interpose constraints "\n-- ")) ">"))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (= constraints (.constraints y))
         (maybe x)))

  Collection
  (conj [mc c]
    (either (or (= bottom-type c)
                (and (some constraints (partial = c))
                     (maybe mc)))
            (MultiConstraint (conj constraints c))))

  Constraint
  (satisfied-by [c info]
    (let [type-map (extract-type-map c)]
      (or (flat-map type-map
                    (fn [type-map]
                      (satisfied-by (TypeConstraint type-map empty-list (symbol "<unknown>") nothing "")
                                      info)))
          (and (= nothing type-map)
               (every (.constraints c)
                      (fn [inner-c]
                        (satisfied-by inner-c info)))))))

  (extract-type-map [mc]
    (reduce (.constraints mc) nothing
            (fn [type-map c]
              (or (map type-map (partial restrict-types c))
                  (extract-type-map c)))))

  (extract-items-constraints [mc]
    (-> (.constraints mc)
        (filter (partial instance? ItemsConstraint))
        (map .items-constraints)
        ((fn [ls]
           (let [max-len (reduce ls 0 (fn [max l]
                                        (either (> (count l) max)
                                                max)))]
             (either (and (= max-len 0)
                          (maybe []))
                     (map ls (fn [l]
                               (either (and (< (count l) max-len)
                                            (maybe (comp l (repeat (- max-len (count l))
                                                                   top-type))))
                                       l)))))))
        (map (fn [[c & cs]] (comp* c cs)))))

  (update-sym [mc sym]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-sym c sym)))))

  (update-var [mc var]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-var c var)))))

  (format-path [_ n]
    (let [max-len (reduce (map constraints (fn [c] (count (.path c)))) n
                          (fn [max-len path-len]
                            (either (> max-len path-len)
                                    path-len)))
          paths (map constraints (fn [c]
                                   (format-path c (inc max-len))))]
      (-> paths
          (list-zipper empty-list)
          (map (fn [strs]
                 (str (to-str (interpose strs "    "))
                      "\n"))))))

  (update-sym [mc sym]
    (.constraints mc (map constraints (fn [c]
                                        (update-sym c sym)))))

  (update-var [mc var]
    (.constraints mc (map constraints (fn [c]
                                        (update-var c var)))))

  (update-path [mc file-name line-number]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-path c file-name line-number)))))

  (intersect [mc c]
    (either (or (and (instance? MultiConstraint c)
                     (maybe (reduce (.constraints c) mc
                                    (fn [cs new-c]
                                      (either (= cs bottom-type)
                                              (intersect new-c cs))))))
                (= bottom-type (intersect c mc))
                (and (some constraints (partial = c))
                     (maybe mc)))
            (MultiConstraint (conj constraints c)))))

(deftype FieldConstraint [field field-var path sym var]
  (assert (instance? Tagged field))
  (assert (instance? List path))
  (assert (instance? Maybe sym))

  Eq
  (=* [x y]
    (and (instance? FieldConstraint y)
         (= field (.field y))
         (maybe x)))

  Stringable
  (string-list [_]
    (list "<FieldConstraint " (str field) " " (str sym)
          ;; "\n" (str (interpose path "\n"))
          ">"))

  Constraint
  (satisfied-by [c info]
    (let [type-map (extract-type-map info)]
      (or (flat-map type-map
                    (fn [type-map]
                      (first (seq (restrict-types c type-map)))))
          (and (= nothing type-map)
               (or (and (instance? FieldConstraint info)
                        (= (.field c) (.field info)))
                   (and (instance? MultiConstraint info)
                        (some (.constraints info)
                              (partial satisfied-by c))))))))

  (extract-type-map [_] nothing)

  (restrict-types [c type-map]
    (reduce (seq type-map) {}
            (fn [type-map [type-num field-set]]
              (either (map (field-set field)
                           (fn [_] (assoc type-map type-num field-set)))
                      type-map))))

  (format-path [x desired-len]
    (format-path* (cons [(str "Field '" (subs (str field) 1) "' required from") ""]
                        path)
                  desired-len)))

(deftype StaticLengthConstraint [length path sym var]
  (assert (instance? Integer length))
  (assert (instance? List path))
  (assert (instance? Maybe sym))

  Eq
  (=* [x y]
    (and (instance? StaticLengthConstraint y)
         (= (.length x) (.length y))
         (maybe x)))

  Stringable
  (string-list [c]
    (list "<StaticLengthConstraint " (str (.length c)) " " (str (.sym c)) "\n"
          (to-str (interpose (seq (.path c)) "\n")) ">"))

  Constraint
  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons [(str "Length from") ""]
                          (.path x))
                    desired-len))
  Constraint
  (intersect [slc c]
    (either (or (= slc c)
                (= c bottom-type)
                (and (= c top-type) (maybe slc))
                (and (instance? ResultConstraint c)
                     (let [result-constraint (intersect slc (.assertion c))]
                       (or (and (= bottom-type result-constraint)
                                (maybe (NoValues [slc (.assertion c)])))
                           (maybe (ResultConstraint (intersect slc (.assertion c)))))))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) slc
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c slc))))
                (and (instance? FieldConstraint c)
                     (maybe (NoValues [slc c])))
                (and (instance? ItemsConstraint c)
                     (< (.length slc) (count (.items-constraints c)))
                     (maybe (NoValues [slc c]))))
            (MultiConstraint [slc (update-var c (.var slc))]))))

(deftype StaticIntConstraint [val path sym var]
  Constraint
  (assertion-path [c] (.path c))

  (intersect [slc c]
    (either (or (= slc c)
                (= c bottom-type)
                (and (= c top-type) (maybe slc))
                (and (instance? ResultConstraint c)
                     (let [result-constraint (intersect slc (.assertion c))]
                       (or (and (= bottom-type result-constraint)
                                (maybe (NoValues [slc (.assertion c)])))
                           (maybe (ResultConstraint (intersect slc (.assertion c)))))))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) slc
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c slc))))
                (and (instance? FieldConstraint c)
                     (maybe (NoValues [slc c]))))
            (MultiConstraint [slc (update-var c (.var slc))]))))

(deftype StaticStrConstraint [val path sym var]
  Constraint
  (assertion-path [c] (.path c))

  (intersect [slc c]
    (either (or (= slc c)
                (= c bottom-type)
                (and (= c top-type) (maybe slc))
                (and (instance? ResultConstraint c)
                     (let [result-constraint (intersect slc (.assertion c))]
                       (or (and (= bottom-type result-constraint)
                                (maybe (NoValues [slc (.assertion c)])))
                           (maybe (ResultConstraint (intersect slc (.assertion c)))))))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) slc
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c slc))))
                (and (instance? FieldConstraint c)
                     (maybe (NoValues [slc c]))))
            (MultiConstraint [slc (update-var c (.var slc))]))))

(def StaticConstraints (comp StaticLengthConstraint
                             StaticStrConstraint
                             StaticIntConstraint))

(def empty-items-constraint (ItemsConstraint [] empty-list nothing ""))

(def SymbolConstraints (comp TypeConstraint
                             StaticConstraints
                             ItemsConstraint
                             FieldConstraint))

(extend-type SymbolConstraints
  Constraint
  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (either (and (= "" file-name)
                   (maybe constraint))
              (.path constraint new-path))))

  (update-sym [tc new-sym]
    (.sym tc (maybe new-sym)))

  (update-var [tc new-var]
    (.var tc new-var)))

(def ValueConstraint (comp SymbolConstraints
                           MultiConstraint
                           AllValues))

(def Constraints (comp AllValues
                       NoValues
                       MultiConstraint
                       SymbolConstraints
                       ResultConstraint))

(extend-type Constraints
  Composition
  (comp* [mc cs]
    (reduce cs mc intersect)))

(extend-type TypeConstraint
  Constraint
  (intersect [tc c]
    (either (or (= tc c)
                (= c bottom-type)
                (and (= c top-type) (maybe tc))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) tc
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c tc))))
                (and (instance? ItemsConstraint c)
                     (let [types-map (select-keys (.type-maps tc) [ListType VectorType])]
                       (and (empty? types-map)
                            (maybe (NoValues [tc c])))))
                (and (instance? FieldConstraint c)
                     (let [field (.field c)]
                       (and (empty? (filter (vals (.type-maps tc)) (fn [fields]
                                                                     (fields field))))
                            (maybe (NoValues [tc c])))))
                (and (instance? ResultConstraint c)
                     (let [result-constraint (intersect tc (.assertion c))]
                       (or (and (= bottom-type result-constraint)
                                (maybe (NoValues [tc (.assertion c)])))
                           (maybe (ResultConstraint (intersect tc (.assertion c)))))))
                (and (instance? TypeConstraint c)
                     (let [types-map (select-keys (.type-maps tc) (keys (.type-maps c)))]
                       (and (empty? types-map)
                            (maybe (NoValues [tc c]))))))
            (MultiConstraint [tc (update-var c (.var tc))]))))

(extend-type FieldConstraint
  Constraint
  (intersect [fc c]
    (either (or (= fc c)
                (= c bottom-type)
                (and (= c top-type) (maybe fc))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) fc
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c fc))))
                (and (instance? ItemsConstraint c)
                     (maybe (NoValues [fc c])))
                (and (instance? ResultConstraint c)
                     (let [result-constraint (intersect fc (.assertion c))]
                       (or (and (= bottom-type result-constraint)
                                (maybe (NoValues [fc (.assertion c)])))
                           (maybe (ResultConstraint (intersect fc (.assertion c)))))))
                (and (instance? TypeConstraint c)
                     (let [field (.field fc)]
                       (and (empty? (filter (vals (.type-maps c)) (fn [fields]
                                                                    (fields field))))
                            (maybe (NoValues [fc c]))))))
            (MultiConstraint [fc (update-var c (.var fc))]))))

(extend-type ItemsConstraint
  Constraint
  (intersect [ic c]
    (either (or (= ic c)
                (= c bottom-type)
                (and (= c top-type) (maybe ic))
                (and (instance? ResultConstraint c)
                     (let [result-constraint (intersect ic (.assertion c))]
                       (or (and (= bottom-type result-constraint)
                                (maybe (NoValues [ic (.assertion c)])))
                           (maybe (ResultConstraint (intersect ic (.assertion c)))))))
                (and (instance? MultiConstraint c)
                     (or (= bottom-type (reduce (.constraints c) ic
                                                (fn [x y]
                                                  (either (= bottom-type (intersect x y))
                                                          x))))
                         (maybe (conj c ic))))
                (and (instance? TypeConstraint c)
                     (let [types-map (select-keys (.type-maps c) [ListType VectorType])]
                       (and (empty? types-map)
                            (maybe (NoValues [ic c])))))
                (and (instance? StaticLengthConstraint c)
                     (< (.length c) (count (.items-constraints ic)))
                     (maybe (NoValues [ic c])))
                (and (instance? FieldConstraint c)
                     (maybe (NoValues [ic c])))
                (and (instance? ItemsConstraint c)
                     (= bottom-type
                        (reduce (zip-lists (.items-constraints ic) (.items-constraints c))
                                top-type
                                (fn [final-c [c1 c2]]
                                  (either (= bottom-type final-c)
                                          (intersect c1 c2)))))))
            (MultiConstraint [ic (update-var c (.var ic))]))))

(defn conflicting-assertions [constraints file-name line-number]
  (apply print-err (list* "Conflicting assertions"
                           (either (= "" file-name)
                                   (str "at " file-name ": " line-number))
                           "\n"
                           (format-path (MultiConstraint constraints) 0)))
  nothing)

(defn compose-constraints [file-name line-number x y]
  (assert (instance? Constraints x))
  (assert (instance? Constraints y))

  (let [z (comp x y)]
    (either (and (= bottom-type z)
                 (let [constraints (either (and (< 1 (count (.constraints z)))
                                                (maybe (.constraints z)))
                                           [x y])]
                   (maybe (conflicting-assertions constraints file-name line-number))))
            (maybe z))))
