
(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -2, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FunctionType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MaybeType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ListType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SymbolType};"))
(def BitmapIndexedType (inline C Integer "(Value *)&(Integer){IntegerType, -2, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ArrayNodeType};"))
(def HashCollisionNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -2, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, OpaqueType};"))
(def TypeConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeConstraintType};"))
(def NoValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, NoValuesType};"))
(def AllValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AllValuesType};"))
(def MultiConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MultiConstraintType};"))
(def ResultConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ResultConstraintType};"))
(def ItemsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ItemsConstraintType};"))
(def FieldConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FieldConstraintType};"))
(def StaticIntConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StaticIntConstraintType};"))
(def MinValueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MinValueType};"))
(def MaxValueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MaxValueType};"))
(def InferredInnerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InferredInnerType};"))
(def StaticLengthConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2,
    StaticLengthConstraintType};"))
(def StaticStrConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StaticStrConstraintType};"))
(def ContentsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ContentsConstraintType};"))
(def HashSetType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashSetType};"))
(def ProtoDispatcherType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ProtoDispatcherType};"))
(def FloatType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FloatType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeCount};"))

(def default-extract-items-constraints)

(defprotocol Constraint
  (assertion-path [x])

  (format-path [x n])

  (intersect [c1 c2])

  (restrict-types [c type-map]
    type-map)

  (extract-type-map [_]
    (assert-result r (instance? Maybe r)))

  (extract-items-constraints [_]
    (assert-result r (instance? Vector r))
    [])

  (extract-items-constraints [c n]
    (assert (instance? Integer n))
    (assert-result r (instance? Vector r))

    (default-extract-items-constraints c n))

  (extract-coll-type [_])

  (extract-inner-constraint [_])

  (update-path [constraint file-name line-number]
    constraint)

  (extract-sym [tc]
    (assert-result r (instance? Maybe r))
    nothing)

  (update-sym [tc new-sym]
    (assert (instance? Tagged new-sym)))

  (clear-sym [tc])

  (extract-var [c])

  (update-var [c new-var])

  (satisfied-by [c info]
    (assert-result r (instance? Maybe r))
    ;; TODO: the whole idea behind this function is suspect
    nothing))

;; TODO: constraints to add
;; min count (instead of ItemsConstraint)
;; keys required in a hash map
;; key constraint on hash maps

(defn format-path* [path desired-len]
  (either (empty? path)
          (let [path (-> path
                         (remove (fn [[file line]]
                                   (either (and (instance? Symbol file)
                                                (maybe nothing))
                                           (or (empty? file)
                                               (= 0 line)))))
                         (map (fn [[file line]]
                                (str file ": " line))))
                max-width (reduce path 0 (fn [max s]
                                           (let [n (count s)]
                                             (either (> max n)
                                                     n))))
                path (either (and (< (count path) desired-len)
                                  (maybe (comp path (repeat (- desired-len (count path))
                                                            (spaces max-width)))))
                             path)]
            (map path
                 (fn [x]
                   (str x (spaces (- max-width (count x)))))))))

(deftype NoValues [constraints]
  Stringable
  (string-list [_]
    (list "(NoValues [" (to-str (interpose constraints "\n")) "])"))

  Constraint
  (intersect [nv _] nv)
  (clear-sym [x] x)
  (update-sym [x _] x)
  (update-var [x _] x)
  (extract-coll-type [x] x)

  (format-path [_ n]
    (let [max-len (reduce (map constraints (fn [c] (count (assertion-path c))))
                          n
                          (fn [max-len path-len]
                            (either (> max-len path-len)
                                    path-len)))
          paths (map constraints (fn [c]
                                   (format-path c (inc max-len))))]
      (-> paths
          (list-zipper empty-list)
          (map (fn [strs]
                 (str (to-str (interpose strs "    "))
                      "\n"))))))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (maybe x))))

(deftype AllValues [var]
  Stringable
  (string-list [_]
    (list "(AllValues " (str var) ")"))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (maybe x)))

  Constraint
  (intersect [_ c] c)
  (clear-sym [x] x)
  (update-sym [x _] x)
  (extract-var [_] var)
  (update-var [x v] (AllValues v))
  (extract-coll-type [x] x)
  (extract-type-map [_] nothing))

(def bottom-type (NoValues []))

(def top-type (AllValues ""))

(defn default-extract-items-constraints [c n]
  (assert (instance? Integer n))
  (assert-result r (instance? Vector r))

  (take (comp (extract-items-constraints c)
              (repeat n top-type))
        n))

(deftype ResultConstraint [assertion]
  (assert (instance? ValueConstraint assertion))

  Stringable
  (string-list [_] (list "(ResultConstraint " (str assertion) ")"))

  Constraint
  (update-var [_ new-var]
    (ResultConstraint (update-var assertion new-var)))

  (clear-sym [_]
    (ResultConstraint (clear-sym assertion)))

  (update-sym [_ new-var]
    (ResultConstraint (update-sym assertion new-var)))

  (extract-type-map [_]
    (extract-type-map assertion)))

(defn sym-str [s]
  (either (map s (fn [s]
                   (str "(maybe '" s ")")))
          "nothing"))

(deftype ItemsConstraint [items-constraints tail-constraint path sym var]
  (assert (instance? Vector items-constraints))
  (assert (instance? List path))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(ItemsConstraint [" (to-str (interpose items-constraints "\n"))
          "]\n" (str tail-constraint) "\n(list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" "\")"))

  Constraint
  (extract-items-constraints [c n]
    (either (and (<= n 0)
                 (maybe []))
            (take (comp items-constraints
                        (extract-items-constraints tail-constraint (- n (count items-constraints)))
                        (repeat n top-type))
                  n)))

  (assertion-path [_]
    path)

  (extract-type-map [_]
    (maybe {ListType #{}
            VectorType #{}}))

  (extract-items-constraints [_]
    (comp items-constraints
          (extract-items-constraints tail-constraint)))

  (format-path [x desired-len]
    (format-path* (cons ["Sequence from" ""] path)
                  desired-len)))

(def empty-items-constraint (ItemsConstraint [] top-type empty-list nothing ""))

(deftype TypeConstraint [type-maps path type-sym sym var]
  (assert (instance? HashMap type-maps))
  (assert (instance? List path))
  (assert (instance? Tagged type-sym))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(TypeConstraint "  (str type-maps) " (list"
          (either (map (first path) (fn [[f l]]
                                      (let [f (str f)]
                                        (str "[\"" (either (map (> (count f) 15)
                                                                (fn [len]
                                                                  (subs f (- len 15))))
                                                           f)
                                             "\" " l "]"))))
                  "")
          ") "
          (str "'" type-sym) " " (sym-str sym)
          " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (for [_ (instance? TypeConstraint y)
          y-maps (get y .type-maps)
          _ (= type-maps y-maps)]
      x))

  Constraint
  (assertion-path [_] path)

  (satisfied-by [c info]
    (flat-map (extract-type-map info)
              (fn [value-type-map]
                (and (< 0 (count value-type-map))
                     (every (keys value-type-map)
                            (partial get type-maps))))))

  (extract-type-map [_]
    (maybe type-maps))

  (format-path [x desired-len]
    (format-path* (cons [(str "Type '" type-sym "' from") ""]
                        path)
                  desired-len)))

(deftype FieldConstraint [field field-var path sym var]
  (assert (instance? Tagged field))
  (assert (instance? List path))
  (assert (instance? Maybe sym))

  Stringable
  (string-list [_]
    (list "(FieldConstraint (symbol \"" (str field) "\") \"" (str field-var) "\" (list"
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym)
          " \"" (str var) "\")"))

  Constraint
  (assertion-path [_]
    path)

  (extract-type-map [_]
    nothing)

  (restrict-types [c type-map]
    (reduce (seq type-map) {}
            (fn [type-map [type-num field-set]]
              (either (map (field-set field)
                           (fn [_] (assoc type-map type-num field-set)))
                      type-map))))

  (format-path [x desired-len]
    (format-path* (cons [(str "Field '" (subs (str field) 1) "' required from") ""]
                        path)
                  desired-len)))

(deftype StaticIntConstraint [val path sym var]
  (assert (instance? Integer val))
  (assert (instance? List path))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(StaticIntConstraint " (str val) " (list"
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (assertion-path [c]
    (.path c))

  (format-path [x desired-len]
    (format-path* (cons ["Integer from" ""] path)
                  desired-len))

  (extract-type-map [_]
    (maybe {IntegerType #{}})))

(deftype MinValue [min path sym var]
  (assert (instance? Integer min))
  (assert (instance? List path))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(MinValue " (str min) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (assertion-path [_]
    path)

  (extract-type-map [_]
    (maybe {IntegerType #{}}))

  (format-path [x desired-len]
    (format-path* (cons [(str "Min value of " min " from") ""] path)
                  desired-len))

  (update-var [c new-var]
    (.var c new-var))

  (intersect [mvc c]
    (either (= mvc c)
            (intersect (update-var c (.var mvc)) mvc))))

(deftype MaxValue [max path sym var]
  (assert (instance? Integer max))
  (assert (instance? List path))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(MaxValue " (str max) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (assertion-path [_]
    path)

  (extract-type-map [_]
    (maybe {IntegerType #{}}))

  (format-path [x desired-len]
    (format-path* (cons [(str "Max value of " max " from") ""] path)
                  desired-len)))

(deftype InferredInner [inner path sym var]
  (assert (instance? List path))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(InferredInner " (str inner) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (extract-items-constraints [c n]
    (vec (repeat n inner)))

  (extract-type-map [_]
    nothing)

  (assertion-path [_]
    path)

  (format-path [x desired-len]
    (format-path* (cons ["Contents restriction from" ""] path)
                  desired-len)))

(deftype StaticLengthConstraint [length path sym var]
  (assert (instance? Integer length))
  (assert (instance? List path))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Stringable
  (string-list [c]
    (list "(StaticLengthConstraint " (str length) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (assertion-path [c]
    (.path c))

  (format-path [x desired-len]
    (format-path* (cons [(str "Length from") ""]
                          (.path x))
                    desired-len))

  (extract-type-map [_]
    (maybe {ListType #{}
            VectorType #{}})))

(deftype StaticStrConstraint [val path sym var]
  (assert (instance? String val))
  (assert (instance? List path))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(StaticStrConstraint " val " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (format-path [x desired-len]
    (format-path* (cons ["String from" ""] path)
                  desired-len))

  (extract-type-map [_]
    (maybe {StringBufferType #{}
            SubStringType #{}}))

  (assertion-path [c]
    (.path c)))

(extend-type Symbol
  Constraint
  (assertion-path [_]
    empty-list)

  (format-path [_ desired-len]
    (format-path* (list ["Symbol from" ""])
                  desired-len))

  (extract-type-map [_]
    (maybe {SymbolType #{}}))

  (intersect [slc c]
    (either (or (= slc c)
                (and (instance? Symbol c)
                     (maybe (NoValues [slc c])))
                (for [type-map (extract-type-map c)
                      :when (get type-map SymbolType)]
                  slc))
            (NoValues [slc c]))))

(extend-type Integer
  Constraint
  (intersect [x c]
    (intersect (StaticIntConstraint x empty-list nothing "") c)))

(extend-type String
  Constraint
  (intersect [x c]
    (intersect (StaticStrConstraint x empty-list nothing "") c)))

(extend-type Vector
  Constraint
  (intersect [v c]
    (intersect (ItemsConstraint v top-type empty-list nothing "") c)))

(def StaticConstraints (comp StaticLengthConstraint
                             StaticStrConstraint
                             StaticIntConstraint))

(deftype CollectionOf [constraints path sym var]
  (assert (instance? List path))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(CollectionOf " (str constraints) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (update-var [c new-var]
    (.var c new-var))

  (update-sym [c new-sym]
    (.sym c new-sym))

  (extract-type-map [_]
    nothing)

  (assertion-path [_]
    path)

  (format-path [x desired-len]
    (format-path* (cons ["Contents from" ""] path)
                  desired-len)))

(def SymbolConstraints (comp TypeConstraint
                             MinValue
                             MaxValue
                             InferredInner
                             StaticConstraints
                             ItemsConstraint
                             CollectionOf
                             FieldConstraint))

(deftype MultiConstraint [constraints]
  (assert (instance? Vector constraints))

  Stringable
  (string-list [_] (list "(MultiConstraint [" (to-str (interpose constraints "\n")) "])"))

  Constraint
  (extract-var [_]
    (either (some constraints (fn [c]
                                (let [var (extract-var c)]
                                  (or (and (= "" var)
                                           nothing)
                                      (maybe var)))))
            ""))

  (extract-sym [c]
    (some constraints extract-sym))

  (extract-type-map [mc]
    (reduce (.constraints mc) nothing
            (fn [type-map c]
              (or (map type-map (partial restrict-types c))
                  (extract-type-map c)))))

  (clear-sym [mc]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (clear-sym c)))))

  (update-sym [mc sym]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-sym c sym)))))

  (update-var [mc var]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-var c var)))))

  (format-path [_ n]
    (let [max-len (reduce (map constraints (fn [o]
                                             (count (.path o))))
                          n
                          (fn [max-len path-len]
                            (either (> max-len path-len)
                                    path-len)))
          paths (map constraints (fn [c]
                                   (format-path c (inc max-len))))]
      (-> paths
          (list-zipper empty-list)
          (map (fn [strs]
                 (to-str (interpose strs "    ")))))))

  (assertion-path [c]
    (format-path c 0))

  (update-path [mc file-name line-number]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-path c file-name line-number))))))

(def ValueConstraint (comp SymbolConstraints
                           MultiConstraint
                           AllValues))

(def Constraints (comp AllValues
                       NoValues
                       MultiConstraint
                       SymbolConstraints
                       ResultConstraint))

(defprotocol ConstraintOps
  (=-multi [y x]
    (assert (instance? MultiConstraint x))
    (assert-result r (instance? Maybe r))

    nothing)

  (intersect-result [c rc]
    (assert (instance? ResultConstraint rc))
    nothing)

  (=-result-constraint [y x]
    (assert (instance? ResultConstraint x))
    nothing)

  (intersect-typec [c tc]
    (assert (instance? TypeConstraint tc))
    (assert-result r (instance? Constraints r))

    (either (flat-map (extract-type-map c)
                      (fn [type-map]
                        (or (and (empty? (select-keys (.type-maps tc) (keys type-map)))
                                 (maybe (NoValues [tc c])))
                            (maybe (MultiConstraint [tc (update-var c (.var tc))])))))
            (intersect (update-var c (.var tc)) tc)))

  (=-contentsc [x y]
    nothing)

  (intersect-coll-of [c cc]
    (assert (instance? CollectionOf cc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (.var cc)) cc))

  (=-static-str [y x]
    nothing)

  (intersect-static-str [c slc]
    (assert (instance? StaticStrConstraint slc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (.var slc)) slc))

  (=-static-len [y x]
    nothing)

  (intersect-static-len [c slc]
    (assert (instance? StaticLengthConstraint slc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (.var slc)) slc))

  (=-inferred-inner [y x]
    nothing)

  (intersect-inner [c ic]
    (assert (instance? InferredInner ic))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (.var ic)) ic))

  (=-max-value [y x]
    (assert (instance? MaxValue x))
    nothing)

  (intersect-max-value [c mvc]
    (assert (instance? MaxValue mvc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (.var mvc)) mvc))

  (=-min-value [y x]
    (assert (instance? MinValue x))
    nothing)

  (intersect-min-value [c mvc]
    (assert (instance? MinValue mvc))
    (assert-result r (instance? Constraints r))

    (intersect c mvc))

  (=-static-int [y x]
    (assert (instance? StaticIntConstraint x))
    nothing)

  (intersect-static-int [c slc]
    (assert (instance? StaticIntConstraint slc))
    (intersect (update-var c (.var slc)) slc))

  (=-field-constraint [y x]
    (assert (instance? FieldConstraint x))
    nothing)

  (fieldc-satisfied [info c]
    (assert (instance? FieldConstraint c))
    (flat-map (extract-type-map info)
              (fn [type-map]
                (first (seq (restrict-types c type-map))))))

  (intersect-fieldc [c fc]
    (assert (instance? FieldConstraint fc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (.var fc)) fc))

  (=-items-constraint [y x]
    (assert (instance? ItemsConstraint x))
    nothing)

  (intersect-itemsc [c ic]
    (assert (instance? ItemsConstraint ic))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (.var ic)) ic))

  (intersect-multi [c mc]
    (assert (instance? MultiConstraint mc))
    (assert-result r (instance? Constraints r))

    (either (or (= (reduce (.constraints mc) c
                           (fn [x y]
                             (either (= (intersect x y) bottom-type)
                                     x)))
                   bottom-type)
                (and (some (.constraints mc) (partial = c))
                     (maybe mc)))
            (do
              ;; TODO: this blindly adds 'c', which is fine but a little inefficient
              (MultiConstraint (conj (.constraints mc) c)))))

  (conj-multi [c mc]
    (assert (instance? MultiConstraint mc))

    (either (and (some (.constraints mc) (partial = c))
                 (maybe c))
            (MultiConstraint (conj (.constraints mc) c)))))

(extend-type NoValues
  ConstraintOps
  (conj-multi [c mc]
    (maybe mc)))

(extend-type AllValues
  ConstraintOps
  (intersect-result [c rc]
    rc)

  (intersect-typec [c tc]
    tc)

  (intersect-coll-of [c cc]
    cc)

  (intersect-static-str [c slc]
    slc)

  (intersect-static-len [c slc]
    slc)

  (intersect-inner [c ic]
    ic)

  (intersect-max-value [c mvc]
    mvc)

  (intersect-min-value [c mvc]
    mvc)

  (intersect-static-int [c slc]
    slc)

  (intersect-fieldc [c fc]
    fc)

  (intersect-itemsc [c ic]
    ic)

  (intersect-multi [c mc]
    mc)

  (conj-multi [c mc]
    (maybe mc)))

(extend-type SymbolConstraints
  Constraint
  (extract-sym [c]
    (.sym c))

  (extract-var [c]
    (.var c))

  (extract-coll-type [_]
    top-type)

  (update-path [constraint file-name line-number]
    (let [new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (either (and (= "" file-name)
                   (maybe constraint))
              (.path constraint new-path))))

  (clear-sym [tc]
    (.sym tc nothing))

  (update-sym [tc new-sym]
    (.sym tc (maybe new-sym)))

  (update-var [tc new-var]
    (.var tc new-var)))

(extend-type ItemsConstraint
  Eq
  (=* [x y]
    (=-items-constraint y x))

  ConstraintOps
  (intersect-coll-of [c cc]
    (let [coll-c (.constraints cc)]
      (either (or (= (reduce (.items-constraints c)
                             top-type
                             (fn [r c]
                               (either (= r bottom-type)
                                       (-> coll-c
                                           (intersect c)
                                           (update-var (extract-var c))))))
                     bottom-type)
                  (= (intersect coll-c (.tail-constraint c))
                     bottom-type))
              (MultiConstraint [cc (update-var c (.var cc))]))))

  (intersect-static-str [c slc]
    (either (and (< (count slc) (count (extract-items-constraints c)))
                 (maybe (NoValues [slc c])))
            (MultiConstraint [slc c])))

  (intersect-static-len [c slc]
    (either (and (< (.length slc) (count (extract-items-constraints c)))
                 (maybe (NoValues [slc c])))
            (MultiConstraint [slc c])))

  (intersect-inner [c ic]
    (either (or (-> (.items-constraints c)
                    (map (fn [c2]
                           (intersect (.inner ic) c2)))
                    (some (fn [c]
                            (= c bottom-type))))
                (= (intersect (.tail-constraint c) ic)
                   bottom-type))
            (MultiConstraint [ic (update-var c (.var ic))])))

  (intersect-typec [c tc]
    (assert (instance? TypeConstraint tc))

    (MultiConstraint [tc (update-var c (.var tc))]))

  (intersect-max-value [c mvc]
    (NoValues [mvc c]))

  (intersect-static-int [c slc]
    (NoValues [slc c]))

  (=-items-constraint [y x]
    (and (= (.items-constraints y) (.items-constraints x))
         (= (.tail-constraint y) (.tail-constraint x))
         (maybe x)))

  (intersect-itemsc [c ic]
    (assert (instance? ItemsConstraint ic))

    (let [items-ic (extract-items-constraints ic)
          items-c (extract-items-constraints c)
          cnt-ic (count items-ic)
          cnt-c (count items-c)
          max-cnt (either (> cnt-ic cnt-c)
                          cnt-c)
          inner-tail-ic (extract-inner-constraint (.tail-constraint ic))
          inner-tail-ic (either (= top-type inner-tail-ic)
                                (.inner inner-tail-ic))
          inner-tail-c (extract-inner-constraint (.tail-constraint c))
          inner-tail-c (either (= top-type inner-tail-c)
                               (.inner inner-tail-c))
          items-ic (comp items-ic (repeat (- max-cnt cnt-ic) inner-tail-ic))
          items-c (comp items-c (repeat (- max-cnt cnt-c) inner-tail-c))
          constraints (map (zip-lists items-ic items-c)
                           (fn [[c1 c2]]
                             (intersect c1 c2)))
          new-tail (intersect inner-tail-ic inner-tail-c)]
      (either (or (some constraints (fn [c]
                                      (= c bottom-type)))
                  (= new-tail bottom-type))
              (-> ic
                  (.tail-constraint new-tail)
                  (.items-constraints (vec constraints))))))

  (intersect-fieldc [c fc]
    (NoValues [fc c]))

  (intersect-min-value [c mvc]
    (NoValues [mvc c]))

  Constraint
  (intersect [ic c]
    (either (=-items-constraint c ic)
            (intersect-itemsc c ic)))

  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (ItemsConstraint (map (.items-constraints constraint)
                            (fn [constraints]
                              (update-path constraints file-name line-number)))
                       (update-path (.tail-constraint constraint) file-name line-number)
                       new-path
                       (.sym constraint) (.var constraint)))))

(extend-type Constraints
  Constraint
  (extract-inner-constraint [_]
    top-type))

(extend-type MultiConstraint
  Eq
  (=* [x y]
    (=-multi y x))

  Collection
  (conj [mc c]
    (conj-multi c mc))

  ConstraintOps
  (=-multi [y x]
    (and (= (.constraints x) (.constraints y))
         (maybe x)))

  (intersect-inner [c ic]
    (either (= (reduce (.constraints c) ic
                       (fn [x y]
                         (either (= (intersect x y) bottom-type)
                                 x)))
               bottom-type)
            (conj c ic)))

  (intersect-typec [c tc]
    (intersect c tc))

  (conj-multi [c mc]
    (reduce (.constraints c) mc conj))

  (intersect-multi [c mc]
    (reduce (.constraints c) mc
            (fn [mc new-c]
              (either (= mc bottom-type)
                      (intersect mc new-c)))))

  Constraint
  (intersect [mc c]
    (intersect-multi c mc))

  (extract-coll-type [mc]
    (either (some (.constraints mc) (partial instance? CollectionOf))
            top-type))

  (satisfied-by [c info]
    (let [type-map (extract-type-map c)]
      (and (or (= nothing type-map)
               (flat-map type-map
                         (fn [type-map]
                           (satisfied-by (TypeConstraint type-map empty-list (symbol "<unknown>") nothing "")
                                         info))))
           (every (.constraints c)
                  (fn [inner-c]
                    (satisfied-by inner-c info))))))

  (extract-items-constraints [mc]
    (let [coll-c (either (-> (.constraints mc)
                             (some (partial instance? CollectionOf))
                             (map .constraints))
                         top-type)]
      (either (-> (.constraints mc)
                  (some (partial instance? ItemsConstraint))
                  (map (fn [ic]
                         (-> (extract-items-constraints ic)
                             (map (fn [c]
                                    (-> c
                                        (intersect (extract-inner-constraint mc))
                                        (update-var (extract-var c)))))
                             (map (fn [c]
                                    (-> c
                                        (intersect coll-c)
                                        (update-var (extract-var c)))))))))
              [])))

  (extract-inner-constraint [c]
    (either (some (.constraints c) (fn [c]
                                     (instance? InferredInner c)))
            top-type)))

(extend-type ResultConstraint
  Eq
  (=* [x y]
    (and (or (=-result-constraint y x)
             (=* (.assertion x) y))
         (maybe x)))

  Constraint
  (intersect [rc c]
    (let [intersected (either (intersect-result c rc)
                              (intersect (.assertion rc) c))]
      (either (= intersected bottom-type)
              (ResultConstraint intersected))))

  ConstraintOps
  (=-result-constraint [y x]
    (=* (.assertion x) (.assertion y)))

  (intersect-result [c rc]
    (maybe (intersect (.assertion rc) (.assertion c)))))

(extend-type TypeConstraint
  Constraint
  (intersect [tc c]
    (intersect-typec c tc))

  ConstraintOps
  (intersect-coll-of [tc c]
    (either (for [type-map (extract-type-map c)
                  _ (empty? (select-keys (.type-maps tc) (keys type-map)))]
              (maybe (NoValues [tc c])))
            (MultiConstraint [c (update-var tc (extract-var c))])))

  (intersect-inner [c ic]
    (let [new-type-map (dissoc (.type-maps c) IntegerType SymbolType)]
      ;; TODO: incomplete. need to account for Strings
      ;; also account for Fn's
      (either (and (empty? new-type-map)
                   (maybe (NoValues [ic c])))
              (MultiConstraint [ic (-> c
                                       (.type-maps new-type-map)
                                       (update-var (.var ic)))]))))

  (intersect-fieldc [c fc]
    (let [field (.field fc)
          new-map (reduce (seq (.type-maps c))
                          {}
                          (fn [type-map [type-num fields]]
                            (either (map (fields field) (fn [_]
                                                          (assoc type-map type-num fields)))
                                    type-map)))]
      (either (and (empty? new-map)
                   (maybe (NoValues [fc c])))
              (MultiConstraint [fc (-> c
                                       (.type-maps new-map)
                                       (update-var (.var fc)))]))))

  (intersect-typec [c tc]
    (either (or (= tc c)
                (and (empty? (select-keys (.type-maps tc) (keys (.type-maps c))))
                     (maybe (NoValues [tc c]))))
            (.type-maps tc (filter-keys (.type-maps tc)
                                        (fn [k]
                                          (get (.type-maps c) k)))))))

(extend-type FieldConstraint
  Eq
  (=* [x y]
    (=-field-constraint y x))

  Constraint
  (satisfied-by [c info]
    (fieldc-satisfied info c))

  (intersect [fc c]
    (intersect-fieldc c fc))

  ConstraintOps
  (intersect-coll-of [c cc]
    (either (and (= (.field c) '.set-map)
                 (maybe (MultiConstraint [cc (update-var c (.var cc))])))
            (NoValues [cc c])))

  (intersect-static-str [c slc]
    (NoValues [slc c]))

  (intersect-static-len [c slc]
    (NoValues [slc c]))

  (intersect-inner [c ic]
    (MultiConstraint [ic (update-var c (.var ic))]))

  (intersect-max-value [c mvc]
    (NoValues [mvc c]))

  (=-field-constraint [y x]
    (and (= (.field y) (.field y))
         (maybe x)))

  (fieldc-satisfied [info c]
    (= (.field info) (.field c)))

  (intersect-fieldc [c fc]
    (MultiConstraint [fc (update-var c (.var fc))]))

  (intersect-static-int [c slc]
    (NoValues [slc c]))

  (intersect-min-value [c mvc]
    (NoValues [mvc c])))

(extend-type StaticIntConstraint
  Eq
  (=* [x y]
    (=-static-int y x))

  Constraint
  (intersect [slc c]
    (intersect-static-int c slc))

  ConstraintOps
  (intersect-coll-of [c cc]
    (NoValues [cc c]))

  (intersect-static-str [c slc]
    (NoValues [slc c]))

  (intersect-static-len [c slc]
    (NoValues [slc c]))

  (intersect-inner [c ic]
    (NoValues [ic c]))

  (=-static-int [y x]
    (and (= (.val y) (.val x))
         (maybe x)))

  (intersect-max-value [c mvc]
    (either (<= (.val c) (.max mvc))
            (NoValues [mvc c])))

  (intersect-static-int [c slc]
    (either (= slc c)
            (NoValues [slc c])))

  (intersect-min-value [c mvc]
    (either (and (< (.val c) (.min mvc))
                 (maybe (NoValues [mvc c])))
            c)))

(extend-type MinValue
  Eq
  (=* [x y]
    (=-min-value y x))

  Constraint
  (intersect [mvc c]
    (print-err 'intersect-min mvc c)
    (intersect-min-value c mvc))

  ConstraintOps
  (intersect-static-len [c ic]
    (NoValues [ic c]))

  (intersect-static-str [c ic]
    (NoValues [ic c]))

  (intersect-inner [c ic]
    (NoValues [ic c]))

  (intersect-max-value [c mvc]
    (either (and (<= (.min c) (.max mvc))
                 (maybe (MultiConstraint [c mvc])))
            (NoValues [mvc c])))

  (=-min-value [y x]
    (and (= (.min y) (.min x))
         (maybe x)))

  (intersect-min-value [c mvc]
    (either (=* c mvc)
            (.min mvc (either (< (.min mvc) (.min c))
                              (.min c))))))

(extend-type InferredInner
  Eq
  (=* [x y]
    (=-inferred-inner y x))

  Constraint
  (intersect [ic c]
    (intersect-inner c ic))

  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (-> constraint
          (.inner (update-path (.inner constraint) file-name line-number))
          (.path new-path))))

  (extract-inner-constraint [c]
    c)

  ConstraintOps
  (intersect-coll-of [c cc]
    (let [new-inner (intersect (.constraints cc) (.inner c))]
      (either (= new-inner bottom-type)
              (MultiConstraint [(.constraints cc new-inner)
                                (-> c
                                    (.inner new-inner)
                                    (update-var (.var cc)))]))))

  (intersect-static-str [c slc]
    (either (= (intersect (.inner c) (TypeConstraint {StringBufferType #{} SubStringType #{}}
                                                     (.path slc) 'String (.sym slc) (.var slc)))
               bottom-type)
            slc))

  (intersect-static-len [c slc]
    (MultiConstraint [slc c]))

  (=-inferred-inner [y x]
    (and (= (.inner x) (.inner y))
         (maybe x)))

  (intersect-inner [c ic]
    (let [new-c (intersect (.inner ic) (.inner c))]
      (either (= new-c bottom-type)
              (.inner ic new-c)))))

(extend-type MaxValue
  Eq
  (=* [x y]
    (=-max-value y x))

  ConstraintOps
  (intersect-coll-of [c cc]
    (NoValues [cc c]))

  (intersect-static-str [c slc]
    (NoValues [slc c]))

  (intersect-static-len [c slc]
    (NoValues [slc c]))

  (intersect-inner [c ic]
    (NoValues [ic c]))

  (=-max-value [y x]
    (and (= (.max x) (.max y))
         (maybe x)))

  (intersect-max-value [c mvc]
    (.max mvc (either (< (.max mvc) (.max c))
                      (.max c))))

  Constraint
  (intersect [mvc c]
    (intersect-max-value c mvc)))

(extend-type StaticLengthConstraint
  Eq
  (=* [x y]
    (=-static-len y x))

  Constraint
  (intersect [slc c]
    (intersect-static-len c slc))

  ConstraintOps
  (intersect-coll-of [c cc]
    (MultiConstraint [cc (update-var c (.var cc))]))

  (intersect-static-str [c slc]
    (MultiConstraint [slc c]))

  (intersect-static-len [c slc]
    (either (= slc c)
            (NoValues [slc c])))

  (=-static-len [y x]
    (and (= (.length x) (.length y))
         (maybe x))))

(extend-type StaticStrConstraint
  Eq
  (=* [x y]
    (=-static-str y x))

  Constraint
  (intersect [slc c]
    (intersect-static-str c slc))

  ConstraintOps
  (intersect-coll-of [c cc]
    (NoValues [cc c]))

  (=-static-str [y x]
    (and (= (.val x) (.val y))
         (maybe x)))

  (intersect-static-str [c slc]
    (either (= slc c)
            (NoValues [slc c]))))

(extend-type CollectionOf
  Eq
  (=* [x y]
    (=-contentsc y x))

  Constraint
  (extract-coll-type [x]
    x)

  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (CollectionOf (update-path (.constraints constraint) file-name line-number)
                    new-path
                    (.sym constraint) (.var constraint))))


  (extract-type-map [c]
    (maybe {ListType #{}
            MaybeType #{}
            BitmapIndexedType #{}
            ArrayNodeType #{}
            HashCollisionNodeType #{}
            PromiseType #{}
            HashSetType #{'set-map}
            FutureType #{}
            AgentType #{}
            VectorType #{}}))

  (intersect [cc c]
    (intersect-coll-of c cc))

  ConstraintOps
  (intersect-coll-of [c cc]
    (either (= cc c)
            (let [contents (intersect (.constraints cc) (.constraints c))]
              (either (= contents bottom-type)
                      (.constraints cc contents)))))

  (=-contentsc [x y]
    (and (= (.constraints x) (.constraints y))
         (maybe x))))

(defn conflicting-assertions [failing-constraint file-name line-number]
  (apply print-err (list* "Conflicting assertions"
                           (either (= "" file-name)
                                   (str "at " file-name ": " line-number))
                           "\n"
                           (format-path failing-constraint 0)))
  nothing)

(defn compose-constraints [file-name line-number x y]
  (assert (instance? Constraints x))
  (assert (instance? Constraints y))

  (let [z (intersect x y)]
    (either (and (= bottom-type z)
                 (let [z (either
                          (and (flat-map (get z .constraints)
                                         (fn [constraints]
                                           (< 1 (count constraints))))
                               (maybe z))
                          (NoValues [x y]))]
                   (maybe (conflicting-assertions z file-name line-number))))
            (maybe z))))
