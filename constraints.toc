
(def SymbolOrString (any-of Symbol
                            String))

(deftype Location [file line]
  (assert (instance? SymbolOrString file))
  (assert (instance? Integer line))

  Stringable
  (string-list [_]
    (list (either (and (= file 'core)
                       (maybe "core"))
                  (str file))
          ": " (str line)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(defn sym-str [s]
  (either (or (and (instance? Symbol s)
                   (maybe (str "'" s))))
          (str s)))

;; TODO: remove unused types
(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -2, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FunctionType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MaybeType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ListType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SymbolType};"))
(def BitmapIndexedType (inline C Integer "(Value *)&(Integer){IntegerType, -2, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ArrayNodeType};"))
(def HashCollisionNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -2, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, OpaqueType};"))
(def NoValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, NoValuesType};"))
(def AllValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AllValuesType};"))
(def ResultConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ResultConstraintType};"))
;; TODO: what the heck is this used for. Get rid of it
(def InferredInnerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InferredInnerType};"))
(def ContentsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ContentsConstraintType};"))
(def HashSetType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashSetType};"))
(def ProtoDispatcherType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ProtoDispatcherType};"))
(def FloatType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FloatType};"))
(def SumConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SumConstraintType};"))
(def TypeOfConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeOfConstraintType};"))
(def InnerTypeOfConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InnerTypeOfConstraintType};"))
(def DebugConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, DebugConstraintType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeCount};"))

;; type compoonents
(deftype NoSymbol []
  Stringable
  (string-list [_]
    (list "c/no-symbol"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (instance? NoSymbol y)))

(def OptionalSym (any-of NoSymbol
                         Symbol))

(def no-symbol (NoSymbol))

(deftype NoInt []
  Stringable
  (string-list [_]
    (list "c/no-int"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (instance? NoInt y))

  Ord
  (<* [x y]
    (and (instance? Integer y)
         (maybe x))))

(def OptionalInt (any-of NoInt
                         Integer))
(def no-int (NoInt))

(deftype NoString []
  Stringable
  (string-list [_]
    (list "c/no-string"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (instance? NoString y)))

(def no-string (NoString))

(deftype NoTail []
  Stringable
  (string-list [_]
    (list "c/no-tail"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def no-tail (NoTail))

(deftype NoFields []
  Stringable
  (string-list [_]
    (list "c/no-fields")))

(def no-fields (NoFields))

(deftype NoArgs []
  Stringable
  (string-list [_]
    (list "c/no-args"))

  Eq
  (=* [x y]
    (and (instance? NoArgs y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def no-args (NoArgs))

(deftype Variadic []
  Stringable
  (string-list [_] (list "c/variadic")))

(def variadic (Variadic))

(def ArityRank (any-of Integer
                       Variadic))

(deftype Field [sym]
  (assert (instance? Symbol sym))

  Stringable
  (string-list [_]
    (list (str "(c/Field (symbol \"" sym "\"))")))

  Eq
  (=* [x y]
    (and (instance? Field y)
         (= sym (.sym y))
         (maybe x)))

  Container
  (map [x _]
    x)

  (map [x _ embed]
    (embed x)))

;; universal types
(deftype AllValues [path var]
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "c/top-type"))

  Eq
  (=* [x y]
    (and (instance? AllValues y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype NoValues [constraints]
  Stringable
  (string-list [_]
    (list "(c/NoValues [" (to-str (interpose constraints "\n")) "])"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (and (instance? NoValues y)
         (or (and (empty? constraints)
                  (maybe y))
             (maybe x)))))

;; atomic types
(deftype SymbolConstraint [static-value path sym var]
  (assert (instance? OptionalSym static-value))
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/SymbolConstraint " (sym-str static-value) " "
          "empty-list "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? SymbolConstraint y)
         (or (= static-value (.static-value y))
             (= no-symbol static-value)
             (= no-symbol (.static-value y)))
         (maybe x)))

  Container
  (map [x _]
    x)

  (map [x _ embed]
    (embed x)))

(deftype OpaqueConstraint [path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/OpaqueConstraint " "empty-list "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? OpaqueConstraint y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

;; atomic and container types
(deftype StrBuffConstraint [static-value path sym var]
  (assert (instance? (any-of String
                             NoString) static-value))
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/StrBuffConstraint " (either (map (= static-value no-string) str)
                                          (str "\"" static-value "\"")) " "
          "empty-list "
          ;; (str (cons 'list path)) " "
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? StrBuffConstraint y)
         (or (= static-value (.static-value y))
             (= no-string static-value)
             (= no-string (.static-value y)))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype SubStrConstraint [static-value path sym var]
  (assert (instance? (any-of String
                             NoString) static-value))
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/SubStrConstraint " (either (map (= static-value no-string) str)
                                         (str "\"" static-value "\"")) " "
          "empty-list "
          ;; (str (cons 'list path)) " "
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? SubStrConstraint y)
         (or (= static-value (.static-value y))
             (= no-string static-value)
             (= no-string (.static-value y)))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

;; container types
(deftype ListConstraint [items tail-c path sym var]
  (assert (instance? Vector items))
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/ListConstraint [" (to-str (interpose items "\n")) "]\n"
          (str tail-c)
          " "
          "empty-list "
          ;; (str (cons 'list path)) " "
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? ListConstraint y)
         (= items (.items y))
         (= tail-c (.tail-c y))
         (maybe x)))

  Container
  (map [c f]
    (-> c
        (.tail-c (f (.tail-c c)))
        (.items (map (.items c) f))))

  (map [c f embed]
    (for [new-tail-c (f (.tail-c c))
          new-items (map (.items c) f embed)]
      (-> c
          (.tail-c new-tail-c)
          (.items new-items)))))
(def empty-list-constraint (ListConstraint [] no-tail empty-list no-symbol ""))

(deftype VectorConstraint [items tail-c path sym var]
  (assert (instance? Vector items))
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/VectorConstraint [" (to-str (interpose items "\n")) "]\n"
          (str tail-c)
          " "
          "empty-list "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? VectorConstraint y)
         (= items (.items y))
         (= tail-c (.tail-c y))
         (maybe x)))

  Container
  (map [c f]
    (-> c
        (.tail-c (f (.tail-c c)))
        (.items (map (.items c) f))))

  (map [c f embed]
    (for [new-tail-c (f (.tail-c c))
          new-items (map (.items c) f embed)]
      (-> c
          (.tail-c new-tail-c)
          (.items new-items)))))
(def empty-vect-constraint (VectorConstraint [] no-tail empty-list no-symbol ""))

(deftype MaybeConstraint [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/MaybeConstraint " (str contents) "\n"
          "empty-list "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? MaybeConstraint y)
         (= contents (.contents y))
         (maybe x)))

  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (map (f (.contents x))
         (partial .contents x))))

(deftype HashMapConstraint [type-num kv-pairs keys-c vals-c path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/HashMapConstraint " (str type-num) " " (str kv-pairs) " "
          (str keys-c) " " (str vals-c) " "
          "empty-list "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? HashMapConstraint y)
         (= kv-pairs (.kv-pairs y))
         (= keys-c (.keys-c y))
         (= vals-c (.vals-c y))
         (maybe x)))

  Container
  (map [c f]
    (-> c
        (.keys-c (f (.keys-c c)))
        (.vals-c (f (.vals-c c)))
        (.kv-pairs (-> (.kv-pairs c)
                       vec
                       (reduce {} (fn [m [k v]]
                                    (assoc m
                                      (f k) (f v))))))))

  (map [c f embed]
    (for [new-keys (f (.keys-c c))
          new-vals (f (.vals-c c))
          new-kv (-> (.kv-pairs c)
                     vec
                     (map (fn [[key-c val-c]]
                            (for [new-key (f key-c)
                                  new-val (f val-c)]
                              [new-key new-val]))
                          embed))]
      (-> c
          (.keys-c new-keys)
          (.vals-c new-vals)
          (.kv-pairs (reduce new-kv {} (fn [m [k v]]
                                         (assoc m k v))))))))

(deftype AgentConstraint [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/AgentConstraint " (str contents) " "
          "empty-list "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? AgentConstraint y)
         (= contents (.contents y))
         (maybe x)))

  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (map (f (.contents x))
         (partial .contents x))))

(deftype FutureConstraint [path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/FutureConstraint " "empty-list "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? FutureConstraint y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype PromiseConstraint [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/PromiseConstraint " (str contents) " "
          "empty-list "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? PromiseConstraint y)
         (= contents (.contents y))
         (maybe x)))

  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (map (f (.contents x))
         (partial .contents x))))


(deftype fn-arity [arity-id param-consts result-const]
  (assert (instance? OptionalSym arity-id))
  (assert (instance? ListConstraint param-consts))

  Stringable
  (string-list [_]
    (list "(c/fn-arity " (str "'" arity-id) "\n" (str param-consts) "\n" (str result-const) ")"))

  Eq
  (=* [x y]
    (and (instance? fn-arity y)
         (= param-consts (.param-consts y))
         (= result-const (.result-const y))
         (maybe x)))

  Container
  (map [x f]
    (let [new-fixed (map (.items param-consts) f)
          new-var (f (.tail-c param-consts))]
      (-> x
          (.param-consts (-> empty-list-constraint
                             (.items new-fixed)
                             (.tail-c new-var)))
          (.result-const (f result-const)))))

  (map [x f embed]
    (for [new-fixed (map (.items param-consts) f embed)
          new-var (f (.tail-c param-consts))
          new-result (f (.result-const x))]
      (-> x
          (.param-consts (-> empty-list-constraint
                             (.items new-fixed)
                             (.tail-c new-var)))
          (.result-const new-result)))))

(deftype FnConstraint [required-arities arities path sym var]
  ;; (assert (instance? (map-of ArityRank fn-arity) arities))
  (assert (instance? (vector-of Integer) required-arities))
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/FnConstraint [" (to-str (interpose required-arities " ")) "]"
          "\n" (str arities)
          "\n empty-list "
          ;; "\n" (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? FnConstraint y)
         (= (count required-arities) (count (.required-arities y)))
         (every (.required-arities y) (fn [arity-rank]
                                       (some required-arities (partial = arity-rank))))
         (=* arities (.arities y))
         (maybe x)))

  Container
  (map [x f]
    (.arities x (map-vals arities f)))

  (map [x f embed]
    (map (contextual-map-vals arities f embed)
         (fn [a]
           (.arities x a)))))

;; product type
(deftype ReifiedConstraint [type-number type-symbol field-consts fields invoke-fn path sym var]
  (assert (instance? Integer type-number))
  ;; TODO: put this in
  ;; (assert (instance? (min-value 1) type-num))
  (assert (instance? OptionalSym type-symbol))
  (assert (instance? HashMap fields))
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/ReifiedConstraint " (str type-number) " " (cond (= no-symbol type-symbol)
                                                              (str no-symbol)
                                                              (str " (symbol \"" type-symbol "\")"))
          "\n" (str field-consts)
          "\n" (str fields)
          "\n" (str invoke-fn)
          ;; (str (interpose (cons 'list path) " "))
          " empty-list "
          " " (sym-str sym) " \"" (str var) "\")" ))

  Eq
  ;; TODO: equality must check the field maps as well
  ;; verify this
  (=* [x y]
    (for [_ (instance? ReifiedConstraint y)
          _ (= fields (.fields y))]
      x))

  Container
  (map [tc f]
    (-> tc
        (.field-consts (-> (.field-consts tc)
                           vec
                           (map (fn [[fld fld-c]]
                                  [(f fld) (f fld-c)]))
                           (reduce {} (fn [m [k v]]
                                        (assoc m k v)))))
        (.fields (-> (.fields tc)
                     vec
                     (map (fn [[fld fld-c]]
                            [(either (instance? Symbol fld)
                                     (f fld))
                             (either (instance? OptionalInt fld-c)
                                     (f fld-c))]))
                     (reduce {} (fn [m [k v]]
                                  (assoc m k v)))))
        (.invoke-fn (f (.invoke-fn tc)))))

  (map [tc f embed]
    (for [new-field-cs (-> (.field-consts tc)
                           vec
                           (map (fn [[fld fld-c]]
                                  (for [new-fld (f fld)
                                        new-c (f fld-c)]
                                    [new-fld new-c]))
                                embed)
                           (map (fn [new-flds]
                                  (reduce new-flds {} (fn [m [k v]]
                                                        (assoc m k v))))))
          new-fields (-> (.fields tc)
                         vec
                         (map (fn [[fld fld-c]]
                                (for [new-fld (either (map (instance? Symbol fld) embed)
                                                      (f fld))
                                      new-c (either (map (instance? OptionalInt fld-c) embed)
                                                      (f fld-c))]
                                  [new-fld new-c]))
                              embed)
                         (map (fn [new-flds]
                                (reduce new-flds {} (fn [m [k v]]
                                                      (assoc m k v))))))
          new-invoke (f (.invoke-fn tc))]
      (-> tc
          (.field-consts new-field-cs)
          (.fields new-fields)
          (.invoke-fn new-invoke)))))

;; type attributes
(deftype CollectionOf [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/CollectionOf\n" (str contents)
          "\nempty-list "
          ;; " (list "
          ;; (either (map (first path) (fn [[f l]]
          ;;                             (str "[\"" f "\" " l "]")))
          ;;         "")
          ;; ") "
          (sym-str sym) " \"" (str var) "\")"))

  Eq
  (=* [x y]
    (and (instance? CollectionOf y)
         (= contents (.contents y))
         (maybe x)))

  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (-> (.contents x)
        f
        (map (partial .contents x)))))

;; sum type
(deftype SumConstraint [alts path sym var]
  (assert (instance? Vector alts))
  (assert (instance? (min-count 1) alts))
  (assert (instance? OptionalSym sym))
  (assert (instance? (list-of Vector) path))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list (str "(c/SumConstraint\n[" (to-str (interpose alts "\n\n")) "]"
               " empty-list "
               ;; "\n(list" (either (map (first path) (fn [[f l]]
               ;;                             (str "[\"" f "\" " l "]")))
               ;;         "") ") "
               (sym-str sym) " "
               (str "\"" var "\"") ")")))

  Eq
  (=* [x y]
    (and (instance? SumConstraint y)
         (= (count alts) (count (.alts y)))
         (every (.alts y) (fn [c]
                            (some alts (partial =* c))))
         (maybe x)))

  Container
  (map [x f]
    (.alts x (map (.alts x) f)))

  (map [x f embed]
    (-> (.alts x)
        (map f embed)
        (map (partial .alts x)))))

;; computed types
(deftype ComputedConstraint [mods path sym var]
  (assert (instance? OptionalSym sym))

  Stringable
  (string-list [_]
    (list "(c/ComputedConstraint "
          "\n[" (to-str (interpose mods "\n"))
          "]\n"
           "empty-list"
          ;; (str " " (cons 'list path))
          " " (sym-str sym)
          " " (str "\"" var "\"")
          ")"))

  Eq
  (=* [x y]
    (and (instance? ComputedConstraint y)
         (= mods (.mods y))
         (maybe x)))

  Container
  (map [x f]
    (.mods x (map (.mods x) f)))

  (map [x f embed]
    (map (map (.mods x) f embed)
         (fn [new-mods]
           (.mods x new-mods)))))

(deftype ParamConstraint [arity param-index path sym var]
  (assert (instance? OptionalSym sym))

  Stringable
  (string-list [_]
    (list "(c/ParamConstraint " (str "'" arity) " " (str param-index)
          " empty-list"
          ;; (str " " (cons 'list path))
          " " (sym-str sym)
          " " (str "\"" var "\"")
          ")"))

  Eq
  (=* [x y]
    (and (instance? ParamConstraint y)
         (or (= arity (.arity y))
             (= (.arity y) arity))
         (= param-index (.param-index y))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

;; Get's replaced with the constraint of the param-sym, so not many implementations for it
(deftype TypeOfConstraint [param-sym path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/TypeOfConstraint " (sym-str param-sym)
          " empty-list "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? TypeOfConstraint y)
         (= param-sym (.param-sym y))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

;; type operations
(deftype InnerTypeOfConstraint [path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/InnerTypeOfConstraint "
          "empty-list "
          ;; (str (cons 'list path))
          " " (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? InnerTypeOfConstraint y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def inner-type-of-constraint (InnerTypeOfConstraint empty-list no-symbol ""))

;; TODO: make this be NthOf
(deftype FirstOf [base-sym path sym var]
  (assert (instance? Symbol base-sym))

  Stringable
  (string-list [_]
    (list "(c/FirstOf " (str "'" base-sym) " "
          "empty-list "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? FirstOf y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype LastOf [base-sym path sym var]
  (assert (instance? Symbol base-sym))

  Stringable
  (string-list [_]
    (list "(c/LastOf " (str "'" base-sym) " "
          "empty-list "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? LastOf y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype RestOf [base-sym path sym var]
  (assert (instance? Symbol base-sym))

  Stringable
  (string-list [_]
    (list "(c/RestOf " (str "'" base-sym) " "
          "empty-list "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? RestOf y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype ButLastOf [base-sym path sym var]
  (assert (instance? Symbol base-sym))

  Stringable
  (string-list [_]
    (list "(c/ButLastOf " (str "'" base-sym) " "
          "empty-list "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? ButLastOf y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype ListFrom [base-sym path sym var]
  (assert (instance? Symbol base-sym))

  Stringable
  (string-list [_]
    (list "(c/ListFrom " (str "'" base-sym) " "
          "empty-list "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? ListFrom y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype VectFrom [base-sym path sym var]
  (assert (instance? Symbol base-sym))

  Stringable
  (string-list [_]
    (list "(c/VectFrom " (str "'" base-sym) " "
          "empty-list "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? VectFrom y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype ArgOf [fn-sym arg-position path sym var]
  (assert (instance? Symbol fn-sym))
  (assert (instance? Integer arg-position))
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/ArgOf " (sym-str fn-sym) " " (str arg-position)
          " empty-list"
          ;; (str " " (cons 'list path))
          " " (sym-str sym)
          " " (str "\"" var "\"")
          ")"))

  Eq
  (=* [x y]
    (and (instance? ArgOf y)
         (= arg-position (.arg-position y))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype CallValue [args path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/CallValue "
          (either (map (= no-args args) (fn [_]
                                          "c/no-args"))
                  (str "\n[" (to-str (interpose args "\n")) "]"))
          " empty-list"
          ;; (str " " (cons 'list path))
          " " (sym-str sym)
          " " (str "\"" var "\"")
          ")"))

  Eq
  (=* [x y]
    (and (instance? CallValue y)
         (= args (.args y))
         (maybe x)))

  Container
  (map [x f]
    (.args x (map args f)))

  (map [x f embed]
    (map (map args f embed)
         (partial .args x))))

(deftype SetTo [fld-path fld-c]
  (assert (instance? Vector fld-path))

  Stringable
  (string-list [_]
    (list "(c/SetField " (str fld-path) " " (str fld-c) ")"))

  Eq
  (=* [x y]
    (and (instance? SetTo y)
         (= fld-path (.fld-path y))
         (= fld-c (.fld-c y))
         (maybe x)))

  Container
  (map [x f]
    (let [new-fld-path (map (.fld-path x) f)]
      (SetTo new-fld-path (f (.fld-c x)))))

  (map [x f embed]
    (for [new-fld-path (map (.fld-path x) f)
          new-c (f (.fld-c x))]
      (SetTo new-fld-path new-c))))

(deftype GetFrom [fld-path]
  (assert (instance? Vector fld-path))

  Stringable
  (string-list [_]
    (list "(c/GetFrom " (str fld-path) ")"))

  Eq
  (=* [x y]
    (and (instance? GetFrom y)
         (= fld-path (.fld-path y))
         (maybe x)))

  Container
  (map [x f]
    (GetFrom (map fld-path f)))

  (map [x f embed]
    (map fld-path GetFrom embed)))

(def StrConstraint (any-of StrBuffConstraint
                           SubStrConstraint))

(def SymbolConstraints (any-of SymbolConstraint
                               VectorConstraint
                               ListConstraint
                               StrConstraint
                               HashMapConstraint
                               MaybeConstraint
                               AgentConstraint
                               FutureConstraint
                               OpaqueConstraint
                               PromiseConstraint
                               FnConstraint
                               CollectionOf
                               SumConstraint
                               ReifiedConstraint
                               InnerTypeOfConstraint
                               TypeOfConstraint
                               FirstOf
                               LastOf
                               RestOf
                               ButLastOf
                               ParamConstraint
                               ComputedConstraint))

(def ValueConstraint (any-of SymbolConstraints
                             AllValues))

(def Constraints (any-of ValueConstraint
                         NoValues))

(def SeqConstraint (any-of VectorConstraint
                           ListConstraint))

(def TypeOps (any-of FirstOf
                     RestOf
                     LastOf
                     ButLastOf
                     VectFrom
                     ListFrom
                     CallValue
                     InnerTypeOfConstraint
                     SetTo
                     GetFrom
                     ArgOf))

(def top-type (AllValues empty-list ""))
(def bottom-type (NoValues []))
(def empty-fn-constraint (FnConstraint [] {} empty-list no-symbol ""))
(def substr-constraint (SubStrConstraint no-string empty-list no-symbol ""))
(def strbuff-constraint (StrBuffConstraint no-string empty-list no-symbol ""))
(def string-constraint (SumConstraint [strbuff-constraint substr-constraint]
                                      empty-list no-symbol ""))
(def not-container (ReifiedConstraint UnknownType (symbol "Can not contain other values")
                                      {} {} empty-fn-constraint
                                      empty-list no-symbol ""))
(def empty-reified (ReifiedConstraint 0 no-symbol {} {}
                                      empty-fn-constraint
                                      empty-list  no-symbol ""))

(defn IntegerConstraint [static-value max min path sym var]
  (ReifiedConstraint IntegerType 'Integer {}
                     {'static-value static-value 'max max 'min min}
                     empty-fn-constraint
                     path sym var))

(def coll-of-any (CollectionOf top-type empty-list no-symbol ""))
(def list-constraint (ListConstraint [] top-type empty-list no-symbol ""))
(def vect-constraint (VectorConstraint [] top-type empty-list no-symbol ""))
(def seq-constraint (SumConstraint [vect-constraint list-constraint]
                                     empty-list no-symbol ""))
(def fn-constraint (FnConstraint []
                                   {variadic (fn-arity no-symbol list-constraint top-type)
                                    0 (fn-arity no-symbol empty-list-constraint
                                                  top-type)
                                    1 (fn-arity no-symbol (ListConstraint (repeat 1 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)
                                    2 (fn-arity no-symbol (ListConstraint (repeat 2 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)
                                    3 (fn-arity no-symbol (ListConstraint (repeat 3 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)
                                    4 (fn-arity no-symbol (ListConstraint (repeat 4 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)
                                    5 (fn-arity no-symbol (ListConstraint (repeat 5 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)
                                    6 (fn-arity no-symbol (ListConstraint (repeat 6 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)
                                    7 (fn-arity no-symbol (ListConstraint (repeat 7 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)
                                    8 (fn-arity no-symbol (ListConstraint (repeat 8 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)
                                    9 (fn-arity no-symbol (ListConstraint (repeat 9 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)}
                                   empty-list no-symbol ""))
(def type-of-constraint (TypeOfConstraint no-symbol empty-list no-symbol ""))
(def sym-constraint (SymbolConstraint no-symbol empty-list no-symbol ""))
(def seq-or-str-constraint (SumConstraint [vect-constraint list-constraint strbuff-constraint substr-constraint]
                                            empty-list no-symbol ""))
(def hash-coll-constraint (HashMapConstraint HashCollisionNodeType {} top-type top-type empty-list no-symbol ""))
(def array-constraint (HashMapConstraint ArrayNodeType {} top-type top-type empty-list no-symbol ""))
(def bitmap-constraint (HashMapConstraint BitmapIndexedType {} top-type top-type empty-list no-symbol ""))
(def hashmap-constraint (SumConstraint [bitmap-constraint array-constraint hash-coll-constraint]
                                         empty-list no-symbol ""))
(def int-constraint (IntegerConstraint no-int int-max int-min empty-list no-symbol ""))
(def maybe-constraint  (MaybeConstraint top-type empty-list no-symbol ""))
(def set-constraint (ReifiedConstraint HashSetType 'HashSet
                                         {(Field (symbol ".set-map")) hashmap-constraint}
                                         {(Field (symbol ".set-map")) hashmap-constraint}
                                         (.arities fn-constraint {}) empty-list no-symbol ""))
(def agent-constraint (AgentConstraint top-type empty-list no-symbol ""))
(def promise-constraint (PromiseConstraint top-type empty-list no-symbol ""))
(def future-constraint (FutureConstraint empty-list no-symbol ""))
(def opaque-constraint (OpaqueConstraint empty-list no-symbol ""))
(def arity-constraint (ReifiedConstraint FnArityType 'FnArity {} {}
                                         (.arities fn-constraint {})
                                         empty-list no-symbol ""))


(defn sum-type [const-cs]
  (assert (instance? Vector const-cs))

  (either (or (flat-map (every const-cs (partial = bottom-type))
                        (fn [_]
                          (first const-cs)))
              (let [const-cs (remove const-cs (partial = bottom-type))]
                (or (and (= 1 (count const-cs))
                         (first const-cs))
                    (and (empty? const-cs)
                         (maybe top-type))
                    (some const-cs (partial = top-type))
                    (apply = const-cs)
                    (and (every const-cs (partial instance? CollectionOf))
                         (-> const-cs
                             (map .contents)
                             sum-type
                             (CollectionOf empty-list no-symbol "")
                             maybe))
                    (and (< 1 (count const-cs))
                         (maybe (SumConstraint const-cs empty-list no-symbol ""))))))
          top-type))

(defn missing-field [fld]
  (ReifiedConstraint UnknownType (symbol (str "Field/index '" fld "' required"))
                     {} {} empty-fn-constraint
                     empty-list no-symbol ""))

(defn cant-set-contents [x fld-path]
  (either (map (first fld-path)
               (fn [fld]
                 (NoValues [x (missing-field fld)])))
          (NoValues [x (ReifiedConstraint UnknownType (symbol "Unable to set contents")
                                          {} {} empty-fn-constraint
                                          empty-list no-symbol "")])))

(defprotocol Constraint
  (set-path [c new-path]
    (assert (instance? (list-of Vector) new-path))
    (assert-result r (instance? RecurseNext r))

    (RecurseWith c))

  (extract-sym [tc]
    (assert-result r (instance? (maybe-of Symbol) r))

    nothing)

  (update-sym [c new-sym]
    (assert (instance? Symbol new-sym))

    c)

  (add-to-path [constraint file-name line-number]
    constraint)

  (type-num [c]
    (assert-result r (instance? Integer r))

    UnknownType)

  (type-sym [c]
    (assert-result r (instance? OptionalSym r)))

  (assertion-path [x])

  (format-path [x n]
    (assert-result r (instance? (list-of String) r)))

  (show-full [c]
    (assert-result b (instance? (list-of String) b)))

  (set-to [x fld-path fld-c]
    (cond (empty? fld-path)
          fld-c

          (cant-set-contents x fld-path)))

  (get-from [x fld]
    (NoValues [x (missing-field fld)]))

  (contents-constraint [c]
    (NoValues [c not-container]))

  ;; replace any ParamConstraints for 'arity' with their corresponding values
  (reify-const [c arity args]
    (cata find-bottom c))

  ;; is the constraint a NoValues type, or contains one
  (find-bottom [c]
    c)
  
  ;; get a minimum number of items from a list or vector
  (get-items [c items-count]
    (assert-result r (instance? Vector r))

    [])

  ;; Ensure constraint is as small as possible
  (trim-const [c]
    c)

  ;; derive a new type by applying a type operation
  (derive-const [op]
    ;; TODO: perhaps this is a better impl
    ;; (fn [c]
    ;;   (intersect (map op (fn [f]
    ;;                        (f top-type)))
    ;;              c))

    ;; TODO: Make sure (fn [_] op) works as well
    (constantly op))

  ;; produces the type required by the type operation
  ;; (required [c op]
  ;;   (intersect c op))

  (intersect [c1 c2]
;; 'intersect' is commutative and associative
;; defined for almost everything
;; type ops may not be intersected with each other.
;; ComputedConstraint may not be intersected with itself
;; intersecting anything with a ComputedConstraint appends the constraint
;; intersecting anything with a ParamConstraint produces a ComputedConstraint with ParamConstraint first

    ;; 'top-type' is the undefined result
    top-type))

(defn format-path* [path desired-len]
  (assert (instance? List path))
  (assert (instance? Integer desired-len))

  (either (map (first path)
               (fn [[header]]
                 (let [path (-> (rest path)
                                (remove (fn [[file line]]
                                          (either (and (instance? Symbol file)
                                                       (maybe nothing))
                                                  (or (empty? file)
                                                      (= 0 line)))))
                                (map (fn [[file line]]
                                       (let [file (str file)]
                                         (str (either (-> file
                                                          str
                                                          (split-string (partial = "/"))
                                                          last
                                                          (map (fn [file]
                                                                 (either (and (flat-map (first file)
                                                                                        (partial = "/"))
                                                                              (maybe file))
                                                                         file))))
                                                      file)
                                              ": " line)))))
                       max-width (reduce path (count header)
                                         (fn [max s]
                                           (let [n (count s)]
                                             (either (> max n)
                                                     n))))
                       path (either (and (< (count path) desired-len)
                                         (maybe (comp path (repeat (- desired-len (count path))
                                                                   (spaces max-width)))))
                                    path)]
                   (map (cons header path)
                        (fn [x]
                          (str x (spaces (- max-width (count x)))))))))
          path))

(defn replace-path [c new-path]
  (apo (fn [c]
         (set-path c new-path))
       c))

(defn update-path
  ([c loc]
   (assert (instance? Location loc))
   (update-path c (.file loc) (.line loc)))

  ([c file-name line-number]
   (cata (fn [c]
           (add-to-path c file-name line-number))
         c)))

(defn trim [c]
  (cata trim-const c))

(defn derive [op c]
  ((cata derive-const op) c))

(extend-type ValueConstraint
  Constraint
  (add-to-path [c file line]
    (cond (or (= file "")
              (some (.path c) (partial = [file line])))
          c
          (.path c (cons [file line] (.path c))))))

(extend-type SymbolConstraints
  Constraint
  (set-path [c new-path]
    (RecurseFinal (.path c new-path)))

  (extract-sym [c]
    (instance? Symbol (.sym c)))

  (update-sym [c new-sym]
    (.sym c new-sym)))

(extend-type TypeOps
  Constraint
  (derive-const [op]
    (fn [c]
      (cond (= c top-type)
            (map op (fn [f]
                      (f top-type)))

            (trim (ComputedConstraint [c (map op (fn [f]
                                                   (f top-type)))]
                                      empty-list no-symbol ""))))))

(extend-type NoTail
  Constraint
  (assertion-path [_] empty-list)

  (format-path [_ n]
    (list "No Tail for sequence"))

  (show-full [c]
    (list "c/no-tail")))

(extend-type AllValues
  Constraint
  (format-path [x desired-len]
    (list "<Unknown Type>"))

  (show-full [c]
    (format-path c 0))

  (contents-constraint [c]
    c)

  (get-items [c items-count]
    (repeat items-count c))

  (intersect [_ y] y))

(extend-type NoValues
  Constraint
  (format-path [c n]
    (let [max-len (-> (trim c)
                      .constraints
                      (map (fn [c] (count (assertion-path c))))
                      (reduce n (fn [max-len path-len]
                                  (either (> max-len path-len)
                                          path-len)))
                      inc)]
      (-> (.constraints c)
          (map (fn [c]
                 (format-path c max-len)))
          (list-zipper empty-list)
          (map (fn [strs]
                 (str (to-str (interpose strs "    "))
                      "\n"))))))

  (show-full [c]
    (comp (list "Conflicting types")
          (map (.constraints c) (partial str "  "))))

  (contents-constraint [c]
    c)

  (reify-const [c arity args]
    c)

  (trim-const [c]
    (.constraints c (comp (remove (.constraints c) (partial instance? NoValues))
                          (-> (.constraints c)
                              (filter (partial instance? NoValues))
                              (flat-map .constraints)))))

  (intersect [x _] x))

(extend-type SymbolConstraint
  Constraint
  (type-num [c] SymbolType)

  (type-sym [_] 'Symbol)

  (assertion-path [c] (.path c))

  (show-full [c]
    (format-path c 0))

  (format-path [x desired-len]
    (format-path* (cons [(str "Symbol " (either (= no-symbol (.static-value x))
                                                (str "'" (.static-value x)))
                              " from:") ""]
                        (.path x))
                  desired-len))

  (derive-const [op]
    (fn [c]
      (intersect op c)))

  (intersect [x y]
    (cond (or (instance? ParamConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? ComputedConstraint y)
              (instance? InnerTypeOfConstraint y)
              (instance? SumConstraint y))
          (intersect y x)

          (instance? SymbolConstraint y)
          (either (map (or (= (.static-value x) (.static-value y))
                           (and (= (.static-value x) no-symbol)
                                (maybe (.static-value y)))
                           (and (= (.static-value y) no-symbol)
                                (maybe (.static-value x))))
                       (partial .static-value x))
                  (NoValues [x y]))

          (NoValues [x y]))))

(defn str-inner [sc]
  (assert (instance? StrConstraint sc))

  (cond (= (.static-value sc) no-string)
        string-constraint

        (-> (.static-value sc)
            vec
            (map (fn [c]
                   (StrBuffConstraint c empty-list no-symbol "")))
            sum-type)))

(extend-type StrConstraint
  Constraint
  (type-sym [_] 'String)

  (assertion-path [c] (.path c))

  (show-full [c]
    (format-path c 0))

  (format-path [x desired-len]
    (format-path* (cons [(str "String " (either (= no-string (.static-value x))
                                                (str "'" (.static-value x) "'"))
                              " from:") ""]
                        (.path x))
                  desired-len))

  (contents-constraint [c]
    (.static-value c no-string))

  (derive-const [op]
    (fn [c]
      (intersect op c)))

  (intersect [x y]
    (cond (or (instance? ParamConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? ComputedConstraint y)
              (instance? InnerTypeOfConstraint y)
              (instance? SumConstraint y))
          (intersect y x)

          (and (instance? StrConstraint y)
               (= (get-type x) (get-type y)))
          (either (map (or (= (.static-value x) (.static-value y))
                           (and (= (.static-value x) no-string)
                                (maybe (.static-value y)))
                           (and (= (.static-value y) no-string)
                                (maybe (.static-value x))))
                       (fn [stat-val]
                         (cond (instance? StrBuffConstraint y)
                               (.static-value y stat-val)

                               (.static-value x stat-val))))
            (NoValues [x y]))

          (instance? CollectionOf y)
          (cond (= (intersect (str-inner x) (.contents y)) bottom-type)
                (NoValues [x y])

                x)

          (NoValues [x y]))))

(extend-type StrBuffConstraint
  Constraint
   (type-num [c] StringBufferType))

(extend-type SubStrConstraint
  Constraint
   (type-num [c] SubStringType))

(extend-type MaybeConstraint
  Constraint
  (type-num [c] MaybeType)

  (type-sym [_] 'Maybe)

  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons ["Maybe from:" ""] (.path x))
                  desired-len))

  (show-full [c]
    (comp (format-path c 0)
          (cond (= (show-full bottom-type) (.contents c))
                ""
                (comp ["--contains--"]
                      (map (.contents c) (partial str "  "))))))

  (contents-constraint [c]
    (.contents c))

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [f]
                           (f top-type)))
                 c)))

  (find-bottom [c]
    (either (= bottom-type (.contents c))
            c))

  (intersect [x y]
    (cond (or (instance? ParamConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? ComputedConstraint y)
              (instance? InnerTypeOfConstraint y)
              (instance? SumConstraint y))
          (intersect y x)

          (or (instance? MaybeConstraint y)
              (instance? CollectionOf y))
          (let [contents (intersect (.contents x) (.contents y))]
            (either (= bottom-type contents)
                    (.contents x contents)))

          (NoValues [x y]))))

(defn intersect-seqs [l1 l2]
  (assert (instance? SeqConstraint l1))
  (assert (instance? SeqConstraint l2))

  (let [l1 (trim l1)
        l1-tail (.tail-c l1)
        l2 (trim l2)
        l2-tail (.tail-c l2)
        cnt-ic (count (.items l2))
        cnt-c (count (.items l1))
        max-cnt (either (> cnt-ic cnt-c)
                        cnt-c)
        items (map (zip-lists (get-items l2 max-cnt)
                              (get-items l1 max-cnt))
                   (fn [[c1 c2]]
                     (intersect c1 c2)))
        new-tail (either (or (= no-tail l1-tail)
                             (= no-tail l2-tail))
                         (intersect l2-tail l1-tail))
        new-ic (-> l2
                   (.tail-c new-tail)
                   (.items (vec items)))]
    (either (map (or (some items (partial = bottom-type))
                     (= bottom-type new-tail))
                 (fn [failure]
                   (cond (empty? (.constraints failure))
                         (NoValues [l1 l2])

                         failure)))
            (cond (< (count items) max-cnt)
                  (NoValues [l1 l2])

                  new-ic))))

(extend-type ListConstraint
  Constraint
  (type-num [c] ListType)

  (type-sym [_] 'List)

  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons ["List from:" ""] (.path x))
                  desired-len))

  (show-full [c]
    (comp (format-path c 0)
          ["--items--"]
          (-> (.items c)
              (interpose ["----"])
              (flat-map (fn [item-strs]
                          (map item-strs (partial str "  ")))))
          (cond (= (show-full bottom-type) (.tail-c c))
                []
                (comp ["--tail--"]
                      (map (.tail-c c) (partial str "  "))))
          ["===="]))

  (set-to [x fld-path fld-c]
    (-> (cond (empty? fld-path)
              fld-c

              (either (for [idx (first fld-path)
                            :when (and (instance? ReifiedConstraint idx)
                                       (= IntegerType (.type-number idx)))
                            idx (get-in idx [.fields 'static-value])
                            :when-not (= idx no-int)
                            :let [items-count (inc idx)
                                  old-items (cond (<= items-count (count (.items x)))
                                                  (.items x)

                                                  (get-items x items-count))]
                            old-item (nth old-items idx)
                            new-items (store old-items idx
                                             (set-to old-item (rest fld-path) fld-c))]
                        (.items x new-items))
                      (cant-set-contents x fld-path)))
        find-bottom))

  (get-from [x idx]
    (either (for [_ (and (instance? ReifiedConstraint idx)
                         (= IntegerType (.type-number idx)))
                  idx (get-in idx [.fields 'static-value])
                  :when-not (= idx no-int)
                  item (nth (get-items x (inc idx)) idx)]
              item)
            (NoValues [x (missing-field idx)])))

  (contents-constraint [c]
    (cond (and (empty? (.items c))
               (= no-tail (.tail-c c)))
          top-type

          (-> (.items c)
              (conj (either (map (= no-tail (.tail-c c)) (fn [_]
                                                           top-type))
                            (.tail-c c)))
              (remove (partial = top-type))
              sum-type)))

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [contents]
                           (contents top-type)))
                 c)))

  (find-bottom [c]
    (either (or (some (.items c) (partial = bottom-type))
                (= bottom-type (.tail-c c)))
            c))

  (get-items [c items-count]
    (let [fixed (take (.items c) items-count)
          fixed-count (count fixed)]
      (cond (= fixed-count items-count)
            fixed

            (= no-tail (.tail-c c))
            []

            (comp fixed
                  (get-items (.tail-c c) (- items-count fixed-count))))))

  (trim-const [lc]
    (either (map (instance? SeqConstraint (.tail-c lc))
                 (fn [tail-c]
                   (-> lc
                       (.items (comp (.items lc) (.items tail-c)))
                       (.tail-c (.tail-c tail-c)))))
            lc))

  (intersect [x y]
    (cond (or (instance? ParamConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? ComputedConstraint y)
              (instance? SumConstraint y)
              (instance? FirstOf y)
              (instance? LastOf y)
              (instance? RestOf y)
              (instance? ButLastOf y)
              (instance? InnerTypeOfConstraint y)
              (instance? GetFrom y)
              (instance? SetTo y)
              (instance? ListFrom y)
              (instance? VectFrom y))
          (intersect y x)

          (instance? ListConstraint y)
          (intersect-seqs x y)

          (instance? CollectionOf y)
          (intersect-seqs x (.tail-c empty-list-constraint y))

          (NoValues [x y]))))

(extend-type VectorConstraint
  Constraint
  (type-num [c] VectorType)

  (type-sym [_] 'Vector)

  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons ["Vector from:" ""] (.path x))
                  desired-len))

  (show-full [c]
    (comp (format-path c 0)
          ["--items--"]
          (-> (.items c)
              (interpose ["----"])
              (flat-map (fn [item-strs]
                          (map item-strs (partial str "  ")))))
          (cond (= (show-full bottom-type) (.tail-c c))
                []
                (comp ["--tail--"]
                      (map (.tail-c c) (partial str "  "))))
          ["===="]))

  (set-to [x fld-path fld-c]
    (-> (cond (empty? fld-path)
              fld-c

              (either (for [idx (first fld-path)
                            :when (and (instance? ReifiedConstraint idx)
                                       (= IntegerType (.type-number idx)))
                            idx (get-in idx [.fields 'static-value])
                            :when-not (= idx no-int)
                            :let [items-count (inc idx)
                                  old-items (cond (<= items-count (count (.items x)))
                                                  (.items x)

                                                  (get-items x items-count))]
                            old-item (nth old-items idx)
                            new-items (store old-items idx
                                             (set-to old-item (rest fld-path) fld-c))]
                        (.items x new-items))
                      (cant-set-contents x fld-path)))
        find-bottom))

  (get-from [x idx]
    (either (for [_ (and (instance? ReifiedConstraint idx)
                         (= IntegerType (.type-number idx)))
                  idx (get-in idx [.fields 'static-value])
                  :when-not (= idx no-int)
                  item (nth (get-items x (inc idx)) idx)]
              item)
            (NoValues [x (missing-field idx)])))

  (contents-constraint [c]
    (cond (and (empty? (.items c))
               (= no-tail (.tail-c c)))
          top-type

          (-> (.items c)
              (conj (either (map (= no-tail (.tail-c c)) (fn [_]
                                                           top-type))
                            (.tail-c c)))
              (remove (partial = top-type))
              sum-type)))

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [contents]
                           (contents top-type)))
                 c)))

  (find-bottom [c]
    (either (or (some (.items c) (partial = bottom-type))
                (= bottom-type (.tail-c c)))
            c))

  (get-items [c items-count]
    (let [fixed (take (.items c) items-count)
          fixed-count (count fixed)]
      (cond (= fixed-count items-count)
            fixed

            (= no-tail (.tail-c c))
            []

            (comp fixed
                  (get-items (.tail-c c) (- items-count fixed-count))))))

  (trim-const [vc]
    (either (map (instance? SeqConstraint (.tail-c vc))
                 (fn [tail-c]
                   (-> vc
                       (.items (comp (.items vc) (.items tail-c)))
                       (.tail-c (.tail-c tail-c)))))
            vc))

  (intersect [x y]
    (cond (or (instance? ParamConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? ComputedConstraint y)
              (instance? SumConstraint y)
              (instance? FirstOf y)
              (instance? LastOf y)
              (instance? RestOf y)
              (instance? ButLastOf y)
              (instance? InnerTypeOfConstraint y)
              (instance? GetFrom y)
              (instance? SetTo y)
              (instance? ListFrom y)
              (instance? VectFrom y))
          (intersect y x)

          (instance? VectorConstraint y)
          (intersect-seqs x y)

          (instance? CollectionOf y)
          (intersect-seqs x (.tail-c empty-list-constraint y))

          (NoValues [x y]))))

(extend-type SumConstraint
  Constraint
  (type-num [c]
    (either (apply = (map (.alts c) type-num))
            UnknownType))

  (assertion-path [c] (.path c))

  (format-path [c n]
    (let [sum-sym (either (apply = (map (.alts c) type-sym))
                          "Sum Type")]
      (format-path* (cons [(str sum-sym " from") ""] (.path c))
                    n)))

  (show-full [c]
    (comp (format-path c 0)
          (-> (.alts c)
              (interpose ["----"])
              (flat-map (fn [alt-strs]
                          (map alt-strs (partial str "  ")))))))

  (contents-constraint [c]
    c)

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [contents]
                           (contents top-type)))
                 c)))

  (find-bottom [c]
    (either (flat-map (every (.alts c) (partial = bottom-type))
                      first)
            (.alts c (remove (.alts c) (partial = bottom-type)))))

  (get-items [c items-count]
    (let [alts-items (-> (.alts c)
                         (map (fn [alt]
                                (get-items alt items-count)))
                         (filter (fn [alt]
                                   (= items-count (count alt)))))]
      (either (empty? alts-items)
              (-> (apply zip-lists alts-items)
                  (map (fn [alts]
                         (sum-type (vec alts))))
                  vec))))

  (trim-const [c]
    (let [all-alts (flat-map (.alts c) (fn [c]
                                         (either (map (instance? SumConstraint c) .alts)
                                                 [c])))
          trimmed (-> (sum-type all-alts)
                      (.sym (.sym c)))]
      (either (map (instance? SumConstraint trimmed)
                   (fn [_]
                     (.path trimmed (.path c))))
              trimmed)))

  (intersect [x y]
    (cond (= top-type y)
          x

          (= bottom-type y)
          y

          (or (instance? ComputedConstraint y)
              (instance? ParamConstraint y))
          (intersect y x)

          (instance? SumConstraint y)
          (let [new-alts (for [a1 (.alts x)
                               a2 (.alts y)
                               :let [new-alt (intersect a1 a2)]
                               :when-not (= bottom-type new-alt)]
                           new-alt)
                new-alts (reduce new-alts [] (fn [new-alts alt]
                                               (either (and (some new-alts (partial =* alt))
                                                            (maybe new-alts))
                                                       (conj new-alts alt))))]
            (either (or (and (empty? new-alts)
                             (maybe (NoValues [x y])))
                        (and (= 1 (count new-alts))
                             (first new-alts)))
                    (.alts x new-alts)))

          (let [inters (map (.alts x) (partial intersect y))
                goods (-> inters
                          (remove (partial instance? NoValues))
                          (reduce [] (fn [goods y]
                                       (either (and (some goods (partial = y))
                                                    (maybe goods))
                                               (conj goods y)))))]
            (either (or (and (empty? goods)
                             (or (apply = inters)
                                 (maybe (NoValues [y x]))))
                        (and (= (count goods) 1)
                             (first goods)))
                    (.alts x goods))))))

(extend-type CollectionOf
  Constraint
  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (cons ["Contents from" ""] (.path c))
                  desired-len))

  (show-full [c]
    (comp (format-path c 0)
          (map (.contents c) (partial str "  "))))

  (contents-constraint [c]
    (.contents c))

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [contents]
                           (contents top-type)))
                 c)))

  (find-bottom [c]
    (either (= bottom-type (.contents c))
            c))

  (get-items [c items-count]
    (repeat items-count (.contents c)))

  (intersect [x y]
    (cond (instance? CollectionOf y)
          (let [new-cs (intersect (.contents y) (.contents x))]
            (either (or (= new-cs bottom-type)
                        (= x y))
                    (.contents y new-cs)))

          (intersect y x))))

(extend-type ComputedConstraint
  Constraint
  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (cons ["Type computed by" ""] (.path c))
                  desired-len))

  (show-full [c]
    (comp (format-path c 0)
          (-> (.mods c) 
              (interpose (list "---"))
              (flat-map (fn [mod-strs]
                          (map mod-strs (partial str "  ")))))))

  (contents-constraint [c]
    (intersect c inner-type-of-constraint))

  (reify-const [c arity args]
    (let [[mod & mods] (.mods c)]
      (reduce mods mod intersect)))

  (type-num [c]
    (let [new-c (derive c top-type)]
      (cond (instance? ComputedConstraint new-c)
            UnknownType

            (type-num new-c))))

  (derive-const [op]
    (fn [c]
      (reduce (.mods op) c
              (fn [c op-fn]
                (op-fn c)))))

  (find-bottom [c]
    (either (= bottom-type (derive c top-type))
            c))

  (get-items [c items-count]
    (get-items (derive c top-type) items-count))

  (trim-const [c]
    (.mods c (reduce (.mods c) []
                     (fn [new-mods mod]
                       (cond (instance? ComputedConstraint mod)
                             (comp new-mods (.mods mod))
                             (conj new-mods mod))))))

  (intersect [x y]
    (cond (=* x y)
          x

          (or (instance? AllValues y)
              (instance? NoValues y))
          (intersect y x)

          (instance? ComputedConstraint y)
          (cond (or (some (.mods x) (partial instance? TypeOps))
                    (some (.mods y) (partial instance? TypeOps)))
                (do
                  (print-err "Dropping ComputedConstraint" _FILE_ _LINE_
                             "\n\n" 'x x
                             "\n\n" 'y y)
                  top-type)

                (.mods x (comp (.mods x) (.mods y))))

          (or (instance? FirstOf y)
              (instance? LastOf y))
          (.mods x (comp (.mods x) [y (MaybeConstraint top-type empty-list no-symbol "")]))

          (.mods x (conj (.mods x) y)))))

(extend-type ParamConstraint
  Constraint
  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (cons [(str "Parameter " (.param-index c) " from") ""] (.path c))
                  desired-len))

  (show-full [c]
    (format-path c 0))

  (contents-constraint [c]
    (intersect c inner-type-of-constraint))

  (reify-const [c arity args]
    (cond (= (.arity c) arity)
          (either (get args (.param-index c))
                  top-type)

          c))

  (derive-const [op]
    (fn [c]
      c))

  (intersect [x y]
    (cond (=* x y)
          x

          (or (instance? AllValues y)
              (instance? NoValues y)
              (instance? ComputedConstraint y))
          (intersect y x)

          (or (instance? FirstOf y)
              (instance? LastOf y))
          (ComputedConstraint [x y (MaybeConstraint top-type empty-list no-symbol "")]
                              (.path x) (.sym x) (.var x))

          (ComputedConstraint [x y] (.path x) (.sym x) (.var x)))))

(extend-type OpaqueConstraint
  Constraint
  (type-num [c] OpaqueType)

  (type-sym [_] 'Opaque)

  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons ["Opaque pointer from:" ""] (.path x))
                  desired-len))

  (show-full [c]
    (format-path c 0))

  (derive-const [op]
    (fn [c]
      (intersect op c)))

  (intersect [x y]
    (cond (=* x y)
          x

          (or (instance? ComputedConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? InnerTypeOfConstraint y)
              (instance? ParamConstraint y))
          (intersect y x)

          (NoValues [x y]))))

(extend-type AgentConstraint
  Constraint
  (type-num [c] AgentType)

  (type-sym [_] 'Agent)

  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons ["Agent from:" ""] (.path x))
                  desired-len))

  (show-full [c]
    (comp (format-path c 0)
          (map (.contents c) (partial str "  "))))

  (contents-constraint [c]
    (.contents c))

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [contents]
                           (contents top-type)))
                 c)))

  (find-bottom [c]
    (either (= bottom-type (.contents c))
            c))

  (intersect [x y]
    (cond (or (instance? ParamConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? ComputedConstraint y)
              (instance? InnerTypeOfConstraint y)
              (instance? SumConstraint y))
          (intersect y x)

          (instance? AgentConstraint y)
          (let [contents (intersect (.contents x) (.contents y))]
            (either (= bottom-type contents)
                    (.contents x contents)))

          (NoValues [x y]))))

(extend-type FutureConstraint
  Constraint
  (type-num [c] FutureType)

  (type-sym [_] 'Future)

  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons ["Future from:" ""] (.path x))
                  desired-len))

  (show-full [c]
    (format-path c 0))

  (derive-const [op]
    (fn [c]
      (intersect op c)))

  (intersect [x y]
    (cond (=* x y)
          x

          (or (instance? ParamConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? ComputedConstraint y)
              (instance? InnerTypeOfConstraint y)
              (instance? SumConstraint y))
          (intersect y x)

          (NoValues [x y]))))

(extend-type PromiseConstraint
  Constraint
  (type-num [c] PromiseType)

  (type-sym [_] 'Promise)

  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons ["Promise from:" ""] (.path x))
                  desired-len))

  (show-full [c]
    (comp (format-path c 0)
          (map (.contents c) (partial str "  "))))

  (contents-constraint [c]
    (.contents c))

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [contents]
                           (contents top-type)))
                 c)))

  (find-bottom [c]
    (either (= bottom-type (.contents c))
            c))

  (intersect [x y]
    (cond (=* x y)
          x

          (or (instance? ParamConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? ComputedConstraint y)
              (instance? InnerTypeOfConstraint y)
              (instance? SumConstraint y))
          (intersect y x)

          (or (instance? CollectionOf y)
              (instance? PromiseConstraint y))
          (let [contents (intersect (.contents x) (.contents y))]
            (either (= bottom-type contents)
                    (.contents x contents)))

          (NoValues [x y]))))

(extend-type fn-arity
  Constraint
  (show-full [c]
    (comp (list (str "arity: " (.arity-id c))
                "--parameters--")
          (->  (.param-consts c)
               (.items)
               (interpose ["----"])
               (flat-map (fn [item-strs]
                           (map item-strs (partial str "  ")))))
          (let [tail-c (.tail-c (.param-consts c))]
            (cond (first tail-c)
                  (comp ["--variadic params--"]
                        (map tail-c (partial str "  ")))
                  []))
          ["--result--"]
          (map (.result-const c) (partial str "  "))))

  (derive-const [op]
    (fn [c]
      (map op (fn [contents]
                (contents top-type)))))

  (find-bottom [c]
    (either (or (-> (.param-consts c)
                    .items
                    (some (partial = bottom-type)))
                (-> (.param-consts c)
                    .tail-c
                    (= bottom-type))
                (= bottom-type (.result-const c)))
            c))

  (intersect [ar1 ar2]
    (assert (instance? fn-arity ar2))

    (let [param-cs (intersect (.param-consts ar1) (.param-consts ar2))
          result-c (intersect (.result-const ar1) (.result-const ar2))
          arity-id (cond (= no-symbol (.arity-id ar1))
                         (.arity-id ar2)

                         (.arity-id ar1))]
      (either (or (= bottom-type (cata find-bottom param-cs))
                  (= bottom-type (cata find-bottom result-c)))

              (-> ar1
                  (.arity-id arity-id)
                  (.param-consts param-cs)
                  (.result-const result-c))))))

(defn intersect-fns [y x]
  (either (or (=* x y)
              (and (empty? (.arities x))
                   (maybe y))
              (and (empty? (.arities y))
                   (maybe x)))
          (let [new-required (reduce (.required-arities x) (.required-arities y)
                                     (fn [new-reqd arity-rank]
                                       (cond (some new-reqd (partial = arity-rank))
                                             new-reqd

                                             (conj new-reqd arity-rank))))
                maybe-variadic-x (get-in x [.arities variadic])
                maybe-variadic-y (get-in y [.arities variadic])
                new-arities (reduce (vec (.arities y)) {}
                                    (fn [arities [idx y-arity]]
                                      (either (for [_ (instance? Integer idx)
                                                    x-arity (or (get-in x [.arities idx])
                                                                maybe-variadic-x)]
                                                (assoc arities idx (intersect x-arity y-arity)))
                                              arities)))
                new-arities (reduce (vec (.arities x)) new-arities
                                    (fn [arities [idx x-arity]]
                                      (cond (get arities idx)
                                            arities

                                            (either (for [_ (instance? Integer idx)
                                                          y-arity (or (get-in y [.arities idx])
                                                                      maybe-variadic-y)]
                                                      (assoc arities idx (intersect x-arity y-arity)))
                                                    arities))))
                new-arities (either (for [variadic-x maybe-variadic-x
                                          variadic-y maybe-variadic-y]
                                      (assoc new-arities variadic (intersect variadic-x variadic-y)))
                                    new-arities)
                new-arities (reduce (vec new-arities) {}
                                    (fn [new-arities [k v]]
                                      (cond (= bottom-type v)
                                            new-arities

                                            (assoc new-arities k v))))]
            (cond (empty? new-arities)
                  (NoValues [x y])

                  (every new-required (partial get new-arities))
                  (-> x
                      (.required-arities new-required)
                      (.arities new-arities))

                  (NoValues [x y])))))

(extend-type FnConstraint
  Constraint
  (type-num [c] FunctionType)

  (type-sym [_] 'Fn)

  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons ["Function from" ""] (.path x))
                  desired-len))

  (show-full [c]
    (comp (format-path c 0)
          ["---------"]
          (-> (.arities c)
              vals
              (interpose ["----"])
              flatten
              (map (partial str "  ")))))

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [contents]
                           (contents top-type)))
                 c)))

  (find-bottom [c]
    (either (some (vals (.arities c)) (partial = bottom-type))
            c))

  (intersect [x y]
    (cond (=* x y)
          x

          (or (instance? ParamConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? ComputedConstraint y)
              (instance? SumConstraint y)
              (instance? ReifiedConstraint y)
              (instance? ArgOf y)
              (instance? InnerTypeOfConstraint y)
              (instance? CallValue y))
          (intersect y x)

          (instance? CollectionOf y)
          (let [new-result (.contents y)]
            (cata find-bottom
                  (map x (fn [arity]
                         (.result-const arity (intersect new-result (.result-const arity)))))))

          (instance? FnConstraint y)
          (intersect-fns x y)

          (NoValues [x y]))))

(defn intersect-int [x y]
  (either (for [min-x (get-in x [.fields 'min])
                max-x (get-in x [.fields 'max])
                static-x (get-in x [.fields 'static-value])
                min-y (get-in y [.fields 'min])
                max-y (get-in y [.fields 'max])
                static-y (get-in y [.fields 'static-value])
                :let [new-min (either (> min-x min-y)
                                      min-y)
                      new-max (either (< max-x max-y)
                                      max-y)]
                new-static (or (= static-x static-y)
                               (flat-map (or (= static-x static-y)
                                             (and (= static-x no-int)
                                                  (maybe static-y))
                                             (and (= static-y no-int)
                                                  (maybe static-x)))
                                         (fn [new-static]
                                           (and (<= new-min new-static new-max)
                                                (maybe new-static)))))]
            ;; TODO: use the path from the most restrictive constraint
            ;; determined by satisfied-by
            (.fields x {'min new-min 'max new-max 'static-value new-static}))
          (NoValues [x y])))

(def intersectors {IntegerType intersect-int})

(defn intersect-reified [x y]
  (either (map (get intersectors (type-num x))
               (fn [f]
                 (f x y)))

          (cata find-bottom (.fields x (merge-with intersect (.fields y) (.fields x))))))

(extend-type ReifiedConstraint
  Constraint
  (type-sym [c]
    (.type-symbol c))

  (type-num [c]
    (.type-number c))

  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (cons [(str "'" (type-sym c) "' from") ""]
                        (.path c))
                  desired-len))

  (show-full [c]
    (cons (str "Type: " (type-sym c))
          (show-full (.invoke-fn c))))

  (set-to [x fld-path fld-c]
    (-> (cond (empty? fld-path)
              fld-c

              (either (for [fld (first fld-path)
                            field-check (get (.field-consts x) fld)
                            curr-field (get (.fields x) fld)
                            :let [new-field (set-to curr-field (rest fld-path) fld-c)
                                  final-field (intersect field-check new-field)]
                            final-field (or (= bottom-type final-field)
                                            (= final-field new-field))]
                        (.fields x (assoc (.fields x) fld final-field)))
                      (cant-set-contents x fld-path)))
        find-bottom))

  (get-from [c fld-c]
    (either (or (get (.fields c) fld-c)
                (get (.field-consts c) fld-c))
            (NoValues [c (missing-field fld-c)])))

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [contents]
                           (contents top-type)))
                 c)))

  (find-bottom [c]
    (either (or (some (seq (.fields c)) (fn [[fld-c val-c]]
                                          (or (= bottom-type fld-c)
                                              (= bottom-type val-c))))
                (= bottom-type (.invoke-fn c)))
            c))

  (intersect [x y]
    (cond (=* x y)
          x

          (or (instance? ParamConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? ComputedConstraint y)
              (instance? SumConstraint y)
              (instance? ArgOf y)
              (instance? InnerTypeOfConstraint y)
              (instance? GetFrom y)
              (instance? SetTo y)
              (instance? CallValue y))
          (intersect y x)

          (instance? FnConstraint y)
          (let [new-invoke (intersect-fns (.invoke-fn x) y)]
            (either (= bottom-type new-invoke)
                    (.invoke-fn x new-invoke)))

          (and (instance? ReifiedConstraint y)
               (= (type-num x) (type-num y)))
          (intersect-reified x y)

          (NoValues [x y]))))

(extend-type ArgOf
  Constraint
  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (cons [(str "Argument " (.arg-position c) " of") ""] (.path c))
                  desired-len))

  (show-full [c]
    (comp (format-path* (cons [(str "Argument " (.arg-position c) " of") ""] (.path c))
                        0)
          ["===="]))

  (derive-const [op]
    (fn [c]
      (intersect op c)))

  (intersect [x y]
    (cond (=* x y)
          x

          (or (instance? ParamConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? ComputedConstraint y)
              (instance? InnerTypeOfConstraint y)
              (instance? SumConstraint y))
          (intersect y x)

          (instance? FnConstraint y)
          (let [arg-pos (.arg-position x)
                num-args (inc arg-pos)
                arity-args (-> (.arities y)
                               vals
                               (reduce [] (fn [arities arity]
                                            (assert (instance? fn-arity arity))
                                            (either (map (-> (.param-consts arity)
                                                             (get-items num-args)
                                                             (nth arg-pos))
                                                         (partial conj arities))
                                                    arities))))]
            (cond (empty? arity-args)
                  (NoValues [x y])

                  (sum-type arity-args)))

          (instance? ReifiedConstraint y)
          (intersect (.arg-position x (inc (.arg-position x)))
                     (.invoke-fn y))

          (NoValues [x y]))))

(extend-type FirstOf
  Constraint
  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons [(str "First value of seq:") ""] (.path x))
                  desired-len))

  (show-full [c]
    (format-path c 0))

  (derive-const [op]
    (fn [c]
      (intersect op c)))

  (intersect [x y]
    (cond (=* x y)
          x

          (instance? SeqConstraint y)
          (MaybeConstraint (either (first (get-items y 1))
                                   top-type)
                           empty-list no-symbol "")

          (or (instance? SumConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? InnerTypeOfConstraint y)
              (instance? ComputedConstraint y)
              (instance? ParamConstraint y))
          (intersect y x)
     
          (NoValues [x y]))))

(extend-type LastOf
  Constraint
  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons [(str "Last value of seq:") ""] (.path x))
                  desired-len))

  (show-full [c]
    (format-path c 0))

  (derive-const [op]
    (fn [c]
      (intersect op c)))

  (intersect [x y]
    (cond (=* x y)
          x

          (instance? SeqConstraint y)
          (let [y (trim y)]
            (MaybeConstraint (either (and (= no-tail (.tail-c y))
                                          (last (.items y)))

                                     (either (first (get-items (.tail-c y) 1))
                                             top-type))
                             empty-list no-symbol ""))

          (or (instance? SumConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? InnerTypeOfConstraint y)
              (instance? ComputedConstraint y)
              (instance? ParamConstraint y))
          (intersect y x)

          (NoValues [x y]))))

(extend-type RestOf
  Constraint
  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons [(str "Rest of seq:") ""] (.path x))
                  desired-len))

  (show-full [c]
    (format-path c 0))

  (derive-const [op]
    (fn [c]
      (intersect op c)))

  (intersect [x y]
    (cond (=* x y)
          x

          (instance? SeqConstraint y)
          (let [y (trim y)]
            (.items y (rest (.items y))))

          (or (instance? SumConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? InnerTypeOfConstraint y)
              (instance? ComputedConstraint y)
              (instance? ParamConstraint y))
          (intersect y x)
     
          (NoValues [x y]))))

(extend-type ButLastOf
  Constraint
  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons [(str "All but the last value of seq:") ""] (.path x))
                  desired-len))

  (show-full [c]
    (format-path c 0))

  (derive-const [op]
    (fn [c]
      (intersect op c)))

  (intersect [x y]
    (cond (=* x y)
          x

          (instance? SeqConstraint y)
          (let [y (trim y)]
            (cond (= (.tail-c y) no-tail)
                  (.items y (butlast (.items y)))

                  y))

          (or (instance? SumConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? InnerTypeOfConstraint y)
              (instance? ComputedConstraint y)
              (instance? ParamConstraint y))
          (intersect y x)

          (NoValues [x y]))))

(extend-type ListFrom
  Constraint
  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons [(str "List from value") ""] (.path x))
                  desired-len))

  (show-full [c]
    (format-path c 0))

  (derive-const [op]
    (fn [c]
      (intersect op c)))

  (intersect [x y]
    (cond (=* x y)
          x

          (instance? ListConstraint y)
          y

          (instance? VectorConstraint y)
          (let [y (trim y)]
            (-> empty-list-constraint
                (.items (.items y))
                (.tail-c (.tail-c y))
                (.path (comp (.path y) (.path x)))))

          (or (instance? SumConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? InnerTypeOfConstraint y)
              (instance? ComputedConstraint y)
              (instance? ParamConstraint y))
          (intersect y x)

          (NoValues [x y]))))

(extend-type VectFrom
  Constraint
  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons [(str "Vector from value") ""] (.path x))
                  desired-len))

  (show-full [c]
    (format-path c 0))

  (derive-const [op]
    (fn [c]
      (intersect op c)))

  (intersect [x y]
    (cond (=* x y)
          x

          (instance? VectorConstraint y)
          y

          (instance? ListConstraint y)
          (let [y (trim y)]
            (-> empty-vect-constraint
                (.items (.items y))
                (.tail-c (.tail-c y))
                (.path (comp (.path y) (.path x)))))

          (or (instance? SumConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? InnerTypeOfConstraint y)
              (instance? ComputedConstraint y)
              (instance? ParamConstraint y))
          (intersect y x)

          (NoValues [x y]))))

(extend-type CallValue
  Constraint
  (set-path [c new-path]
    (RecurseFinal (.path c new-path)))

  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (cons ["Called at " ""] (.path c))
                  desired-len))

  (show-full [c]
    (comp (format-path* (cons ["Called with args at" ""] (.path c))
                        0)
          ["--args--"]
          (flat-map (.args c) (fn [arg-strs]
                                (map arg-strs (partial str "  "))))
          ["===="]))

  (intersect [x y]
    (cond (=* x y)
          x

          (or (instance? ParamConstraint y)
              (instance? ComputedConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? InnerTypeOfConstraint y)
              (instance? SumConstraint y))
          (intersect y x)

          (instance? FnConstraint y)
          (let [args (.args x)]
            (either (or (map (instance? NoArgs args)
                             (fn [_]
                               (-> (.arities y)
                                   vals
                                   (reduce [] (fn [arities arity]
                                                (assert (instance? fn-arity arity))
                                                (conj arities (.result-const arity))))
                                   sum-type)))
                        (map (or (get-in y [.arities (count args)])
                                 (get-in y [.arities variadic]))
                             (fn [arity]
                               ;; TODO: make sure all param constraints are satisfied by the arg constraints
                               (let [new-args (intersect (.items empty-list-constraint args)
                                                         (.param-consts arity))
                                     reified (cond (= bottom-type new-args)
                                                   new-args

                                                   (let [new-args (get-items new-args (count args))
                                                         new-args (cata (fn [c]
                                                                          (reify-const c (.arity-id arity)
                                                                                       (repeat (count new-args)
                                                                                               top-type)))
                                                                        new-args)]
                                                     (cata (fn [c]
                                                             (reify-const c (.arity-id arity)
                                                                          new-args))
                                                           arity)))
                                     reified (cata find-bottom reified)]
                                 (either (= bottom-type reified)
                                         (.result-const reified))))))

                    (NoValues [x y])))

          (instance? ReifiedConstraint y)
          (cond (instance? NoArgs (.args x))
                (intersect x (.invoke-fn y)) 

                (intersect (.args x (comp [y] (.args x)))
                           (.invoke-fn y)))

          (NoValues [x y]))))

(extend-type InnerTypeOfConstraint
  Constraint
  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (cons ["Inner type of value from" ""] (.path c))
                  desired-len))

  (show-full [c]
    (format-path c 0))

  (intersect [x y]
    (cond (=* x y)
          x

          (or (instance? AllValues y)
              (instance? NoValues y)
              (instance? SumConstraint y))
          (intersect y x)

          (contents-constraint y))))

(extend-type GetFrom
  Constraint
  (show-full [c]
    (string-list c))

  (derive-const [op]
    (fn [c]
      (intersect op c)))

  (intersect [x y]
    ;; TODO: for some reason, the empty? check in the inner 'cond' doesn't work
    (cond (empty? (.fld-path x))
          y

          (cond (=* x y)
                x

                (empty? (.fld-path x))
                y

                (or (instance? ParamConstraint y)
                    (instance? ComputedConstraint y)
                    (instance? AllValues y)
                    (instance? NoValues y)
                    (instance? SumConstraint y))
                (intersect y x)

                (or (instance? ListConstraint y)
                    (instance? VectorConstraint y)
                    (instance? ReifiedConstraint y))
                (either (map (first (.fld-path x))
                             (fn [fld]
                               (intersect (.fld-path x (rest (.fld-path x)))
                                          (get-from y fld))))

                        y)

                (NoValues [x y])))))

(extend-type SetTo
  Constraint
  (show-full [c]
    (string-list c))

  (derive-const [op]
    (fn [c]
      (intersect op c)))

  (intersect [x y]
    ;; TODO: for some reason, the empty? check in the inner 'cond' doesn't work
    (cond (empty? (.fld-path x))
          y

          (cond (=* x y)
                x

                (empty? (.fld-path x))
                y

                (or (instance? ParamConstraint y)
                    (instance? ComputedConstraint y)
                    (instance? AllValues y)
                    (instance? NoValues y)
                    (instance? SumConstraint y))
                (intersect y x)

                (or (instance? ListConstraint y)
                    (instance? VectorConstraint y)
                    (instance? ReifiedConstraint y))
                (set-to y (.fld-path x) (.fld-c x))

                (NoValues [x y])))))

(extend-type Field
  Constraint
  (show-full [c]
    (list "Field " (str (.sym c)))))

(extend-type TypeOfConstraint
  Constraint
  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (cons ["Type of value from" ""] (.path c))
                  desired-len))

  (show-full [c]
    (string-list c)))

;; (extend-type HashMapConstraint)


;; misc
;; Going to try and do without these
;; DebugConstraint

(def core-type-constraints {'Integer int-constraint
                            'StringBuffer strbuff-constraint
                            'SubString substr-constraint
                            'FnArity arity-constraint
                            'BitmapIndexedNode bitmap-constraint
                            'ArrayNode array-constraint
                            'HashCollisionNode hash-coll-constraint
                            'Fn fn-constraint
                            'List list-constraint
                            'Maybe maybe-constraint
                            'Vector vect-constraint
                            'Symbol sym-constraint
                            'HashMap hashmap-constraint
                            'Promise promise-constraint
                            'Future future-constraint
                            'Agent agent-constraint
                            'Opaque opaque-constraint})

;; combine two constraints to produce a new constraint
;; that is the same or more restrictive than either constraint

(defn is-bottom [c]
  (cata find-bottom c))

(defn set-items [c items]
  (apo (fn [c]
         (cond (instance? SeqConstraint c)
               (RecurseFinal (.items c items))

               (RecurseWith c)))
       c))

(defn set-tail [c tail]
  (apo (fn [c]
         (cond (instance? SeqConstraint c)
               (RecurseFinal (.tail-c c tail))

               (RecurseWith c)))
       c))

(defn reify-type-constraint [arity arity-id arg-cs loc]
  (assert (instance? Vector arg-cs))

  ;; (or ;; (= (.file loc) 'core)
  ;;     ;; (= (.line loc) 0)
  ;;     (and (= arity-id 'extract)
  ;;          (do
  ;;            (print-err 'reifying _LINE_ loc arity-id "\n"
  ;;                       arity "\n\n"
  ;;                       'args arg-cs)
  ;;            nothing)))
  (let [r (cata (fn [c]
                  (reify-const c arity-id arg-cs))
                arity)]
    (-> r
        trim
        (update-path loc))))

(defn merge-mods [mods1 mods2 new-c]
  (assert (instance? Sequence mods1))
  (assert (instance? Sequence mods2))
  (assert (instance? ComputedConstraint new-c))

  (cond (empty? mods1)
        (.mods new-c (comp (.mods new-c) mods2))

        (empty? mods2)
        (.mods new-c (comp (.mods new-c) mods1))

        (let [[mod1 & rest-mods1] mods1
              [mod2 & rest-mods2] mods2]
          (cond (and (instance? TypeOps mod1)
                     (instance? TypeOps mod2))
                (either (map (= mod1 mod2)
                             (fn [_]
                               (merge-mods rest-mods1 rest-mods2
                                           (.mods new-c (conj (.mods new-c) mod1)))))
                        (intersect mod1 mod2))

                (instance? ComputedConstraint mod1)
                (merge-mods (comp (.mods mod1) rest-mods1) mods2
                            new-c)

                (instance? ComputedConstraint mod2)
                (merge-mods mods1 (comp (.mods mod2) rest-mods2)
                            new-c)

                (instance? TypeOps mod1)
                (merge-mods mods1 rest-mods2
                            (.mods new-c (conj (.mods new-c) mod2)))

                (instance? TypeOps mod2)
                (merge-mods rest-mods1 mods2
                            (.mods new-c (conj (.mods new-c) mod1)))

                (let [new-mod (intersect mod1 mod2)]
                  (either (= bottom-type new-mod)
                          (merge-mods rest-mods1 rest-mods2
                                      (.mods new-c (conj (.mods new-c) new-mod)))))))))
