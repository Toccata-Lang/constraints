
(deftype ToccataCore [s]
  Stringable
  (string-list [_]
    (list "core"))

  Eq
  (=* [x y]
    (identical x y)))

(def lflf "\n\n")

(def FileName (any-of ToccataCore
                      String))

(defn file-name [x]
  (assert (instance? FileName x))
  (cond (instance? ToccataCore x)
        (.s x)

        x))

(deftype Location [file line]
  (assert (instance? FileName file))
  (assert (instance? Integer line))

  Stringable
  (string-list [_]
    (list (str file ": " line)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def no-loc (Location "" 0))

(deftype NoSymbol []
  Stringable
  (string-list [_]
    (list "c/no-symbol"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (instance? NoSymbol y)))

(def no-symbol (NoSymbol))

(extend-type Symbol
  Container
  (map [x f]
    (print-err 'blewie-sym _LINE_ x f)
    (abort)))

(deftype TaggedSymbol [ns base sym loc constraint]
  (assert (instance? Location loc))
  (assert (instance? (any-of Symbol NoSymbol) ns))
  (assert (instance? Symbol sym))
  (assert (instance? Symbol base))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Hashable
  (sha1-update [x ctxt]
    (sha1-update sym ctxt))

  (sha1 [x]
    (sha1 base))

  Ord
  (<* [_ x] (<* x base))

  Eq
  (=* [_ x] (=* x base))

  Stringable
  (string-list [s]
    ;; (list "(c/tagged-symbol " (str ns " " base " " sym " " file " " line "\n" constraint) ")")
    (list (cond (instance? Symbol (.ns s))
                (str (.ns s) "/" (.base s))

                (str (.base s))))))

(def OptionalSym (any-of NoSymbol
                         TaggedSymbol))

;; TODO: remove unused types
(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -2, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FunctionType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MaybeType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ListType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SymbolType};"))
(def BitmapIndexedType (inline C Integer "(Value *)&(Integer){IntegerType, -2, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ArrayNodeType};"))
(def HashCollisionNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -2, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, OpaqueType};"))
(def NoValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, NoValuesType};"))
(def AllValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AllValuesType};"))
(def ResultConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ResultConstraintType};"))
;; TODO: what the heck is this used for. Get rid of it
(def InferredInnerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InferredInnerType};"))
(def ContentsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ContentsConstraintType};"))
(def HashSetType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashSetType};"))
(def ProtoDispatcherType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ProtoDispatcherType};"))
(def FloatType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FloatType};"))
(def SumConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SumConstraintType};"))
(def TypeOfConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeOfConstraintType};"))
(def InnerTypeOfConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InnerTypeOfConstraintType};"))
(def DebugConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, DebugConstraintType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeCount};"))

;; type compoonents
(deftype NoInt []
  Stringable
  (string-list [_]
    (list "c/no-int"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (instance? NoInt y))

  Ord
  (<* [x y]
    (and (instance? Integer y)
         (maybe x))))

(def OptionalInt (any-of NoInt
                         Integer))
(def no-int (NoInt))

(deftype NoString []
  Stringable
  (string-list [_]
    (list "c/no-string"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Seqable
  (first [_] nothing)
  (rest [x] x)

  Eq
  (=* [x y]
    (instance? NoString y)))

(def OptionalStr (any-of NoString
                         String))
(def no-string (NoString))

(def NoStatic (any-of NoString
                      NoInt
                      NoSymbol))

(deftype NoTail []
  Stringable
  (string-list [_]
    (list "c/no-tail"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def no-tail (NoTail))

(deftype Max []
  Stringable
  (string-list [_]
    (list "c/max-key"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def max-key (Max))

(deftype Min []
  Stringable
  (string-list [_]
    (list "c/min-key"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def min-key (Min))

(deftype StaticValue []
  Stringable
  (string-list [_]
    (list "c/static-value"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def static-value (StaticValue))

(deftype Contents []
  Stringable
  (string-list [_]
    (list "c/contents"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def contents (Contents))

(deftype NoContents []
  Stringable
  (string-list [_]
    (list "c/no-contents"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def no-contents (NoContents))

(deftype NoFields []
  Stringable
  (string-list [_]
    (list "c/no-fields")))

(def no-fields (NoFields))

(deftype NoArgs []
  Stringable
  (string-list [_]
    (list "c/no-args"))

  Eq
  (=* [x y]
    (and (instance? NoArgs y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Seqable
  (first [_]
    nothing))

(def no-args (NoArgs))

(deftype Variadic []
  Stringable
  (string-list [_] (list "c/variadic")))

(def variadic (Variadic))

(def ArityRank (any-of Integer
                       Variadic))

(deftype Field [sym]
  (assert (instance? TaggedSymbol sym))

  Stringable
  (string-list [_]
    (list (str "(c/Field (c/tag \"" sym "\"))")))

  Eq
  (=* [x y]
    (and (instance? Field y)
         (= sym (.sym y))
         (maybe x)))

  Container
  (map [x _]
    x)

  (map [x _ embed]
    (embed x)))

(def FieldMapKey (any-of Field
                         Contents
                         StaticValue
                         Max
                         Min))

;; universal types
(deftype AllValues [path var]
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "c/top-type"))

  Eq
  (=* [x y]
    (and (instance? AllValues y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def top-type (AllValues empty-list ""))

(deftype NoValues [constraints]
  Stringable
  (string-list [_]
    (list "(c/NoValues [" (to-str (interpose constraints "\n")) "])"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (and (instance? NoValues y)
         (or (and (empty? constraints)
                  (maybe y))
             (maybe x)))))
(def bottom-type (NoValues []))

;; container types
(deftype CollectionOf [ctnts-c path sym var]
  (assert (instance? (list-of Location) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/coll-of-c " (str ctnts-c) ")"))

  Eq
  (=* [x y]
    (and (instance? CollectionOf y)
         (= ctnts-c (.ctnts-c y))
         (maybe x)))

  Container
  (map [x f]
    (.ctnts-c x (f (.ctnts-c x))))

  (map [x f embed]
    (-> (.ctnts-c x)
        f
        (map (partial .ctnts-c x)))))

(defn coll-of-c
  ([ctnts-c]
   (CollectionOf ctnts-c empty-list no-symbol ""))
  ([ctnts-c path sym var]
   (CollectionOf ctnts-c path sym var)))

(defn sym-str [s]
  (assert (instance? OptionalSym s))
  (assert-result r (instance? String r))

  (cond (= no-symbol s)
        ""

        (str "(c/tag \"" s "\")")))

(deftype SeqConstraint [type-num item tail path sym var]
  ;; can only be ListType, VectorType, UnknownType
  (assert (instance? Integer type-num))
  ;; ! item SymbolConstraints or NoTail
  ;; (assert (instance? (any-of SeqConstraint CollectionOf NoTail) tail))
  (assert (instance? (list-of Location) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Eq
  (=* [x y]
    (and (instance? SeqConstraint y)
         (= type-num (.type-num y))
         (= item (.item y))
         (= tail (.tail y))
         (maybe x)))

  Container
  (map [c f]
    (-> c
        (.tail (f (.tail c)))
        (.item (f (.item c)))))

  (map [c f embed]
    (for [new-tail (f (.tail c))
          new-item (f (.item c))]
      (-> c
          (.tail new-tail)
          (.item new-item)))))

(defn seq-c
  ([items]
   (seq-c items no-tail UnknownType))
  ([items tail]
   (seq-c items tail UnknownType))
  ([items tail seq-type]
   (cond (empty? items)
         (SeqConstraint seq-type no-tail tail
                   empty-list no-symbol "")

         (reduce (reverse items) tail
                 (fn [tail item]
                   (SeqConstraint seq-type item tail empty-list no-symbol ""))))))

(defn empty-seq? [c]
  (and (= no-tail (.item c))
       (= no-tail (.tail c))))

(def empty-seq (seq-c [no-tail]))
(def empty-list-constraint (.type-num empty-seq ListType))
(def empty-vect-constraint (.type-num empty-seq VectorType))

(defn list-c
  ([items]
   (seq-c items no-tail ListType))
  ([items tail]
   (seq-c items tail ListType)))

(defn vect-c
  ([items]
   (seq-c items no-tail VectorType))
  ([items tail]
   (seq-c items tail VectorType)))

(deftype fn-arity [arity-id param-consts result-const]
  (assert (instance? OptionalSym arity-id))
  ;; (assert (instance? SeqConstraint param-consts))

  Stringable
  (string-list [_]
    (list "(c/fn-arity\n" (either (map (= arity-id no-symbol) str)
                                  (str "(c/tag '" arity-id ")")) "\n"
          (str param-consts) "\n;; returns\n" (str result-const) ")"))

  Container
  (map [x f]
    (-> x
        (.param-consts (map param-consts f))
        (.result-const (f result-const))))

  (map [x f embed]
    (for [new-params (map param-consts f embed)
          new-result (f (.result-const x))]
      (-> x
          (.param-consts new-params)
          (.result-const new-result)))))

(deftype FnConstraint [required-arities arities path sym var]
  ;; (assert (instance? (map-of ArityRank fn-arity) arities))
  (assert (instance? (vector-of Integer) required-arities))
  (assert (instance? (list-of Location) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Eq
  (=* [x y]
    (and (instance? FnConstraint y)
         (= (count required-arities) (count (.required-arities y)))
         (every (.required-arities y) (fn [arity-rank]
                                        (some required-arities (partial = arity-rank))))
         (=* arities (.arities y))
         (maybe x)))

  Container
  (map [x f]
    (.arities x (map-vals arities f)))

  (map [x f embed]
    (map (contextual-map-vals arities f embed)
         (fn [a]
           (.arities x a)))))

(defn fn-c
  ([required arities]
   (FnConstraint required arities empty-list no-symbol ""))
  ([required arities path sym var]
   (FnConstraint required arities path sym var)))

;; product type
(deftype ReifiedConstraint [type-number type-symbol field-consts fields invoke-fn path sym var]
  (assert (instance? Integer type-number))
  ;; TODO: put this in
  ;; (assert (instance? (min-value 1) type-num))
  (assert (instance? OptionalSym type-symbol))
  (assert (instance? HashMap field-consts))
  (assert (instance? HashMap fields))
  (assert (instance? (list-of Location) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (let [long-form (list "(c/ReifiedConstraint " (str type-number) " "
                          (cond (= no-symbol type-symbol)
                                (str no-symbol)
                                (str "(c/tag \"" type-symbol "\")"))
                          "\n{" (to-str (map (vec field-consts) (fn [[k v]]
                                                                 (str k " " v "\n"))))
                          "}\n{" (to-str (map (vec fields) (fn [[k v]]
                                                            (str k " " v "\n"))))
                          "}\n" (str invoke-fn) "\n"
                          ;; (str (interpose (cons 'list path) " "))
                          " empty-list" (either (map (= no-symbol) (partial str " "))
                                                (sym-str sym))
                          " \"" (str var) "\")" )]
      (cond (and (= type-number UnknownType)
                 (= type-symbol no-symbol)
                 (empty? field-consts)
                 (empty? fields)
                 (= invoke-fn (fn-c [] {})))
            (list "c/empty-reified")

            (= type-number MaybeType)
            (either (map (get fields contents)
                         (fn [ctnts-c]
                           (cond (instance? AllValues ctnts-c)
                                 (list "c/maybe-constraint")

                                 (= no-contents ctnts-c)
                                 (list "c/nothing-constraint")

                                 (list "(c/MaybeConstraint " (str ctnts-c) ")"))))
                    long-form)

            (= type-number IntegerType)
            (either (for [static (get fields static-value)
                          min (get fields min-key)
                          max (get fields max-key)]
                      (cond (and (= no-int static)
                                 (= min int-min)
                                 (= max int-max))
                            (list "c/int-constraint")

                            (list "(c/IntegerConstraint " (str static)
                                  " " (str max) " " (str min) ")")))
                    long-form)

            (= type-number SymbolType)
            (either (for [static (get fields static-value)]
                      (cond (= no-symbol static)
                            (list "c/sym-constraint")

                            (list "(c/SymbolConstraint " (str "'" static) ")")))
                    long-form)

            (= type-number StringBufferType)
            (either (for [static (get fields static-value)]
                      (cond (= no-string static)
                            (list "c/strbuff-constraint")

                            (list "(c/StrBuffConstraint " (str "\"" static "\"") ")")))
                    long-form)

            (= type-number SubStringType)
            (either (for [static (get fields static-value)]
                      (cond (= no-string static)
                            (list "c/substr-constraint")

                            (list "(c/SubStrConstraint " (str "\"" static "\"") ")")))
                    long-form)

            (= type-number PromiseType)
            (list "c/promise-constraint")

            (= type-number AgentType)
            (list "c/agent-constraint")

            (= type-number BitmapIndexedType)
            (cond (and (empty? field-consts)
                       (empty? fields))
                  (list "c/bitmap-constraint")

                  long-form)

            (= type-number ArrayNodeType)
            (cond (and (empty? field-consts)
                       (empty? fields))
                  (list "c/array-constraint")

                  long-form)

            (= type-number HashCollisionNodeType)
            (cond (and (empty? field-consts)
                       (empty? fields))
                  (list "c/hash-coll-constraint")

                  long-form)

            long-form)))

  Eq
  ;; TODO: equality must check the field maps as well
  ;; verify this
  (=* [x y]
    (and (instance? ReifiedConstraint y)
         (= type-number (.type-number y))
         (= fields (.fields y))
         (maybe x)))

  Container
  (map [tc f]
    (-> tc
        (.field-consts (-> (.field-consts tc)
                           vec
                           (map (fn [[fld fld-c]]
                                  [(f fld) (f fld-c)]))
                           (reduce {} (fn [m [k v]]
                                        (assoc m k v)))))
        (.fields (-> (.fields tc)
                     vec
                     (map (fn [[fld fld-c]]
                            [(f fld)
                             (either (or (instance? Symbol fld-c)
                                         (instance? NoSymbol fld-c)
                                         (instance? OptionalStr fld-c)
                                         (instance? OptionalInt fld-c))
                                     (f fld-c))]))
                     (reduce {} (fn [m [k v]]
                                  (assoc m k v)))))
        (.invoke-fn (f (.invoke-fn tc)))))

  (map [tc f embed]
    ;; TODO: not even sure this is right. Too tired to step through it
    (for [new-field-cs (-> (.field-consts tc)
                           vec
                           (map (fn [[fld fld-c]]
                                  (for [new-fld (f fld)
                                        new-c (f fld-c)]
                                    [new-fld new-c]))
                                embed)
                           (map (fn [new-flds]
                                  (reduce new-flds {} (fn [m [k v]]
                                                        (assoc m k v))))))
          new-fields (-> (.fields tc)
                         vec
                         (map (fn [[fld fld-c]]
                                (for [new-fld (f fld)
                                      new-c (either (map (or (instance? OptionalInt fld-c)
                                                             (instance? OptionalStr fld-c)
                                                             (instance? Symbol fld-c)
                                                             (instance? NoSymbol fld-c))
                                                         embed)
                                                      (f fld-c))]
                                  [new-fld new-c]))
                              embed)
                         (map (fn [new-flds]
                                (reduce new-flds {} (fn [m [k v]]
                                                      (assoc m k v))))))
          new-invoke (f (.invoke-fn tc))]
      (-> tc
          (.field-consts new-field-cs)
          (.fields new-fields)
          (.invoke-fn new-invoke)))))

;; type attributes
;; sum type
(deftype SumConstraint [alts path sym var]
  (assert (instance? Vector alts))
  (assert (instance? (min-count 1) alts))
  (assert (instance? OptionalSym sym))
  (assert (instance? (list-of Location) path))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list (str "(c/sum-c [" (to-str (interpose alts "\n")) "])")))

  Eq
  (=* [x y]
    (and (instance? SumConstraint y)
         (= (count alts) (count (.alts y)))
         (every (.alts y) (fn [c]
                            (some alts (partial =* c))))
         (maybe x)))

  Container
  (map [x f]
    (.alts x (map (.alts x) f)))

  (map [x f embed]
    (-> (.alts x)
        (map f embed)
        (map (partial .alts x)))))

(defn sum-c
  ([alts]
   (SumConstraint alts empty-list no-symbol ""))
  ([alts path sym var]
   (SumConstraint alts path sym var)))

;; multiple constraint
(deftype MultiConstraint [constraints path sym]
  (assert (instance? OptionalSym sym))

  Stringable
  (string-list [_]
    (list "(c/multi [" (to-str (interpose constraints "\n")) "]"
          ;; " empty-list" (sym-str sym)
          ")"
          ))

  Eq
  (=* [x y]
    (and (instance? MultiConstraint y)
         (= (count constraints) (count (.constraints y)))
         (every constraints (fn [inner]
                              (some (.constraints y) (partial = inner))))
         (maybe x)))

  Container
  (map [x f]
    (.constraints x (map (.constraints x) f)))

  (map [x f embed]
    (map (map (.constraints x) f embed)
         (fn [new-cs]
           (.constraints x new-cs)))))

(defn multi [cs]
  (assert (instance? Vector cs))

  (MultiConstraint cs empty-list no-symbol))

(deftype ParamConstraint [arity param-path path sym var]
  (assert (instance? (vector-of Integer) param-path))
  (assert (instance? TaggedSymbol arity))
  (assert (instance? OptionalSym sym))

  Stringable
  (string-list [_]
    (list "(c/param " (str "(c/tag '" arity) ") " (str param-path) ")"))

  Eq
  (=* [x y]
    (and (instance? ParamConstraint y)
         (or (= arity (.arity y))
             (= (.arity y) arity))
         (= param-path (.param-path y))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(defn param [arity param-index]
  (ParamConstraint arity [param-index] empty-list no-symbol ""))

;; Get's replaced with the constraint of the param-sym, so not many implementations for it
(deftype TypeOfConstraint [param-sym path sym var]
  (assert (instance? OptionalSym param-sym))
  (assert (instance? (list-of Location) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/TypeOfConstraint" (sym-str param-sym)
          " empty-list"
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? TypeOfConstraint y)
         (= param-sym (.param-sym y))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype ProtoImpls [fn-sym default-impl impl-fns]
  (assert (instance? TaggedSymbol fn-sym))
  (assert (instance? FnConstraint default-impl))
  (assert (instance? (map-of Integer FnConstraint) impl-fns))

  Stringable
  (string-list [_]
    (list "(c/ProtoImpls\n" (sym-str fn-sym) "\n" (str default-impl) "\n\n" (str impl-fns) ")"))

  ;; TODO: could probably gain perf by doing a custom =* and sha1 that don'w
  ;; walk impl-fns
  ;; Hashable
  ;; (sha1-update [x ctxt]
  ;;   (sha1-update-type x ctxt)
  ;;   (sha1-update fn-sym ctxt)
  ;;   (sha1-update default-impl ctxt))

  ;; (sha1 [x]
  ;;   (let [ctxt (sha1-init)]
  ;;     (sha1-update x ctxt)
  ;;     (sha1-finalize ctxt)))


  ;; Eq
  ;; (=* [x y]
  ;;   (and (instance? ProtoImpls y)
  ;;        (= fn-sym (.fn-sym y))
  ;;        (= default-impl (.default-impl y))
  ;;        (cond (or (= impl-fns (.impl-fns y))
  ;;                  (and (empty? impl-fns)
  ;;                       (empty? (.impl-fns y))))
  ;;              (maybe x)

  ;;              (do
  ;;                (print-err 'wth _LINE_ impl-fns
  ;;                           lflf (.impl-fns y))
  ;;                (abort)
  ;;                nothing))
  ;;        (maybe x)))

  Container
  (map [x f]
    (ProtoImpls fn-sym
                (map default-impl f)
                (map-vals impl-fns f)))

  (map [x f embed]
    (for [def-impl (map default-impl f embed)
          impl-fns (contextual-map-vals impl-fns f embed)]
      (ProtoImpls fn-sym def-impl impl-fns))))

(deftype InnerTypeOf []
  Stringable
  (string-list [_]
    (list "c/inner-type-of-op")))
(def inner-type-of-op (InnerTypeOf))

(deftype FirstOf []
  Stringable
  (string-list [_]
    (list "c/first-of-op")))
(def first-of-op (FirstOf))

(deftype LastOf []
  Stringable
  (string-list [_]
    (list "c/last-of-op")))
(def last-of-op (LastOf))

(deftype RestOf []
  Stringable
  (string-list [_]
    (list "c/rest-of-op")))
(def rest-of-op (RestOf))

(deftype ButLastOf []
  Stringable
  (string-list [_]
    (list "c/butlast-of-op")))
(def butlast-of-op (ButLastOf))

(deftype ListFrom []
  Stringable
  (string-list [_]
    (list "c/list-from-op")))
(def list-from-op (ListFrom))

(deftype VectFrom []
  Stringable
  (string-list [_]
    (list "c/vect-from-op")))
(def vect-from-op (VectFrom))

(deftype ArgOf []
  Stringable
  (string-list [_]
    (list "c/arg-of-op")))
(def arg-of-op (ArgOf))

(deftype GetFrom []
  Stringable
  (string-list [_]
    (list "c/get-from-op")))
(def get-from-op (GetFrom))

(deftype SetTo []
  Stringable
  (string-list [_]
    (list "c/set-to-op")))
(def set-to-op (SetTo))

(deftype CallValue []
  Stringable
  (string-list [_]
    (list "c/call-value-op")))
(def call-value-op (CallValue))

(deftype Concat []
  Stringable
  (string-list [_]
    (list "c/concat-op")))
(def concat-op (Concat))

(deftype Apply []
  Stringable
  (string-list [_]
    (list "c/apply-op")))
(def apply-op (Apply))

;; TODO: should be an enum
(def TypeOpCodes (any-of InnerTypeOf
                         FirstOf
                         LastOf
                         RestOf
                         ButLastOf
                         ListFrom
                         VectFrom
                         ArgOf
                         GetFrom
                         SetTo
                         CallValue
                         Concat
                         Apply))

;; type operations
(deftype TypeOp [op-code base params sym path]
  (assert (instance? TypeOpCodes op-code))
  (assert (instance? (list-of Location) path))
  (assert (instance? OptionalSym sym))

  Stringable
  (string-list [_]
    (list "(c/type-op " (str op-code) "\n"
          (str base)
          (either (map (instance? Vector params)
                       (fn [_]
                         (str "\n[" (to-str (interpose params "\n")) "]")))
                  (cond (= no-args params) "" (str "\n" params)))
           "\n" (sym-str sym) ")" ))

  Eq
  (=* [x y]
    (and (instance? TypeOp y)
         (= op-code (.op-code y))
         (= base (.base y))
         (= params (.params y))
         (maybe x))))

(defn type-op
  ([op-code base]
   (TypeOp op-code base no-args no-symbol empty-list))
  ([op-code base params]
   (TypeOp op-code base params no-symbol empty-list))
  ([op-code base params sym]
   (TypeOp op-code base params sym empty-list))
  ([op-code base params sym path]
   (TypeOp op-code base params sym path)))

(def SymbolConstraints (any-of ReifiedConstraint
                               FnConstraint
                               CollectionOf
                               SumConstraint
                               TypeOfConstraint
                               ParamConstraint
                               MultiConstraint
                               TypeOp))

(def ValueConstraint (any-of SymbolConstraints
                             AllValues))

(def Constraints (any-of ValueConstraint
                         ProtoImpls
                         NoValues))

(def empty-fn-constraint (FnConstraint [] {} empty-list no-symbol ""))

(defn tag
  ([s]
   (tag s no-loc))
  ([s loc]
   (assert (instance? (any-of String
                              Symbol
                              NoSymbol
                              TaggedSymbol)
                      s))

   (cond (instance? TaggedSymbol s)
         (.loc s loc)

         (instance? NoSymbol s)
         s

         (let [s (symbol (str s))]
           (TaggedSymbol no-symbol s s loc top-type)))))

(def Integer-sym (tag 'Integer))
(def StringBuffer-sym (tag 'StringBuffer))
(def SubString-sym (tag 'SubString))
(def String-sym (tag 'String))
(def FnArity-sym (tag 'FnArity))
(def Fn-sym (tag 'Fn))
(def List-sym (tag 'List))
(def Maybe-sym (tag 'Maybe))
(def Vector-sym (tag 'Vector))
(def Symbol-sym (tag 'Symbol))
(def HashMap-sym (tag 'HashMap))
(def HashSet-sym (tag 'HashSet))
(def Promise-sym (tag 'Promise))
(def Future-sym (tag 'Future))
(def Agent-sym (tag 'Agent))
(def Opaque-sym (tag 'Opaque))
(def BitmapIndexedNode-sym (tag 'BitmapIndexedNode))
(def ArrayNode-sym (tag 'ArrayNode))
(def HashCollisionNode-sym (tag 'HashCollisionNode))

(defn IntegerConstraint
  ([static-val]
   (IntegerConstraint static-val 2147483647 -2147483648 empty-list no-symbol ""))
  ([static-val max-val min-val]
   (IntegerConstraint static-val max-val min-val empty-list no-symbol ""))
  ([static-val max-val min-val path sym var]
   ;; TODO: make min-key-val' and max-key-val' be constraints as well as integers
   (ReifiedConstraint IntegerType Integer-sym {}
                      {static-value static-val max-key max-val min-key min-val}
                      empty-fn-constraint path sym var)))

(def hashmap-names {BitmapIndexedType BitmapIndexedNode-sym
                    ArrayNodeType ArrayNode-sym
                    HashCollisionNodeType HashCollisionNode-sym})

(defn hashmap-c [type-num]
  (ReifiedConstraint type-num (either (get hashmap-names type-num)
                                      HashMap-sym)
                     {} {contents top-type}
                     empty-fn-constraint empty-list no-symbol ""))

(defn SymbolConstraint
  ([static-val]
   (SymbolConstraint static-val empty-list no-symbol ""))
  ([static-val path sym var]
   (ReifiedConstraint SymbolType Symbol-sym {}
                      {static-value static-val}
                      empty-fn-constraint path sym var)))

(defn OpaqueConstraint
  ([]
   (OpaqueConstraint empty-list no-symbol ""))
  ([path sym var]
   (ReifiedConstraint OpaqueType Opaque-sym {} {} empty-fn-constraint path sym var)))

(defn FutureConstraint
  ([]
   (FutureConstraint empty-list no-symbol ""))
  ([path sym var]
   (ReifiedConstraint FutureType Future-sym {} {} empty-fn-constraint path sym var)))

(defn MaybeConstraint
  ([ctnts-c]
   (MaybeConstraint ctnts-c empty-list no-symbol ""))
  ([ctnts-c path sym var]
   (ReifiedConstraint MaybeType Maybe-sym {} {contents ctnts-c} empty-fn-constraint path sym var)))

(defn PromiseConstraint
  ([]
   (ReifiedConstraint PromiseType Promise-sym {} {} empty-fn-constraint empty-list no-symbol ""))
  ([path sym var]
   (ReifiedConstraint PromiseType Promise-sym {} {} empty-fn-constraint path sym var)))

(defn AgentConstraint
  ([]
   (ReifiedConstraint AgentType Agent-sym {} {} empty-fn-constraint empty-list no-symbol ""))
  ([path sym var]
   (ReifiedConstraint AgentType Agent-sym {} {} empty-fn-constraint path sym var)))

(defn StrBuffConstraint
  ([static-val]
   (StrBuffConstraint static-val empty-list no-symbol ""))
  ([static-val path sym var]
   (ReifiedConstraint StringBufferType String-sym {} {static-value static-val}
                      empty-fn-constraint path sym var)))

(defn SubStrConstraint
  ([static-val]
   (SubStrConstraint static-val empty-list no-symbol ""))
  ([static-val path sym var]
   (ReifiedConstraint SubStringType String-sym {} {static-value static-val} empty-fn-constraint path sym var)))


(def empty-reified (ReifiedConstraint UnknownType no-symbol {} {}
                                      empty-fn-constraint
                                      empty-list  no-symbol ""))
(def not-container (.type-symbol empty-reified (tag "Can not contain other values")))
(def coll-of-any (CollectionOf top-type empty-list no-symbol ""))
(def list-constraint (list-c [] coll-of-any))
(def vect-constraint (vect-c [] coll-of-any))
(def seq-constraint (seq-c [] coll-of-any))
(def substr-constraint (SubStrConstraint no-string empty-list no-symbol ""))
(def strbuff-constraint (StrBuffConstraint no-string empty-list no-symbol ""))
(def string-constraint (SumConstraint [strbuff-constraint substr-constraint]
                                      empty-list no-symbol ""))
(def fn-constraint (FnConstraint []
                                 {variadic (fn-arity no-symbol list-constraint top-type)
                                  0 (fn-arity no-symbol empty-list-constraint top-type)
                                  1 (fn-arity no-symbol (list-c (repeat 1 top-type))
                                              top-type)
                                  2 (fn-arity no-symbol (list-c (repeat 2 top-type))
                                              top-type)
                                  3 (fn-arity no-symbol (list-c (repeat 3 top-type))
                                              top-type)
                                  4 (fn-arity no-symbol (list-c (repeat 4 top-type))
                                              top-type)
                                  5 (fn-arity no-symbol (list-c (repeat 5 top-type))
                                              top-type)
                                  6 (fn-arity no-symbol (list-c (repeat 6 top-type))
                                              top-type)
                                  7 (fn-arity no-symbol (list-c (repeat 7 top-type))
                                              top-type)
                                  8 (fn-arity no-symbol (list-c (repeat 8 top-type))
                                              top-type)
                                  9 (fn-arity no-symbol (list-c (repeat 9 top-type))
                                              top-type)}
                                 empty-list no-symbol ""))
(def type-of-constraint (TypeOfConstraint no-symbol empty-list no-symbol ""))
(def sym-constraint (SymbolConstraint no-symbol empty-list no-symbol ""))
(def seq-or-str-constraint (SumConstraint [vect-constraint list-constraint strbuff-constraint substr-constraint]
                                            empty-list no-symbol ""))
(def hash-coll-constraint (hashmap-c HashCollisionNodeType))
(def array-constraint (hashmap-c ArrayNodeType))
(def bitmap-constraint (hashmap-c BitmapIndexedType))
(def hashmap-constraint (SumConstraint [bitmap-constraint array-constraint hash-coll-constraint]
                                         empty-list no-symbol ""))
(def int-constraint (IntegerConstraint no-int int-max int-min empty-list no-symbol ""))
(def maybe-constraint  (MaybeConstraint top-type empty-list no-symbol ""))
(def nothing-constraint  (MaybeConstraint no-contents empty-list no-symbol ""))
(def set-constraint (ReifiedConstraint HashSetType HashSet-sym
                                         {(Field (tag ".set-map")) hashmap-constraint}
                                         {(Field (tag ".set-map")) hashmap-constraint}
                                         (.arities fn-constraint {}) empty-list no-symbol ""))
(def agent-constraint (AgentConstraint))
(def promise-constraint (PromiseConstraint))
(def future-constraint (FutureConstraint empty-list no-symbol ""))
(def opaque-constraint (OpaqueConstraint empty-list no-symbol ""))
(def arity-constraint (ReifiedConstraint FnArityType FnArity-sym {} {}
                                         (.arities fn-constraint {})
                                         empty-list no-symbol ""))
(def inner-type-of (type-op inner-type-of-op top-type))
(def first-of (multi [maybe-constraint
                      (type-op first-of-op top-type)]))
(def last-of (multi [maybe-constraint
                     (type-op last-of-op top-type)]))
(def rest-of (type-op rest-of-op top-type))
(def butlast-of (type-op butlast-of-op top-type))
(def list-from (type-op list-from-op top-type))
(def vect-from (type-op vect-from-op top-type))
(def result-of (type-op call-value-op top-type))
(def concat (type-op concat-op list-constraint))
(def apply-fn (type-op apply-op list-constraint))

(defn missing-field [fld]
  (ReifiedConstraint UnknownType (tag (str "Field/index '" fld "' required"))
                     {} {} empty-fn-constraint
                     empty-list no-symbol ""))

(defn cant-set-contents [x fld-path]
  (either (map (first fld-path)
               (fn [fld]
                 (NoValues [x (missing-field fld)])))
          (NoValues [x (ReifiedConstraint UnknownType (tag "Unable to set ctnts-c")
                                          {} {} empty-fn-constraint
                                          empty-list no-symbol "")])))

(defn is-param [c]
  (or (instance? ParamConstraint c)
      (cond (or (instance? ProtoImpls c)
                (instance? FnConstraint c))
            nothing

            (instance? HashMap c)
            (some (vals c) is-param)

            (instance? SymbolConstraints c)
            (some (type-args c) is-param)

            (and (instance? Vector c)
                 (some c is-param)))))

(defprotocol Constraint
  (do-call-value [base args loc-path]
    (assert (instance? Constraints base))
    (assert-result r (instance? Vector r))

    (cond (or (is-param base)
              (and (= nothing (= args no-args))
                   (some args is-param)))
          [(TypeOp call-value-op base args no-symbol loc-path)
           args]

          (instance? MultiConstraint base)
          (do-call-value base args loc-path)

          [(NoValues [(type-op call-value-op top-type args) base])
           args]))

  (skip-protoimpls [c]
    (RecurseWith c))

  (set-path [c new-path]
    (assert (instance? (list-of Location) new-path))
    (assert-result r (instance? RecurseNext r))

    (RecurseWith c))

  (extract-sym [tc]
    (assert-result r (instance? OptionalSym r))

    no-symbol)

  (update-sym [c new-sym]
    (assert (instance? OptionalSym new-sym))

    c)

  (add-to-path [constraint loc]
    (assert (instance? Location loc))
    constraint)

  (type-num [c]
    (assert-result r (instance? Integer r))

    UnknownType)

  (type-sym [c]
    (assert-result r (instance? OptionalSym r)))

  (assertion-path [x])

  (format-path [x n]
    (assert-result r (instance? (list-of String) r)))

  (show-full [c]
    (assert-result b (instance? (list-of String) b)))

  (set-to [x fld-path fld-c]
    (cond (empty? fld-path)
          fld-c

          (cant-set-contents x fld-path)))

  (get-from [x fld]
    (NoValues [x (missing-field fld)]))

  (contents-constraint [c]
    (NoValues [c not-container]))

  ;; replace any ParamConstraints for 'arity' with their corresponding values
  (reify-const [c arity args]
    c)

  (found-constraint [c]
    nothing)

  (find-param [c]
    (assert-result t (instance? RecurseNext t))

    (RecurseWith c))

  ;; get only the fixeditems from a list or vector
  (get-items [c]
    (assert-result r (instance? Vector r))

    [])

  (get-tail [c]
    no-tail)

  (get-items [c items-count]
    (assert-result r (instance? Vector r))

    [])

  ;; Ensure constraint is as small as possible
  (trim-const [c]
    c)

  ;; derive a new type by applying a type operation
  (derive-const [op]
    ;; TODO: perhaps this is a better impl
    ;; (fn [c]
    ;;   (intersect (map op (fn [f]
    ;;                        (f top-type)))
    ;;              c))

    ;; TODO: Make sure (fn [_] op) works as well
    (constantly op))

  ;; produces the type required by the type operation
  ;; (required [c op]
  ;;   (intersect c op))

  (intersect [c1 c2]
    ;; 'top-type' is the undefined result
    top-type))

(defn set-seq-tail [c new-tail]
  (cond (instance? SeqConstraint c)
        (.tail c (set-seq-tail (.tail c) new-tail))

        new-tail))

(defn format-path* [header path desired-len]
  (assert (instance? String header))
  (assert (instance? (list-of Location) path))
  (assert (instance? Integer desired-len))

  (let [path (-> (rest path)
                 (remove (partial = no-loc))
                 (map (fn [loc]
                        (let [file (str (.file loc))]
                          (str (either (-> file
                                           str
                                           (split-string (partial = "/"))
                                           last
                                           (map (fn [file]
                                                  (either (and (flat-map (first file)
                                                                         (partial = "/"))
                                                               (maybe file))
                                                          file))))
                                       file)
                               ": " (.line loc))))))
        max-width (reduce path (count header)
                          (fn [max s]
                            (let [n (count s)]
                              (either (> max n)
                                      n))))
        path (either (and (< (count path) desired-len)
                          (maybe (comp path (repeat (- desired-len (count path))
                                                    (spaces max-width)))))
                     path)]
    (map (cons header path)
         (fn [x]
           (str x (spaces (- max-width (count x))))))))

(defn replace-path [c new-path]
  (apo (fn [c]
         (set-path c new-path))
       c))

(defn update-path [c loc]
  (elgot skip-protoimpls
         (fn [c]
          (add-to-path c loc))
        c))

(defn trim [c]
  (elgot skip-protoimpls
         trim-const
         c)
  ;; TODO: this might be faster
  ;; (cond (instance? ProtoImpls c)
  ;;       c

  ;;       (trim-const (map c trim)))
  )

(defn derive [op c]
  ((elgot (fn [c]
            (either (map (instance? ProtoImpls c)
                         (fn [c]
                           (RecurseFinal (fn [op]
                                           c))))
                    (RecurseWith c)))
          derive-const
          op)
   c))

(defn some-constraint [pred c]
  (elgot (fn [c]
           (cond (instance? ProtoImpls c)
                 (RecurseFinal nothing)

                 (let [found (pred c)]
                   (either (instance? RecurseNext found)
                           (cond found
                                 (RecurseFinal found)

                                 (RecurseWith c))))))
         found-constraint
         c))

;; (defn some-constraint [pred c]
;;   (or (pred c)
;;       (find-constraint c (partial some-constraint pred))))

;; TODO: this is slower than is-bottom, but I suspect it checks more
(defn ib2 [c]
  (or (= bottom-type c)
      (cond (instance? ProtoImpls c)
            nothing

            (instance? HashMap c)
            (some (vals c) ib2)

            (or (instance? fn-arity c)
                (instance? SymbolConstraints c))
            (ib2 (type-args c))

            (and (instance? Vector c)
                 (some c ib2)))))

(defn is-bottom [c]
  (let [;; r (ib2 c)
        s (some-constraint (partial = bottom-type) c)
        ]
    ;; (or (= r s)
    ;;     (do
    ;;       (print-err 'boomerity _LINE_ r
    ;;                  lflf s)
    ;;       (abort)))
    s
    ))

(defn reify-type-constraint [arity arity-id arg-cs loc]
  (assert (instance? Vector arg-cs))
  ;; TODO: this is an attempt to not descend into ParamConstraint values
  ;; (update-path (elgot (fn [c]
  ;;                       ;; (cond (instance? ParamConstraint c)
  ;;                       ;;       (RecurseFinal (reify-const c arity-id arg-cs)))

  ;;                       (skip-protoimpls c))
  ;;                     (fn [c]
  ;;                       (cond (instance? ParamConstraint c)
  ;;                             c

  ;;                             (reify-const c arity-id
  ;;                                          arg-cs)))
  ;;                     arity)
  ;;              loc)
  (update-path (elgot skip-protoimpls
                      (fn [c]
                        (reify-const c arity-id
                                     arg-cs))
                      arity)
               loc))

(defn sum-type [const-cs]
  (assert (instance? Vector const-cs))

  ;; TODO: calling 'is-bottom' for each alt is bad. Only do when needed
  (let [alts (remove const-cs is-bottom)]
    (either (or (for [_ (empty? alts)
                      first-c (first const-cs)
                      bot-c (is-bottom first-c)]
                  bot-c)
                (let [alts (-> alts
                               (reduce []
                                       (fn [cs c]
                                         (cond (instance? SumConstraint c)
                                               (comp (.alts c) cs)

                                               (some cs (partial = c))
                                               cs

                                               (conj cs c)))))]
                  (or (and (= 1 (count alts))
                           (first alts))
                      (and (empty? alts)
                           (maybe top-type))
                      (some alts (partial = top-type))
                      (apply = alts)
                      (and (every alts (partial instance? CollectionOf))
                           (-> alts
                               (map .ctnts-c)
                               sum-type
                               (CollectionOf empty-list no-symbol "")
                               maybe))
                      (and (< 1 (count alts))
                           (maybe (SumConstraint alts empty-list no-symbol ""))))))
            top-type)))

(extend-type TaggedSymbol
  Constraint
  (show-full [x]
    (list (str x))))

(extend-type ValueConstraint
  Constraint
  (add-to-path [c loc]
    (cond (or (= loc no-loc)
              (some (.path c) (partial = loc)))
          c
          (.path c (cons loc (.path c))))))

(extend-type SymbolConstraints
  Constraint
  (set-path [c new-path]
    (RecurseFinal (.path c new-path)))

  (extract-sym [c]
    (.sym c))

  (update-sym [c new-sym]
    (.sym c new-sym)))

(extend-type NoContents
  Constraint
  (assertion-path [_] empty-list)

  (format-path [_ n]
    (list "Contains nothing"))

  (show-full [c]
    (list "c/no-contents"))

  (intersect [x y]
    (cond (instance? CollectionOf y)
          (NoValues [x y])

          (instance? NoContents y)
          x

          (intersect y x))))

(extend-type NoTail
  Constraint
  (intersect [x y]
    (cond (= bottom-type y)
          y

          (instance? SeqConstraint y)
          (contents-constraint x)

          x))

  (assertion-path [_] empty-list)

  (format-path [_ n]
    (list "No Tail for sequence"))

  (show-full [c]
    (list "c/no-tail")))

(extend-type AllValues
  Constraint
  (do-call-value [base args loc]
    [(type-op call-value-op fn-constraint args) args])

  (format-path [x desired-len]
    (list "<Unknown Type>"))

  (show-full [c]
    (format-path c 0))

  (contents-constraint [c]
    c)

  (get-items [c items-count]
    (repeat items-count c))

  (intersect [x y]
    y))

(extend-type NoValues
  Constraint
  (format-path [c n]
    (let [max-len (-> (trim c)
                      .constraints
                      (map (fn [c] (count (assertion-path c))))
                      (reduce n (fn [max-len path-len]
                                  (either (> max-len path-len)
                                          path-len)))
                      inc)]
      (-> (.constraints c)
          (map (fn [c]
                 (format-path c max-len)))
          (list-zipper empty-list)
          (map (fn [strs]
                 (str (to-str (interpose strs "    "))
                      "\n"))))))

  (show-full [c]
    (comp (list "Conflicting types")
          (map (.constraints c) (partial str "  "))))

  (contents-constraint [c]
    c)

  (trim-const [c]
    (.constraints c (comp (remove (.constraints c) (partial instance? NoValues))
                          (-> (.constraints c)
                              (filter (partial instance? NoValues))
                              (flat-map .constraints)))))

  (intersect [x _] x))

(defn str-inner [sc]
  (either (map (get-in sc [.fields static-value])
               (fn [sv]
                 (cond (= sv no-string)
                       substr-constraint

                       (-> sv
                           vec
                           (map (fn [c]
                                  (SubStrConstraint c empty-list no-symbol "")))
                           sum-type))))
          string-constraint))

(defn set-seq-type [c seq-type]
  (cond (instance? SeqConstraint c)
        (cond (= (.type-num c) seq-type)
              c

              (-> c
                  (.tail (set-seq-type (.tail c) seq-type))
                  (.type-num seq-type)))
        c))

(defn seq-items
  ([c]
   (seq-items c []))
  ([c items]
   (assert-result r (instance? Vector c))

   (cond (instance? SeqConstraint c)
         (cond (= no-tail (.item c))
               (seq-items (.tail c))

               (seq-items (.tail c) (conj items (.item c))))

         items)))

(defn seq-tail [c]
  (cond (instance? SeqConstraint c)
        (seq-tail (.tail c))

        c))

(extend-type SeqConstraint
  Stringable
  (string-list [c]
    (let [seq-str (cond (= (.type-num c) VectorType)
                        "c/vect-c"

                        (= (.type-num c) ListType)
                        "c/list-c"

                        "c/seq-c")]
      (cond (= no-tail (.item c))
            (list (str "(" seq-str " [] " (seq-tail c) ")"))
            (list (str "(" seq-str " [" (to-str (interpose (seq-items c) "\n")) "]\n"
                       (seq-tail c) ")")))))

  Constraint
  (type-num [c] (.type-num c))

  (type-sym [c]
    (cond (= (.type-num c) ListType)
          List-sym

          (= (.type-num c) VectorType)
          Vector-sym

          no-symbol))

  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (cond (= (.type-num c) ListType)
                        "List from:"

                        (= (.type-num c) VectorType)
                        "Vector from:"

                        "Sequence from:")
                  (.path c) desired-len))

  ;; (show-full [c]
  ;;   (comp (format-path c 0)
  ;;         ["--items--"]
  ;;         (-> (.items c)
  ;;             (interpose ["----"])
  ;;             (flat-map (fn [item-strs]
  ;;                         (map item-strs (partial str "  ")))))
  ;;         (cond (= (show-full bottom-type) (.tail-c c))
  ;;               []
  ;;               (comp ["--tail--"]
  ;;                     (map (.tail-c c) (partial str "  "))))
  ;;         ["===="]))

  (set-to [x fld-path fld-c]
    (cond (empty-seq? x)
          (cant-set-contents x fld-path)

          (empty? fld-path)
          fld-c

          (let [[fst & rst] fld-path]
            (either (map (or (instance? Integer fst)
                             (for [_ (and (instance? ReifiedConstraint fst)
                                          (= IntegerType (.type-number fst)))
                                   idx (get-in fst [.fields static-value])
                                   :when-not (= idx no-int)]
                               idx))
                         (fn [idx]
                           (cond (= no-tail (.item x))
                                 (seq-c (conj (get-items (.tail x) idx) fld-c)
                                        (.tail x))

                                 (> idx 0)
                                 (.tail x (set-to (.tail x) (cons (dec idx) rst) fld-c))

                                 (cond (empty? rst)
                                       (.item x fld-c)
                                       
                                       (.item x (set-to (.item x) rst fld-c))))))
                    (cant-set-contents x fld-path)))))

  (get-from [x idx]
    (assert (instance? (any-of Integer ReifiedConstraint) idx))
    (cond (empty-seq? x)
          (NoValues [x (missing-field idx)])

          (either (map (or (instance? Integer idx)
                           (for [_ (and (instance? ReifiedConstraint idx)
                                        (= IntegerType (.type-number idx)))
                                 idx (get-in idx [.fields static-value])
                                 :when-not (= idx no-int)]
                             idx))
                       (fn [idx]
                         (cond (= 0 idx)
                               (.item x)

                               (and (= no-tail (.item x))
                                    (instance? CollectionOf (.tail x)))
                               (.ctnts-c (.tail x))

                               (get-from (.tail x) (dec idx)))))
                  (NoValues [x (missing-field idx)]))))

  (contents-constraint [c]
    (cond (empty-seq? c)
          top-type

          (= no-tail (.item c))
          (contents-constraint (seq-tail c))

          (-> (seq-items c)
              (comp (cond (= no-tail (.tail c))
                          []
                          [(contents-constraint (seq-tail c))]))
              (remove (partial = top-type))
              sum-type)))

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [ctnts-c]
                           (ctnts-c top-type)))
                 c)))

  (found-constraint [c]
    (or (.item c)
        (.tail c)))

  (get-items [l]
    (seq-items l))

  (get-items [c items-count]
    (cond (= no-tail (.item c))
          (get-items (.tail c) items-count)

          (= 1 items-count)
          [(.item c)]

          (cond (= no-tail (.tail c))
                []

                (comp [(.item c)]
                      (get-items (.tail c) (dec items-count))))))

  (get-tail [l]
    (seq-tail l))

  (intersect [x y]
    (cond (= x y)
          x

          (or (instance? ParamConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? MultiConstraint y)
              (instance? SumConstraint y)
              (and (instance? ReifiedConstraint y)
                   (= UnknownType (.type-number y)))
              (instance? TypeOp y))
          (intersect y x)

          (instance? SeqConstraint y)
          (cond (or (empty-seq? y)
                    (empty-seq? x))
                (NoValues [x y])

                (either (map (or (= (.type-num x) (.type-num y))
                                 (and (= (.type-num x) UnknownType)
                                      (maybe (.type-num y)))
                                 (and (= (.type-num y) UnknownType)
                                      (maybe (.type-num x))))
                             (fn [new-type]
                               (let [item-x (.item x)
                                     item-y (.item y)
                                     new-item (either (and (= item-x no-tail)
                                                           (= item-y no-tail))
                                                      
                                                      (cond (= item-x no-tail)
                                                            (intersect (contents-constraint (.tail x))
                                                                       item-y)

                                                            (= item-y no-tail)
                                                            (intersect (contents-constraint (.tail y))
                                                                       item-x)
                                                            
                                                            (intersect item-x item-y)))
                                     new-tail (intersect (.tail x) (.tail y))]
                                 (either (or (= bottom-type new-item)
                                             (= bottom-type new-tail))
                                         ;; TODO: this does not properly handle
                                         ;; location path.
                                         (-> x
                                             (.type-num new-type)
                                             (.item new-item)
                                             (.tail new-tail))))))
                        (NoValues [x y])))

          (instance? CollectionOf y)
          (let [contents (.ctnts-c y)
                new-item (either (= no-tail (.item x))
                                 (intersect contents (.item x)))
                new-tail (either (= no-tail (.tail x))
                                 (intersect y (.tail x)))]
            (either (or (= bottom-type new-item)
                        (= bottom-type new-tail))
                    (-> x
                        (.item new-item)
                        (.tail new-tail))))

          (NoValues [x y])))
  )

(extend-type SumConstraint
  Constraint
  (type-num [c]
    (either (apply = (map (.alts c) type-num))
            UnknownType))

  (assertion-path [c] (.path c))

  (format-path [c n]
    (let [sum-sym (either (apply = (map (.alts c) type-sym))
                          "Sum Type")]
      (format-path* (str sum-sym " from") (.path c) n)))

  (show-full [c]
    (comp (format-path c 0)
          (-> (.alts c)
              (interpose ["----"])
              (flat-map (fn [alt-strs]
                          (map alt-strs (partial str "  ")))))))

  (contents-constraint [c]
    (-> (.alts c)
        (map contents-constraint)
        sum-type))

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [ctnts-c]
                           (ctnts-c top-type)))
                 c)))

  (found-constraint [c]
    (some (.alts c) identity))

  (get-items [c]
    (let [alts-items (-> (.alts c)
                         (map (fn [alt]
                                (get-items alt))))]
      (either (empty? alts-items)
              (-> (list-zipper alts-items empty-list)
                  (map (fn [alts]
                         (sum-type (vec alts))))
                  vec))))

  (get-tail [l]
    (-> (.alts l)
        (map get-tail)
        sum-type))

  (get-items [c items-count]
    (let [alts-items (-> (.alts c)
                         (map (fn [alt]
                                (get-items alt items-count)))
                         (filter (fn [alt]
                                   (= items-count (count alt)))))]
      (either (empty? alts-items)
              (-> (apply zip-lists alts-items)
                  (map (fn [alts]
                         (sum-type (vec alts))))
                  vec))))

  (trim-const [c]
    (let [all-alts (flat-map (.alts c) (fn [c]
                                         (either (map (instance? SumConstraint c) .alts)
                                                 [c])))
          new-c (sum-type all-alts)]
      (cond (instance? SymbolConstraints new-c)
            (-> new-c
                (.path (.path c))
                (.sym (.sym c)))
            new-c)))

  (reify-const [c arity args]
    (let [new-cs (remove (.alts c) (partial = empty-reified))]
      (cond (empty? new-cs)
            empty-reified

            (.alts c new-cs))))

  (intersect [x y]
    (cond (= x y)
          x

          (instance? SumConstraint y)
          (let [new-alts (for [a1 (.alts x)
                               a2 (.alts y)
                               :let [new-alt (intersect a1 a2)]
                               :when-not (= bottom-type new-alt)]
                           new-alt)
                new-alts (reduce new-alts [] (fn [new-alts alt]
                                               (either (and (some new-alts (partial =* alt))
                                                            (maybe new-alts))
                                                       (conj new-alts alt))))]
            (either (or (and (empty? new-alts)
                             (maybe (NoValues [x y])))
                        (and (= 1 (count new-alts))
                             (first new-alts)))
                    (.alts x new-alts)))

          (instance? ParamConstraint y)
          (MultiConstraint [x y] empty-list (.sym x))

          (instance? MultiConstraint y)
          (intersect y x)

          (let [y-type (type-num y)
                [inters fail] (reduce (.alts x) [[] top-type]
                                      (fn [[inters fail] alt]
                                        (let [inter (intersect alt y)]
                                          [(conj inters inter)
                                           (cond (= bottom-type inter)
                                                 (cond (= y-type (type-num alt))
                                                       inter

                                                       fail)
                                                 fail)])))
                goods (-> inters
                          (remove (partial instance? NoValues))
                          (reduce [] (fn [goods y]
                                       (either (and (some goods (partial = y))
                                                    (maybe goods))
                                               (conj goods y)))))]
            (either (or (and (empty? goods)
                             (or (= bottom-type fail)
                                 (apply = inters)
                                 (maybe (NoValues [x y]))))
                        (and (= (count goods) 1)
                             (first goods)))
                    (.alts x goods))))))

(extend-type CollectionOf
  Constraint
  (get-tail [c] c)

  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* "Contents from" (.path c) desired-len))

  (show-full [c]
    (comp (format-path c 0)
          (map (.ctnts-c c) (partial str "  "))))

  (contents-constraint [c]
    (.ctnts-c c))

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [ctnts-c]
                           (ctnts-c top-type)))
                 c)))

  (found-constraint [c]
    (.ctnts-c c))

  (get-items [c items-count]
    (repeat items-count (.ctnts-c c)))

  (intersect [x y]
    (cond (instance? CollectionOf y)
          (let [new-cs (intersect (.ctnts-c x) (.ctnts-c y))]
            (either (or (= new-cs bottom-type)
                        (= x y))
                    (.ctnts-c x new-cs)))

          (intersect y x))))

(extend-type MultiConstraint
  Constraint
  (get-tail [c]
    (.constraints c (map (.constraints c) get-tail)))

  (assertion-path [c] empty-list)

  (format-path [c desired-len]
    (format-path* "Multi Constraints" empty-list desired-len))

  (show-full [c]
    (comp (format-path c 0)
          (-> (.constraints c)
              (interpose (list "---"))
              (flat-map (fn [c-strs]
                          (map c-strs (partial str "  ")))))))

  (contents-constraint [c]
    (reduce (.constraints c) top-type
            (fn [ctnts-c inner]
              (intersect ctnts-c (contents-constraint inner)))))

  (reify-const [c arity args]
    (let [new-cs (remove (.constraints c) (partial = empty-reified))]
      (cond (empty? new-cs)
            empty-reified

            (.constraints c new-cs))))

  (type-num [c]
    (either (-> (.constraints c)
                (map type-num)
                (reduce (maybe UnknownType) (fn [x y]
                                              (flat-map x (fn [inner]
                                                            (cond (= inner UnknownType)
                                                                  (maybe y)

                                                                  (= y UnknownType)
                                                                  x

                                                                  (= inner y)))))))
            UnknownType))

  (derive-const [op]
    (fn [c]
      (-> (.constraints op)
          (map (fn [op-fn]
                 (op-fn c)))
          (reduce top-type intersect))))

  (found-constraint [c]
    (some (.constraints c) identity))

  (get-items [c items-count]
    (get-items (trim (derive c top-type)) items-count))

  (get-items [c]
    (get-items (trim (derive c top-type))))

  (trim-const [c]
    (let [[params others] (reduce (.constraints c) [[] []]
                                  (fn [[params others] inner]
                                    (cond (instance? ParamConstraint inner)
                                          [(conj params inner) others]

                                          [params (conj others inner)])))]
      (reduce params
              (reduce others top-type intersect)
              intersect)))

  (intersect [x y] 
    (cond (or (=* x y)
              (some (.constraints x) (partial = y)))
          x

          (or (instance? AllValues y)
              (instance? NoValues y))
          (intersect y x)

          (instance? MultiConstraint y)
          (reduce (.constraints y) x intersect)

          (let [[new-cs final-y] (reduce (.constraints x) [[] y]
                                         (fn [[cs y] c]
                                           (let [new-y (intersect c y)]
                                             (cond (= bottom-type new-y)
                                                   [(conj cs new-y) new-y]

                                                   (or (= new-y y)
                                                       (= new-y c))
                                                   [cs new-y]

                                                   [(conj cs c) y]))))]
            (either (= bottom-type final-y)
                    (.constraints x (conj new-cs final-y)))))))

(extend-type ParamConstraint
  Constraint
  (get-tail [_]
    top-type)

  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (str "Parameter " (.param-path c) " from") (.path c)
                  desired-len))

  (show-full [c]
    (format-path c 0))

  (contents-constraint [c]
    (.base inner-type-of c))

  (reify-const [c arity-id args]
    (let [param-path (.param-path c)]
      (cond (= (.arity c) arity-id)
            (either (for [arg-idx (first param-path)
                          new-args (get args arg-idx)]
                      (let [rst (rest param-path)]
                        (cond (empty? rst)
                              new-args

                              (reify-const (.param-path c rst)
                                           arity-id new-args))))
                    top-type)
            c)))

  (derive-const [op]
    (fn [c]
      c))

  (find-param [c]
    (RecurseFinal (maybe c)))

  (intersect [x y]
    (cond (=* x y)
          x

          (or (instance? AllValues y)
              (instance? NoValues y)
              (instance? MultiConstraint y))
          (intersect y x)

          (MultiConstraint [y x] empty-list (.sym x)))))

(extend-type fn-arity
  Eq
  (=* [x y]
    (flat-map (instance? fn-arity y)
              (fn [_]
                (let [old-id (.arity-id y)
                      y (elgot skip-protoimpls
                               (fn [c]
                                 (cond (and (instance? ParamConstraint c)
                                            (= old-id (.arity c)))
                                       (.arity c (.arity-id x))

                                       c))
                              y)]
                  (and (= (.param-consts x) (.param-consts y))
                       (= (.result-const x) (.result-const y))
                       (maybe x))))))

  Constraint
  ;; (show-full [c]
  ;;   (comp (list (str "arity: " (.arity-id c))
  ;;               "--parameters--")
  ;;         (->  (.param-consts c)
  ;;              (.items)
  ;;              (interpose ["----"])
  ;;              (flat-map (fn [item-strs]
  ;;                          (map item-strs (partial str "  ")))))
  ;;         (let [tail-c (.tail-c (.param-consts c))]
  ;;           (cond (first tail-c)
  ;;                 (comp ["--variadic params--"]
  ;;                       (map tail-c (partial str "  ")))
  ;;                 []))
  ;;         ["--result--"]
  ;;         (map (.result-const c) (partial str "  "))))

  (derive-const [op]
    (fn [c]
      (map op (fn [ctnts-c]
                (ctnts-c top-type)))))

  (found-constraint [c]
    (or (found-constraint (.param-consts c))
        (.result-const c)))

  (intersect [ar1 ar2]
    (assert (instance? fn-arity ar2))

    (let [param-cs (intersect (.param-consts ar1) (.param-consts ar2))
          result-c (intersect (.result-const ar1) (.result-const ar2))
          arity-id (cond (= no-symbol (.arity-id ar1))
                         (.arity-id ar2)

                         (.arity-id ar1))]
      (either (or (= bottom-type param-cs)
                  (= bottom-type result-c))

              (-> ar1
                  (.arity-id arity-id)
                  (.param-consts param-cs)
                  (.result-const result-c))))))

(defn intersect-fns [y x]
  (either (or (=* x y)
              (and (or (empty? (.arities x))
                       (empty? (.arities y)))
                   (maybe (NoValues [x y]))))
          (let [new-required (reduce (.required-arities x) (.required-arities y)
                                     (fn [new-reqd arity-rank]
                                       (cond (some new-reqd (partial = arity-rank))
                                             new-reqd

                                             (conj new-reqd arity-rank))))
                new-arities (reduce (for [[x-idx x-arity] (vec (.arities x))
                                          [y-idx y-arity] (vec (.arities y))
                                          :when (= x-idx y-idx)
                                          :let [new-arity (intersect x-arity y-arity)]
                                          :when-not (= bottom-type new-arity)]
                                      [x-idx new-arity])
                                    {} (fn [arities [idx arity]]
                                         (assoc arities idx arity)))
                min-variadic-arity (map (get new-arities variadic)
                                        (fn [var-arity]
                                          (-> var-arity .param-consts seq-items count)))
                new-arities (cond (empty? new-arities)
                                  (either (or (map (get-in x [.arities variadic])
                                                      (fn [x-var]
                                                        (reduce (vec (.arities y)) {}
                                                                (fn [arities [rank arity]]
                                                                  (let [new-arity (intersect x-var
                                                                                             arity)]
                                                                    (cond (= bottom-type new-arity)
                                                                          arities
                                                                          (assoc arities
                                                                            rank new-arity)))))))
                                                 (map (get-in y [.arities variadic])
                                                      (fn [y-var]
                                                        (reduce (vec (.arities x)) {}
                                                                (fn [arities [rank arity]]
                                                                  (let [new-arity (intersect y-var
                                                                                             arity)]
                                                                    (cond (= bottom-type new-arity)
                                                                          arities
                                                                          (assoc arities
                                                                            rank new-arity))))))))
                                          {})
                                  new-arities)]
            (cond (empty? new-arities)
                  (NoValues [x y])

                  (every new-required (fn [required]
                                        (or (get new-arities required)
                                            (flat-map min-variadic-arity (fn [min-var]
                                                                           (<= min-var required))))))
                  (-> x
                      (.required-arities new-required)
                      (.arities new-arities))

                  (NoValues [x y])))))

(extend-type FnConstraint
  Stringable
  (string-list [c]
    (let [long-form (list "(c/fn-c [" (to-str (interpose (.required-arities c) " ")) "]"
                          "\n" (str (.arities c)) ")")]
      (cond (= c fn-constraint)
            (list "c/fn-constraint")

            (= (.arities c) (.arities fn-constraint))
            (list "(.required-arities c/fn-constraint " (str (.required-arities c) ")"))

            (and (every (vals (.arities c)) (partial instance? fn-arity))
                 (= (count (.arities c)) (count (.arities fn-constraint))))
            (let [fn-str (cond (empty? (.required-arities c))
                               "c/fn-constraint"
                               (str "(.required-arities c/fn-constraint " (.required-arities c) ")"))
                  results (-> (.arities c)
                              vals
                              (map .result-const))]
              (either (flat-map (first results)
                                (fn [result]
                                  (or (and (= result top-type)
                                           (maybe (list fn-str)))

                                      (and (every results (partial = result))
                                           (maybe (list "(c/intersect " fn-str "\n(c/coll-of-c "
                                                        (str result) "))"))))))
                      long-form))

            long-form)))

  Constraint
  (type-num [c] FunctionType)

  (type-sym [_] Fn-sym)

  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* "Function from" (.path x) desired-len))

  (show-full [c]
    (comp (format-path c 0)
          ["---------"]
          (-> (.arities c)
              vals
              (interpose ["----"])
              flatten
              (map (partial str "  ")))))

  (derive-const [op]
    (fn [c]
      (let [derived (map op (fn [ctnts-c]
                              (ctnts-c top-type)))]
        (intersect derived c))))

  (found-constraint [c]
    (some (vals (.arities c)) identity))

  (find-param [c]
    (RecurseFinal nothing))

  (do-call-value [base args loc-path]
    (either (or (map (= no-args args)
                     (fn [_]
                       ;; get the sum type of the results of all the arities
                       (-> (.arities base)
                           vals
                           (reduce [] (fn [arities arity]
                                        (assert (instance? fn-arity arity))
                                        (conj arities (derive (.result-const arity) top-type))))
                           sum-type
                           (vector args))))
                ;; get the arity
                (map (or (get-in base [.arities (count args)])
                         (get-in base [.arities variadic]))
                     (fn [arity]
                       (assert (instance? fn-arity arity))

                       (let [arity-id (.arity-id arity)
                             fixed-count (-> arity .param-consts seq-items count)
                             [reqd var] (split args fixed-count)
                             new-args (conj reqd (list-c var))
                             reified (elgot skip-protoimpls
                                            (fn [c]
                                              (trim-const
                                               (reify-const c arity-id new-args)))
                                            ;; by reifying the entire arity, including
                                            ;; the params, dependencies between args are
                                            ;; checked.
                                            arity)]
                         (either (map (is-bottom reified)
                                      (fn [err-c]
                                        [err-c args]))
                                 ;; remove any remaining params of arity-id
                                 (elgot (fn [c]
                                          (either (for [ar-c (instance? fn-arity c)
                                                        :when (= (.arity-id ar-c) arity-id)]
                                                    (RecurseFinal ar-c))
                                                  (skip-protoimpls c)))
                                        (fn [c]
                                          (either (for [param-c (instance? ParamConstraint c)
                                                        :when (= (.arity param-c) arity-id)]
                                                    top-type)
                                                  c))
                                        [(.result-const reified)
                                         (get-items (.param-consts reified) (count args))]))))))
            [(NoValues [base (-> empty-reified
                                 (replace-path loc-path)
                                 (.type-symbol (tag "No arity found")))])
             args]))

  (intersect [x y]
    (cond (=* x y)
          x

          (or (instance? ParamConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? MultiConstraint y)
              (instance? SumConstraint y)
              (instance? ReifiedConstraint y)
              (instance? ProtoImpls y)
              (instance? TypeOp y)
              (and (instance? ReifiedConstraint y)
                   (= UnknownType (.type-number y))))
          (intersect y x)

          (instance? CollectionOf y)
          (let [new-result (.ctnts-c y)
                new-arities (-> (.arities x)
                                vec
                                (reduce {} (fn [arities [arity-idx arity]]
                                             (let [arity-r (intersect (.result-const arity)
                                                                      new-result)]
                                               (either (or (= arities bottom-type)
                                                           (= arity-r bottom-type))
                                                       (assoc arities
                                                         arity-idx (.result-const arity arity-r)))))))]
            (either (= new-arities bottom-type)
                    (.arities x new-arities)))

          (instance? FnConstraint y)
          (intersect-fns x y)

          (NoValues [x y]))))

(defn intersect-simple-container [x y]
  (either (for [_ (= (type-num x) (type-num y))
                cnts-x (get-in x [.fields contents])
                cnts-y (get-in y [.fields contents])]
            (let [new-cnts (either (or (= cnts-x no-contents)
                                       (= cnts-y no-contents))
                                   (intersect cnts-x cnts-y))]
              (either (= bottom-type new-cnts)
                      (assoc-in x [.fields contents] new-cnts))))

          (NoValues [x y])))

(defn intersect-int [x y]
  (either (for [min-x (get-in x [.fields min-key])
                max-x (get-in x [.fields max-key])
                static-x (get-in x [.fields static-value])
                min-y (get-in y [.fields min-key])
                max-y (get-in y [.fields max-key])
                static-y (get-in y [.fields static-value])
                :let [new-min (either (> min-x min-y)
                                      min-y)
                      new-max (either (< max-x max-y)
                                      max-y)]
                new-static (or (= static-x static-y)
                               (flat-map (or (= static-x static-y)
                                             (and (= static-x no-int)
                                                  (maybe static-y))
                                             (and (= static-y no-int)
                                                  (maybe static-x)))
                                         (fn [new-static]
                                           (and (<= new-min new-static new-max)
                                                (maybe new-static)))))]
            ;; TODO: use the path from the most restrictive constraint
            ;; determined by satisfied-by
            (.fields x {min-key new-min max-key new-max static-value new-static}))
          (NoValues [x y])))

(defn intersect-static [x y]
  (either (for [sv-x (get-in x [.fields static-value])
                sv-y (get-in y [.fields static-value])
                new-sv (or (= sv-x sv-y)
                           (and (instance? NoStatic sv-x)
                                (maybe sv-y))
                           (and (instance? NoStatic sv-y)
                                (maybe sv-x)))]
            (assoc-in x [.fields static-value] new-sv))
          (NoValues [x y])))

(def intersectors {IntegerType intersect-int
                   SymbolType intersect-static
                   SubStringType intersect-static
                   StringBufferType intersect-static
                   OpaqueType (fn [x y] (NoValues [x y]))
                   FutureType (fn [x y] (NoValues [x y]))
                   MaybeType intersect-simple-container
                   PromiseType (fn [x _] x)
                   AgentType (fn [x _] x)})

(defn intersect-reified [x y]
  (either (map (get intersectors (type-num x))
               (fn [f]
                 (f x y)))

          (let [new-fields (merge-with intersect (.fields x) (.fields y))]
            (either (some (vals new-fields) (partial = bottom-type))
                    (.fields x new-fields)))))

(defn format-static-value [c]
  (assert (instance? ReifiedConstraint c))

  (either (map (get (.fields c) static-value)
               (fn [sv]
                 (cond (or (= no-symbol sv)
                           (= no-int sv)
                           (= IntegerType (type-num c)))
                       (str sv " ")

                       (= SymbolType (type-num c))
                       (str "'" sv " ")

                       "")))
          ""))

(extend-type ReifiedConstraint
  Constraint
  (contents-constraint [c]
    (let [type-number (type-num c)]
      (either (or (map (or (= StringBufferType type-number)
                           (= SubStringType type-number))
                       (fn [_]
                         (str-inner c)))
                  (map (or (= AgentType type-number)
                           (= PromiseType type-number)
                           (= FutureType type-number))
                       (fn [_]
                         top-type))
                  (get-in c [.fields contents]))
              (NoValues [c not-container]))))

  (type-sym [c]
    (.type-symbol c))

  (type-num [c]
    (.type-number c))

  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (str (type-sym c) " " (format-static-value c) "from:")
                  (.path c) desired-len))

  (show-full [c]
    (list (str "Type: " (type-sym c))))

  (set-to [x fld-path fld-c]
    (cond (empty? fld-path)
          fld-c

          (either (for [fld (first fld-path)
                        field-check (get (.field-consts x) fld)
                        curr-field (get (.fields x) fld)
                        :let [new-field (set-to curr-field (rest fld-path) fld-c)
                              final-field (intersect field-check new-field)]
                        final-field (or (= bottom-type final-field)
                                        (= final-field new-field))]
                    (either (= bottom-type final-field)
                            (.fields x (assoc (.fields x) fld final-field))))
                  (cant-set-contents x fld-path))))

  (get-from [c fld-c]
    (either (or (get (.fields c) fld-c)
                (get (.field-consts c) fld-c))
            (NoValues [c (missing-field fld-c)])))

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [ctnts-c]
                           (ctnts-c top-type)))
                 c)))

  (found-constraint [c]
    (or (some (seq (.fields c)) (fn [[fld-c val-c]]
                                  (or (either (instance? Maybe fld-c)
                                              nothing)
                                      (either (instance? Maybe val-c)
                                              nothing))))
        (.invoke-fn c)))

  (do-call-value [base args loc-path]
    (let [[result-c arg-cs] (do-call-value (.invoke-fn base)
                                           (either (instance? NoArgs args)
                                                   (comp [base] args))
                                           loc-path)]
      [result-c (either (instance? NoArgs args)
                        (rest arg-cs))]))

  (intersect [x y]
    (let [type-number (type-num x)]
      (cond (=* x y)
            ;; TODO: the field values could fail to intersect
            x

            (or (instance? ParamConstraint y)
                (instance? AllValues y)
                (instance? NoValues y)
                (instance? MultiConstraint y)
                (instance? SumConstraint y)
                (instance? TypeOp y))
            (intersect y x)

            (instance? CollectionOf y)
            (either (or (map (or (= StringBufferType type-number)
                                 (= SubStringType type-number))
                             (fn [_]
                               (let [intersected (intersect (str-inner x) (.ctnts-c y))]
                                 (cond (= intersected bottom-type)
                                       (NoValues [x y])

                                       (multi [x (.ctnts-c y intersected)])))))
                        (and (or (= AgentType type-number)
                                 (= PromiseType type-number)
                                 (= FutureType type-number))
                             (maybe x))
                        (map (= UnknownType type-number)
                             (fn [_]
                               (assoc-in x [.fields contents]
                                         (intersect (get y .ctnts-c)
                                                    (either (get-in x [.fields contents])
                                                            top-type)))))
                        (for [cnts-x (or (get-in x [.fields contents])
                                         (and (= type-number HashSetType)
                                              (maybe top-type))
                                         (and (< type-number TypeCount)
                                              (maybe (NoValues [x not-container])))
                                         (maybe top-type))
                              cnts-y (get y .ctnts-c)]
                          (let [new-cnts (intersect cnts-x cnts-y)]
                            (either (= bottom-type new-cnts)
                                    (assoc-in x [.fields contents] new-cnts)))))

                    (NoValues [x y]))

            (instance? FnConstraint y)
            (let [new-arities (-> (.arities y)
                                  seq
                                  (reduce {}
                                          (fn [arities [rank arity]]
                                            (assoc arities (cond (= variadic rank)
                                                                 rank
                                                                 (inc rank))
                                                   (either (update-in arity [.param-consts]
                                                                      (partial seq-c [top-type]))
                                                           ;; should never happen
                                                           (do
                                                             (print-err "Invalid c/fn-arity" _LINE_
                                                                        lflf arity)
                                                             (abort)))))))
                  new-invoke (intersect-fns (.invoke-fn x)
                                            (-> y
                                                (.arities new-arities)
                                                (.required-arities (map (.required-arities y) inc))))]
              (either (= bottom-type new-invoke)
                      (.invoke-fn x new-invoke)))

            (instance? ReifiedConstraint y)
            (cond (= type-number (type-num y))
                  (intersect-reified x y)

                  (= UnknownType (type-num y))
                  (intersect y x)

                  (= UnknownType type-number)
                  (let [new-invoke (cond (= empty-fn-constraint (.invoke-fn x))
                                         (.invoke-fn y)

                                         (intersect-fns (.invoke-fn x)
                                                        (.invoke-fn y)))
                        [new-fields fail]
                        (-> (.fields x)
                            vec
                            (reduce [{} top-type]
                                    (fn [[new-fields fail] [fld fld-c]]
                                      (cond (= fail bottom-type)
                                            [new-fields fail]

                                            (either (map (get-in y [.fields fld])
                                                         (fn [fld-y-c]
                                                           (let [new-c (intersect fld-y-c fld-c)]
                                                             [(assoc new-fields fld new-c)
                                                              new-c])))
                                                    [new-fields (NoValues [x y])])))))]
                    (either (or (= bottom-type new-invoke)
                                (= bottom-type fail))
                            (-> y
                                (.fields (comp (.fields y) new-fields))
                                (.invoke-fn new-invoke))))

                  (NoValues [x y]))

            (either (and (= UnknownType type-number)
                         (or (map (get-in x [.fields contents])
                                  (fn [cnts]
                                    (intersect (coll-of-c cnts)
                                               y)))
                             (and (= (.type-symbol x) no-symbol)
                                  (maybe y))))
                    (NoValues [x y]))))))

(defn do-concat [base args loc-path]
  (let [new-base (intersect base (coll-of-c (sum-c [string-constraint
                                                    seq-constraint])))]
    (either (= bottom-type new-base)
            (cond (is-param base)
                  (TypeOp concat-op base no-args no-symbol loc-path)

                  (let [tail-seq (either (= no-tail (get-tail new-base))
                                         (coll-of-c (-> (get-tail new-base)
                                                        contents-constraint
                                                        contents-constraint)))
                        seqs (get-items new-base)
                        result-type (either (map (first seqs) .type-num)
                                            UnknownType)]
                    (-> (reverse seqs)
                        (reduce tail-seq
                                (fn [tail arg]
                                  (assert (instance? SeqConstraint arg))

                                  (let [arg (set-seq-type arg result-type)
                                        arg-tail (seq-tail arg)]
                                    (cond (= arg-tail no-tail)
                                          (set-seq-tail arg tail)

                                          (set-seq-tail arg
                                                        (coll-of-c
                                                         (sum-type [(contents-constraint arg-tail)
                                                                    (contents-constraint tail)])))))))
                        (set-seq-type result-type)))))))

(defn do-apply-value [base args loc-path]
  (assert-result r (instance? Vector r))

  ;; TODO: can this be simplified
  (cond (is-param args)
        [(TypeOp apply-op base args no-symbol loc-path) args]

        (or (instance? FnConstraint base)
            (instance? ReifiedConstraint base))
        (do-call-value base (get-items args) loc-path)

        (cond (is-param base)
              [(TypeOp apply-op base args no-symbol loc-path) args]

              (do-call-value base (get-items args) loc-path))))

(defn do-set-to [base [path v] loc-path]
  (cond (empty? path)
        base

        (= bottom-type v)
        v

        (or (instance? ParamConstraint base)
            (instance? TypeOp base))
        (type-op set-to-op base [path v])

        (or (instance? SeqConstraint base)
            (instance? ReifiedConstraint base))
        (set-to base path v)

        (or (instance? SumConstraint base)
            (instance? MultiConstraint base))
        (do
          (print-err 'time-to-fix _LINE_
                     "\n" 'base base
                     "\n\n" 'path path
                     "\n\n" 'v v)
          (abort))

        (NoValues [(type-op set-to-op top-type [path v] no-symbol loc-path) base])))

(defn do-get-from [base path loc-path]
  (cond (empty? path)
        base

        (or (instance? ParamConstraint base)
            (instance? TypeOp base))
        (type-op get-from-op base path)

        (or (instance? SeqConstraint base)
            (instance? ReifiedConstraint base))
        (either (map (first path)
                     (fn [fld]
                       (do-get-from (get-from base fld)
                                    (rest path)
                                    loc-path)))

                base)

        (or (instance? SumConstraint base)
            (instance? MultiConstraint base))
        (do
          (print-err 'time-to-fix _LINE_
                     "\n" 'base base
                     "\n\n" 'path path)
          (abort))

        (NoValues [(type-op get-from-op top-type path) base])))

(defn do-arg-of [base arg-pos loc-path]
  (cond (instance? FnConstraint base)
        (let [num-args (inc arg-pos)
              arity-args (-> (.arities base)
                             vals
                             (reduce [] (fn [arities arity]
                                          (assert (instance? fn-arity arity))

                                          (let [arity (reify-type-constraint arity (.arity-id arity)
                                                                             (repeat num-args top-type)
                                                                             no-loc)]
                                            (either (map (-> (.param-consts arity)
                                                             (get-items num-args)
                                                             (nth arg-pos))
                                                         (partial conj arities))
                                                    arities)))))]
          (cond (empty? arity-args)
                (NoValues [(type-op arg-of-op top-type arg-pos) base])

                (sum-type arity-args)))

        (instance? ReifiedConstraint base)
        (do-arg-of (.invoke-fn base)
                   (inc arg-pos)
                   loc-path)

        (instance? ProtoImpls base)
        (do-arg-of (.default-impl base) arg-pos loc-path)

        (cond (is-param base)
              (TypeOp arg-of-op base arg-pos no-symbol loc-path)

              (NoValues [(type-op arg-of-op top-type arg-pos) base]))))

(defn seq-from-str [c seq-type]
  (either (map (get-in c [.fields static-value])
               (fn [static]
                 (cond (= static no-string)
                       (seq-c [] (coll-of-c substr-constraint) seq-type)
                       (seq-c (map (vec static)
                                   (fn [s]
                                     (assoc-in substr-constraint [.fields static-value]
                                               s)))
                              no-tail
                              seq-type))))
          (seq-c [] (coll-of-c substr-constraint) seq-type)))

(defn seq-from-hashmap [c seq-c]
  ;; TODO: unfinished
  coll-of-any)

(defn get-last [base params loc-path]
  ;; (assert-result r (instance? (any-of MaybeConstraint
  ;;                                     TypeOp
  ;;                                     NoValues)
  ;;                             r))
  (cond (instance? SeqConstraint base)
        (cond (empty-seq? base)
              nothing-constraint

              (= (.tail base) no-tail)
              (MaybeConstraint (.item base))

              (instance? CollectionOf (.tail base))
              (MaybeConstraint (contents-constraint (.tail base)))

              (get-last (.tail base) params loc-path))

        (and (instance? ReifiedConstraint base)
             (or (= (.type-number base) StringBufferType)
                 (= (.type-number base) SubStringType)))
        (either (map (get-in base [.fields static-value])
                     (fn [sv]
                       (either (map (last sv)
                                    (fn [first-char]
                                      (MaybeConstraint
                                       (SubStrConstraint first-char))))
                               nothing-constraint)))
                (MaybeConstraint substr-constraint))

        (and (instance? ReifiedConstraint base)
             (= (.type-number base) UnknownType))
        maybe-constraint

        (instance? CollectionOf base)
        (MaybeConstraint (.ctnts-c base))

        (cond (is-param base)
              (TypeOp last-of-op base params no-symbol loc-path)

              (NoValues [(type-op last-of-op top-type params) base]))))

(defn get-rest [base params loc-path]
  (cond (instance? SeqConstraint base)
        (cond (or (= no-tail (.tail base))
                  (instance? CollectionOf (.tail base)))
              (.item base no-tail)

              (.tail base))

        (and (instance? ReifiedConstraint base)
             (or (= (.type-number base) StringBufferType)
                 (= (.type-number base) SubStringType)))
        (either (map (get-in base [.fields static-value])
                     (fn [sv]
                       (SubStrConstraint (rest sv))))
                substr-constraint)

        (and (instance? ReifiedConstraint base)
             (= (.type-number base) UnknownType))
        (type-op rest-of-op top-type params)

        (instance? CollectionOf base)
        base

        (cond (is-param base)
              (TypeOp rest-of-op base params no-symbol loc-path)

              (NoValues [(type-op rest-of-op top-type params) base]))))

(defn do-seq-from [seq-type base loc-path]
  (cond (instance? SeqConstraint base)
        (-> base
            (.tail (either (= no-tail (.tail base))
                           (do-seq-from seq-type (.tail base) loc-path)))
            (set-seq-type seq-type))

        (and (instance? ReifiedConstraint base)
             (or (= (.type-number base) StringBufferType)
                 (= (.type-number base) SubStringType)))
        (seq-from-str base seq-type)

        (and (instance? ReifiedConstraint base)
             (or (= (.type-number base) BitmapIndexedType)
                 (= (.type-number base) ArrayNodeType)
                 (= (.type-number base) HashCollisionNodeType)))
        (-> (seq-from-hashmap base empty-list-constraint)
            (.path (.path base)))

        (and (instance? ReifiedConstraint base)
             (= (.type-number base) UnknownType))
        (type-op list-from-op top-type no-args)

        (instance? CollectionOf base)
        (.type-num (seq-c [] base) seq-type)

        (cond (is-param base)
              (TypeOp list-from-op base no-args no-symbol loc-path)

              (NoValues [(type-op list-from-op top-type no-args) base]))))

(def type-op-fn {inner-type-of-op (fn [base _ loc-path]
                                    (contents-constraint base))
                 first-of-op (fn [base params loc-path]
                               (cond (instance? SeqConstraint base)
                                     (either (map (first (get-items base 1))
                                                  MaybeConstraint)
                                             nothing-constraint)
                                     
                                     (and (instance? ReifiedConstraint base)
                                          (or (= (.type-number base) StringBufferType)
                                              (= (.type-number base) SubStringType)))
                                     (either (map (get-in base [.fields static-value])
                                                  (fn [sv]
                                                    (either (map (first sv)
                                                                 (fn [first-char]
                                                                   (MaybeConstraint
                                                                    (SubStrConstraint first-char))))
                                                            nothing-constraint)))
                                             (MaybeConstraint substr-constraint))

                                     (and (instance? ReifiedConstraint base)
                                          (= (.type-number base) UnknownType))
                                     maybe-constraint

                                     (instance? CollectionOf base)
                                     (MaybeConstraint (.ctnts-c base))

                                     (cond (is-param base)
                                           (TypeOp first-of-op base params no-symbol loc-path)

                                           (NoValues [(type-op first-of-op top-type params) base]))))
                 last-of-op get-last
                 rest-of-op get-rest
                 butlast-of-op (fn [base params loc-path]
                                 (cond (instance? SeqConstraint base)
                                       (cond (= (seq-tail base) no-tail)
                                             (.type-num (seq-c (butlast (seq-items base)))
                                                        (.type-num base))

                                             base)

                                       (and (instance? ReifiedConstraint base)
                                            (or (= (.type-number base) StringBufferType)
                                                (= (.type-number base) SubStringType)))
                                       (either (map (get-in base [.fields static-value])
                                                    (fn [sv]
                                                      (SubStrConstraint (butlast sv))))
                                               substr-constraint)

                                       (and (instance? ReifiedConstraint base)
                                            (= (.type-number base) UnknownType))
                                       (type-op butlast-of-op top-type params)

                                       (instance? CollectionOf base)
                                       base

                                       (cond (is-param base)
                                             (TypeOp butlast-of-op base params no-symbol loc-path)

                                             (NoValues [(type-op butlast-of-op top-type params) base]))))
                 list-from-op (fn [base params loc-path]
                                (do-seq-from ListType base loc-path))
                 vect-from-op (fn [base params loc-path]
                                (do-seq-from VectorType base loc-path))
                 arg-of-op do-arg-of
                 get-from-op do-get-from
                 set-to-op do-set-to
                 call-value-op (fn [base args loc-path]
                                 (let [[result-type] (do-call-value base args loc-path)]
                                   result-type))
                 concat-op do-concat
                 apply-op (fn [base args loc-path]
                                 (let [[result-type] (do-apply-value base args loc-path)]
                                   result-type))})

(def type-op-msg {inner-type-of-op (constantly "Inner type of value from")
                  first-of-op (constantly "First value of seq")
                  last-of-op (constantly "Last value of seq")
                  rest-of-op (constantly "Rest of seq")
                  butlast-of-op (constantly "All but the last value of seq")
                  list-from-op (constantly "List from value")
                  vect-from-op (constantly "Vector from value")
                  ;; TODO: make these fns that take a parameter
                  arg-of-op (constantly (str "Argument ?? of"))
                  call-value-op (fn [c] "Called at ")})

(extend-type TypeOp
  Container
  (map [tc f]
    (cond (= (.op-code tc) set-to-op)
          (let [[path v] (.params tc)]
            (-> tc
                (.base (f (.base tc)))
                (.params [(map path f) (f v)])))

          (or (instance? Constraints (.params tc))
              (instance? Vector (.params tc)))
          (-> tc
              (.base (f (.base tc)))
              (.params (map (.params tc)
                            (fn [param]
                              (cond (instance? Integer param)
                                    param

                                    (f param))))))

          (.base tc (f (.base tc)))))

  (map [tc f embed]
    (cond (= (.op-code tc) set-to-op)
          (let [[path v] (.params tc)]
            (for [new-base (f (.base tc))
                  new-path (map path f embed)
                  new-v (f v)]
              (-> tc
                  (.base new-base)
                  (.params [new-path new-v]))))

          (or (instance? Constraints (.params tc))
              (instance? Vector (.params tc)))
          (for [new-base (f (.base tc))
                new-params (cond (instance? Constraints (.params tc))
                                 (f (.params tc))

                                 (map (.params tc)
                                      (fn [param]
                                        (cond (instance? Integer param)
                                              (embed param)

                                              (f param)))
                                      embed))]
            (-> tc
                (.base new-base)
                (.params new-params)))

          (map (f (.base tc))
               (partial .base tc))))

  Constraint
  (type-num [c]
    (type-num (trim (derive c top-type))))

  (trim-const [c]
    (reify-const c no-symbol []))

  (contents-constraint [c]
    (.base inner-type-of c))

  (found-constraint [c]
    (or (.base c)
        (and (instance? Vector (.params c))
             (some (.params c) (fn [param]
                                 (cond (instance? Vector param)
                                       (some param identity)
                                       param))))
        (either (instance? Maybe (.params c))
                nothing)))

  (derive-const [op]
    (fn [c]
      (let [op (map op (fn [f]
                         (f top-type)))]
        (intersect c op))))

  (reify-const [c arity-id arg-cs]
    (let [base (.base c)
          op-code (.op-code c)]
      (cond (or (instance? AllValues base)
                (instance? NoValues base))
            base

            (either (map (get type-op-fn op-code)
                         (fn [f]
                           (cond (instance? MultiConstraint base)
                                 (reduce (.constraints base) top-type
                                         (fn [old-c inner]
                                           (intersect old-c (reify-const (.base c inner)
                                                                         arity-id arg-cs))))

                                 (instance? SumConstraint base)
                                 (-> (.alts base)
                                     (map (fn [alt]
                                            (reify-const (.base c alt) arity-id arg-cs)))
                                     sum-type)

                                 (f base (.params c) (.path c)))))
                    top-type))))

  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (either (map (get type-op-msg (.op-code c))
                               (fn [msg-f]
                                 (msg-f c)))
                          (str "Type operation" (.op-code c)))
                  (.path c) desired-len))

  (show-full [c]
    (format-path c 0))

  (intersect [x y]
    (cond (or (instance? AllValues y)
              (instance? NoValues y)
              (instance? MultiConstraint y))
          (intersect y x)

          (multi [x y]))))

(extend-type Field
  Constraint
  (show-full [c]
    (list "Field " (str (.sym c)))))

(extend-type TypeOfConstraint
  Constraint
  (assertion-path [c] (.path c))

  (find-param [c]
    (RecurseFinal (maybe c)))

  (format-path [c desired-len]
    (format-path* "Type of value from" (.path c) desired-len))

  (show-full [c]
    (string-list c)))

(extend-type ProtoImpls
  Constraint
  (skip-protoimpls [c]
    (RecurseFinal c))

  (set-path [c new-path]
    (RecurseFinal c))

  (find-param [c]
    (RecurseFinal nothing))

  (derive-const [op]
    (fn [c]
      (let [derived (map (.default-impl op) (fn [f]
                                              (f top-type)))]
        (intersect c derived))))

  (show-full [c]
    (comp (list (str "prototype " (.fn-sym c)))
          (show-full (.default-impl c))
          (list (str (map-vals (.impl-fns c) (fn [x]
                                               (to-str (interpose x "\n"))))))))

  (format-path [x n]
    (format-path (.default-impl x) n))

  (assertion-path [x]
    (assertion-path (.default-impl x)))

  (do-call-value [base args loc-path]
    (either (or (and (= args no-args)
                     (maybe (do-call-value (.default-impl base) args loc-path)))
                (map (first args)
                     (fn [disp-arg]
                       (let [arg-count (count args)]
                         (either (map (get-in base [.impl-fns (type-num disp-arg)])
                                      (fn [f]
                                        (let [[res new-args] (do-call-value f args loc-path)]
                                          (cond (is-param res)
                                                [(type-op call-value-op f args)
                                                 new-args]

                                                [res new-args]))))
                                 (let [[res new-args] (do-call-value (.default-impl base)
                                                                     args loc-path)]
                                   (cond (or (is-param res)
                                             (is-param disp-arg))
                                         [(type-op call-value-op (.impl-fns base {}) args)
                                          new-args]

                                         [res new-args])))))))
            [(NoValues [base (-> empty-reified
                                 (replace-path loc-path)
                                 (.type-symbol (tag "Insufficient number of arguments.")))])
             args]))

  (intersect [x y]
    (cond (= x y)
          x

          (instance? MultiConstraint y)
          (intersect y x)

          (either (= bottom-type (intersect (.default-impl x) y))

                  (cond (= top-type y)
                        x
                        (multi [x y]))))))

;; misc
;; Going to try and do without these
;; DebugConstraint

(def core-type-constraints {Integer-sym int-constraint
                            StringBuffer-sym strbuff-constraint
                            SubString-sym substr-constraint
                            FnArity-sym arity-constraint
                            BitmapIndexedNode-sym bitmap-constraint
                            ArrayNode-sym array-constraint
                            HashCollisionNode-sym hash-coll-constraint
                            Fn-sym fn-constraint
                            List-sym list-constraint
                            Maybe-sym maybe-constraint
                            Vector-sym vect-constraint
                            Symbol-sym sym-constraint
                            HashMap-sym hashmap-constraint
                            Promise-sym promise-constraint
                            Future-sym future-constraint
                            Agent-sym agent-constraint
                            Opaque-sym opaque-constraint})

;; combine two constraints to produce a new constraint
;; that is the same or more restrictive than either constraint
