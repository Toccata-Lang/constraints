
;; TODO: add a Hole constraint to print information

(def SymbolOrString (any-of Symbol
                            String))

(deftype Location [file line]
  (assert (instance? SymbolOrString file))
  (assert (instance? Integer line))

  Stringable
  (string-list [_]
    (list (either (and (= file 'core)
                       (maybe "core"))
                  (str file))
          ": " (str line)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def default-old-extract-items-constraints)

(def TypeMap (map-of Integer (set-of Symbol)))

(def top-type)
(def bottom-type)
(def type-map)

(def always-nothing -1)
(def never-nothing -2)

;; Public interface for Constraints
(defprotocol Constraint
  (assertion-path [x])

  ;; Ensure constraint is as small as possible
  (trim [c]
    c)

  (set-path [c new-path]
    (assert (instance? (list-of Vector) new-path))
    (assert-result r (instance? Either r))

    (Right c))

  (dynamic-fields [c]
    c)

  (dynamic-params [c]
    (assert-result r (instance? Vector r))

    [])

  (type-map [new old]
    (assert-result r (instance? (maybe-of TypeMap) r))

    ;; TODO: c-exprs from Toccata might show up here and we can extract constraint info from them
    ;; but for noew, just ignore them
    nothing)

  (add-to-path [constraint file-name line-number]
    constraint)

  (remove-sym [c]
    (assert-result r (instance? Either r))

    (Right c))

  (contents-constraint [_])

  (collection-of [_]
    ;; extract CollectionOf constraint
    )

  (coll-constraint [_]
    ;; extract the CollectionOf or the InferredInner constraints
    ;; returns either an AllValues or CollectionOf constraint
    )

  (intersect [c1 c2])

  (format-path [x n]
    (assert-result r (instance? (list-of String) r)))

  (restrict-types [c types-map]
    (either (map (para type-map c)
                 (fn [c-type-map]
                   (select-keys types-map (keys c-type-map))))
            types-map))

  (is-collection? [c]
    nothing)

  (get-tail-constraint [c x]
    bottom-type)

  (fixed-items-constraints [c x]
    (assert-result r (instance? Vector r))
    [])

  ;; TODO: still need to replace this
  (old-extract-items-constraints [c n]
    (assert (instance? Integer n))
    (assert-result r (instance? Vector r)))

  (extract-sym [tc]
    (assert-result r (instance? (maybe-of Symbol) r))

    nothing)

  (update-sym [tc new-sym]
    (assert (instance? Symbol new-sym)))

  (extract-var [c]
    (assert-result var (instance? String var)))

  (clear-var [c]
    c)

  (update-var [c new-var]
    (assert (instance? String new-var)))

  (set-type-name [c new-name]
    c)

  ;; This is only used for calls to seq and vec. And there's not enough benefit to
  ;; implementing them with recursion schemes
  (set-type [c tc]
    (intersect c tc))

  (satisfied-by [c info]
    (assert-result r (instance? Maybe r))

    nothing))

;; (defn extract-collection-of [c]
;;   (let [x (old-extract-collection-of c)
;;         y (cata collection-of c)]
;;     (or (= x y)
;;         (maybe (print-err 'diff-coll-of c "\n\n" x "\n\n" y)))
;;     y))

(defn extract-tail-constraint [c]
  (para (comp trim get-tail-constraint)
        ;; TODO: remove this trim evenutally
        (trim c)))

(defn extract-items-constraints
  ([c]
   (para (comp trim fixed-items-constraints)
         ;; TODO: remove this trim evenutally
         (trim c)))
  ([c n]
   (old-extract-items-constraints c n)))

(defn update-type-name [c new-name]
  (cata (fn [c]
          (set-type-name c new-name))
        c))

(defn extract-collection-of [c]
  (elgot collection-of trim c))

(defn extract-coll-constraint [c]
  (elgot coll-constraint trim c))

(defn extract-contents-constraint [c]
  (apo (fn [c]
         (-> c
             contents-constraint
             (map trim)))
       c))

(defn extract-dynamic-fields [c]
  (cata dynamic-fields c))

(defn replace-path [c new-path]
  (apo (fn [c]
         (set-path c new-path))
       c))

(defn update-path
  ([c loc]
   (assert (instance? Location loc))
   (update-path c (.file loc) (.line loc)))

  ([c file-name line-number]
   (cata (fn [c]
           (add-to-path c file-name line-number))
         c)))

(defn clear-sym [c]
  (apo remove-sym c))

(defn extract-type-map [c]
  (para type-map c))

(defn extract-dynamic-params [c]
  (cata dynamic-params c))

(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -2, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FunctionType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MaybeType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ListType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SymbolType};"))
(def BitmapIndexedType (inline C Integer "(Value *)&(Integer){IntegerType, -2, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ArrayNodeType};"))
(def HashCollisionNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -2, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, OpaqueType};"))
(def TypeConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeConstraintType};"))
(def NoValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, NoValuesType};"))
(def AllValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AllValuesType};"))
(def MultiConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MultiConstraintType};"))
(def ResultConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ResultConstraintType};"))
(def ItemsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ItemsConstraintType};"))
(def FieldConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FieldConstraintType};"))
(def StaticIntConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StaticIntConstraintType};"))
(def MinValueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MinValueType};"))
(def MaxValueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MaxValueType};"))
(def InferredInnerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InferredInnerType};"))
(def StaticLengthConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2,
    StaticLengthConstraintType};"))
(def StaticStrConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StaticStrConstraintType};"))
(def ContentsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ContentsConstraintType};"))
(def HashSetType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashSetType};"))
(def ProtoDispatcherType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ProtoDispatcherType};"))
(def FloatType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FloatType};"))
(def SumConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SumConstraintType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeCount};"))

(defn extract-key-constraint [c]
  (either (flat-map (extract-type-map c)
                    (fn [types-map]
                      (and (or (get types-map BitmapIndexedType)
                               (get types-map ArrayNodeType)
                               (get types-map HashCollisionNodeType))
                           (-> c
                               extract-contents-constraint
                               extract-items-constraints
                               first))))

          top-type))

;; TODO: constraints to add
;; number of args the target of a call takes
;; min count (instead of ItemsConstraint)
;; keys required in a hash map

(defn format-path* [path desired-len]
  (assert (instance? List path))
  (assert (instance? Integer desired-len))

  (either (map (first path)
               (fn [[header]]
                 (let [path (-> (rest path)
                                (remove (fn [[file line]]
                                          (either (and (instance? Symbol file)
                                                       (maybe nothing))
                                                  (or (empty? file)
                                                      (= 0 line)))))
                                (map (fn [[file line]]
                                       (let [file (str file)]
                                         (str (either (-> file
                                                          str
                                                          (split-string (partial = "/"))
                                                          last
                                                          (map (fn [file]
                                                                 (either (and (flat-map (first file)
                                                                                        (partial = "/"))
                                                                              (maybe file))
                                                                         file))))
                                                      file)
                                              ": " line)))))
                       max-width (reduce path (count header)
                                         (fn [max s]
                                           (let [n (count s)]
                                             (either (> max n)
                                                     n))))
                       path (either (and (< (count path) desired-len)
                                         (maybe (comp path (repeat (- desired-len (count path))
                                                                   (spaces max-width)))))
                                    path)]
                   (map (cons header path)
                        (fn [x]
                          (str x (spaces (- max-width (count x)))))))))
          path))

(deftype AllValues [var]
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(AllValues " (str "\"" var "\"") ")"))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (maybe x)))

  Constraint
  (clear-var [c]
    (.var c ""))

  (satisfied-by [_ c] (maybe c))
  (intersect [_ c] c)
  (update-sym [x _] x)
  (add-to-path [x _ _] x)
  (extract-var [_] var)
  (update-var [x v] (AllValues v))
  (collection-of [x] (Left x)))

(def top-type (AllValues ""))

(defn sym-str [s]
  (either (map s (fn [s]
                   (str "(maybe '" s ")")))
          "nothing"))

;; InferredInner is a weaker version of CollectionOf
(deftype InferredInner [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(InferredInner " (str contents) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (is-collection? [c]
    (maybe c))

  (assertion-path [_] path)

  (format-path [x desired-len]
    (format-path* (cons ["Contents restriction from" ""] path)
                  desired-len)))

;; CollectionOf is a stronger version of InferredInner
(deftype CollectionOf [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(CollectionOf " (str contents) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (is-collection? [c]
    (maybe c))

  (update-var [c new-var]
    (.var c new-var))

  (assertion-path [_] path)

  (format-path [x desired-len]
    (format-path* (cons ["Contents from" ""] path)
                  desired-len)))

(def coll-of-any (CollectionOf top-type empty-list nothing ""))

(deftype ItemsConstraint [items-constraints tail-constraint path sym var]
  (assert (instance? Vector items-constraints))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(ItemsConstraint [" (to-str (interpose items-constraints "\n"))
          "]\n" (str tail-constraint) "\n(list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" "\")"))

  Constraint
  (is-collection? [c]
    (maybe c))

  (trim [ic]
    (either (map (instance? ItemsConstraint tail-constraint)
                 (fn [tail-c]
                   (-> ic
                       (.items-constraints (comp items-constraints
                                                 (.items-constraints tail-c)))
                       (.tail-constraint (.tail-constraint tail-c)))))
            ic))

  (set-type [c tc]
    (-> c
        (.tail-constraint (set-type (.tail-constraint c) tc))
        (intersect tc)))

  (assertion-path [_] path)

  (type-map [_ _]
    (maybe {ListType #{}
            VectorType #{}
            BitmapIndexedType #{}
            ArrayNodeType #{}
            HashCollisionNodeType #{}}))

  (format-path [x desired-len]
    (format-path* (cons ["Sequence from" ""] path)
                  desired-len)))

(deftype TypeConstraint [type-maps path type-sym sym var]
  (assert (instance? TypeMap type-maps))
  (assert (instance? (list-of Vector) path))
  ;; 'type-sym' has to be more relaxed so it can accept an ast/tagged-symbol
  ;; (assert (instance? Symbol type-sym))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(TypeConstraint "  (str type-maps) " "
          (str (cons 'list path))
          (str " '" type-sym) " " (sym-str sym)
          " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (for [_ (instance? TypeConstraint y)
          y-maps (get y .type-maps)
          _ (= type-maps y-maps)]
      x))

  Constraint
  (set-type-name [c new-name]
    (.type-sym c new-name))

  (assertion-path [_] path)

  (type-map [_ _]
    (maybe type-maps))

  (format-path [x desired-len]
    (format-path* (cons [(str "Type '" type-sym "' from") ""]
                        path)
                  desired-len)))

(deftype FieldConstraint [field field-var path sym var]
  (assert (instance? Symbol field))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(FieldConstraint (symbol \"" (str field) "\") \"" (str field-var) "\" (list"
          (either (map (first path) (fn [[f l]]
                                      (let [f (str f)]
                                        (str "[\"" (either (map (> (count f) 15)
                                                                (fn [len]
                                                                  (subs f (- len 15))))
                                                           f)
                                             "\" " l "]"))))
                  "")
          ") " (sym-str sym)
          " \"" (str var) "\")"))

  Constraint
  (assertion-path [_] path)

  (restrict-types [c types-map]
    (reduce (seq types-map) {}
            (fn [types-map [type-num field-set]]
              (either (map (field-set field)
                           (fn [_] (assoc types-map type-num field-set)))
                      types-map))))

  (format-path [x desired-len]
    (format-path* (cons [(str "Field '" (subs (str field) 1) "' required from") ""]
                        path)
                  desired-len)))

(deftype StaticIntConstraint [val path sym var]
  (assert (instance? Integer val))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(StaticIntConstraint " (str val) " (list"
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (satisfied-by [c info]
    (= c info))

  (assertion-path [c] path)

  (format-path [x desired-len]
    (format-path* (cons [(str "Integer value '" val "' from") ""] path)
                  desired-len))

  (type-map [_ _]
    (maybe {IntegerType #{}})))

(deftype MinValue [min path sym var]
  (assert (instance? Integer min))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(MinValue " (str min) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (assertion-path [_] path)

  (type-map [_ _]
    (maybe {IntegerType #{}}))

  (format-path [x desired-len]
    (format-path* (cons [(str "Min value of " min " from") ""] path)
                  desired-len))

  (update-var [c new-var]
    (.var c new-var))

  (intersect [mvc c]
    (either (= mvc c)
            (intersect (update-var c (extract-var mvc)) mvc))))

(deftype MaxValue [max path sym var]
  (assert (instance? Integer max))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(MaxValue " (str max) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (assertion-path [_] path)

  (type-map [_ _]
    (maybe {IntegerType #{}}))

  (format-path [x desired-len]
    (format-path* (cons [(str "Max value of " max " from") ""] path)
                  desired-len)))

(deftype StaticLengthConstraint [length path sym var]
  (assert (instance? Integer length))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [c]
    (list "(StaticLengthConstraint " (str length) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (assertion-path [c] path)

  (format-path [x desired-len]
    (format-path* (cons [(str "Length from") ""]
                          (.path x))
                    desired-len))

  (type-map [_ _]
    (maybe {ListType #{}
            VectorType #{}})))

(deftype StaticStrConstraint [val path sym var]
  (assert (instance? String val))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(StaticStrConstraint " val " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (is-collection? [c]
    (maybe c))

  (satisfied-by [c info]
    (= c info))

  (format-path [x desired-len]
    (format-path* (cons ["String from" ""] path)
                  desired-len))

  (type-map [_ _]
    (maybe {StringBufferType #{}
            SubStringType #{}}))

  (assertion-path [c] path))

(def StaticConstraints (any-of StaticLengthConstraint
                               StaticStrConstraint
                               StaticIntConstraint))

;; TODO: add 'typ-sym' and make it a be optional for all constraints
(deftype SumConstraint [alts path sym var]
  (assert (instance? Vector alts))
  (assert (instance? (min-count 1) alts))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? (list-of Vector) path))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list (str "(SumConstraint " (str alts) " (list"
               (either (map (first path) (fn [[f l]]
                                           (str "[\"" f "\" " l "]")))
                       "") ") " (either (map sym str) 'nothing) " "
                       (str "\"" var "\"") ")")))

  Eq
  (=* [x y]
    (and (instance? SumConstraint y)
         (= (count alts) (count (.alts y)))
         (every (.alts y) (fn [c]
                            (some alts (partial =* c))))
         (maybe x)))

  Constraint
  (assertion-path [x] path)

  (format-path [_ n]
    (format-path* (cons ["Sum Type from" ""] path)
                  n))

  (type-map [c _]
    (let [alt-maps (.alts c)]
      (assert (instance? (vector-of (maybe-of TypeMap)) alt-maps))

      (and (some alt-maps identity)
           (apply (maybe comp) (filter alt-maps identity)))))

  (extract-var [c]
    var)

  (update-var [c new-var]
    (-> c
        (.alts (map (.alts c) (fn [c]
                                (update-var c new-var))))
        (.var new-var)))

  (satisfied-by [c info]
    (or (and (instance? SumConstraint info)
             (every (.alts info)
                    (fn [info-c]
                      (some (.alts c)
                            (fn [c-c]
                              (satisfied-by c-c info-c))))))
        (some alts (fn [c]
                     (satisfied-by c info))))))

(deftype DynamicFields [path sym var]
  Stringable
  (string-list [_]
    (list "(DynamicFields "
          (str " " (cons 'list path)) " " (either (map sym (fn [s]
                                                          (str "(maybe '" s ")")))
                                               "nothing")
          " " (str "\"" var "\"")
          ")"))

  Eq
  (=* [x y]
    (and (instance? DynamicFields y)
         (maybe x))))

(deftype DynamicParamConstraint [param-index path sym var result-type]
  Stringable
  (string-list [_]
    (list "(DynamicParamConstraint " (str param-index)
          (str " " (cons 'list path)) " " (either (map sym (fn [s]
                                                          (str "(maybe '" s ")")))
                                               "nothing")
          " " (str "\"" var "\"")
          " " (str result-type)
          ")"))

  Constraint
  (dynamic-params [c]
    [c])

  Eq
  (=* [x y]
    (and (instance? DynamicParamConstraint y)
         (= param-index (.param-index y))
         (= result-type (.result-type y))
         (maybe x))))

(deftype DynamicItemConstraint [param-index item-index path sym var]
  Stringable
  (string-list [_]
    (list "(DynamicItemConstraint " (str param-index) " " (str item-index)
          (str " " (cons 'list path)) " " (either (map sym (fn [s]
                                                             (str "(maybe '" s ")")))
                                                  "nothing")
          " " (str "\"" var "\"")
          ")"))

  Constraint
  (dynamic-params [c]
    [c])

  Eq
  (=* [x y]
    (and (instance? DynamicItemConstraint y)
         (= param-index (.param-index y))
         (= item-index (.item-index y))
         (maybe x))))

(deftype DynamicResultConstraint [invokable-c num-args path sym var]
  Stringable
  (string-list [_]
    (list "(DynamicResultConstraint " (str invokable-c) " " (str num-args)
          (str " " (cons 'list path)) " " (either (map sym (fn [s]
                                                             (str "(maybe '" s ")")))
                                                  "nothing")
          " " (str "\"" var "\"") ")"))

  Eq
  (=* [x y]
    (and (instance? DynamicResultConstraint y)
         (= invokable-c (.invokable-c y))
         (maybe x)))

  Constraint
  (format-path [x desired-len]
    (format-path* (cons ["Dynamic Result at" ""] path)
                  desired-len)))

(deftype ReifiedFields [field-cs path sym var]
  (assert (instance? Vector field-cs))

  Stringable
  (string-list [_]
    (list "(ReifiedFields " (str (vec (interpose field-cs "\n")))
          (str " " (cons 'list path)) " " (either (map sym (fn [s]
                                                             (str "(maybe '" s ")")))
                                                  "nothing")
          " " (str "\"" var "\"")
          ")"))

  Eq
  (=* [x y]
    (and (instance? ReifiedFields y)
         (= field-cs (.field-cs y))
         (maybe x)))

  Constraint
  (intersect [c1 c2]
    (let [new-c (intersect c2 c1)]
      (print-err 'new-c new-c)
      new-c)))

(def DynamicConstraint (any-of DynamicParamConstraint
                               DynamicFields
                               ReifiedFields
                               DynamicItemConstraint
                               DynamicResultConstraint))

;; Minimum Constraint Implementations
;; (deftype DynamicParamConstraint [param-index]
;;   Stringable
;;   (string-list [_]
;;     (list "(DynamicParamConstraint " (str param-index ")")))

;;   c/Constraint
;;   (c/intersect [c1 c2] c2)
;;   (c/satisfied-by [_ c] (maybe c))
;;   (c/intersect [_ c] c)
;;   (c/old-clear-sym [x] x)
;;   (c/update-sym [x _] x)
;;   (c/update-var [x v] x)
;;   (c/extract-collection-of [x] c/top-type)
;;   (c/old-extract-type-map [_] nothing)
;;   (c/extract-contents-constraint [_] c/top-type)
;;   (c/extract-coll-constraintraint [_] c/top-type)

;;   c/ConstraintOps
;;   (c/intersect-typec [c tc] tc)
;;   (c/intersect-multi [c mc] mc))

(def SymbolConstraints (any-of TypeConstraint
                               MinValue
                               MaxValue
                               InferredInner
                               StaticConstraints
                               ItemsConstraint
                               CollectionOf
                               FieldConstraint
                               SumConstraint
                               DynamicConstraint))

(deftype NoValues [constraints]
  Stringable
  (string-list [_]
    (list "(NoValues [" (to-str (interpose constraints "\n")) "])"))

  Constraint
  (intersect [nv _] nv)
  (update-sym [x _] x)
  (update-var [x _] x)
  (collection-of [x] (Left x))

  (trim [c]
    (.constraints c (comp (remove constraints (partial instance? NoValues))
                          (-> constraints
                              (filter (partial instance? NoValues))
                              (flat-map .constraints)))))

  (format-path [c n]
    (let [max-len (-> (trim c)
                      .constraints
                      (map (fn [c] (count (assertion-path c))))
                      (reduce n (fn [max-len path-len]
                                  (either (> max-len path-len)
                                          path-len)))
                      inc)]
      (-> constraints
          (map (fn [c]
                 (format-path c max-len)))
          (list-zipper empty-list)
          (map (fn [strs]
                 (str (to-str (interpose strs "    "))
                      "\n"))))))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (or (and (empty? constraints)
                  (maybe y))
             (maybe x)))))

(def bottom-type (NoValues []))

(extend-type Integer
  Constraint
  (intersect [x c]
    (intersect (StaticIntConstraint x empty-list nothing (extract-var c)) c)))

(extend-type String
  Constraint
  (intersect [x c]
    (intersect (StaticStrConstraint x empty-list nothing (extract-var c)) c)))

(extend-type Symbol
  Constraint
  (assertion-path [_] empty-list)

  (format-path [_ desired-len]
    (format-path* (list ["Symbol from" ""])
                  desired-len))

  (type-map [_ _]
    (maybe {SymbolType #{}}))

  (intersect [slc c]
    (either (or (= slc c)
                (and (instance? Symbol c)
                     (maybe (NoValues [slc c])))
                (for [types-map (extract-type-map c)
                      :when (get types-map SymbolType)]
                  slc))
            (NoValues [slc c]))))

(deftype MultiConstraint [constraints]
  (assert (instance? Vector constraints))

  Stringable
  (string-list [_] (list "(MultiConstraint [" (to-str (interpose constraints "\n")) "])"))

  Constraint
  (is-collection? [c]
    (some constraints is-collection?))

  (trim [c]
    (let [new-cs (-> constraints
                     (flat-map (fn [c]
                                 (either (map (instance? MultiConstraint c) .constraints)
                                         [c])))
                     (reduce {} (fn [m c]
                                  (let [c-name (type-name c)
                                        new-c (intersect c (either (get m c-name)
                                                                   top-type))]
                                    (assoc m c-name new-c))))
                     vals
                     vec
                     (remove (partial = top-type)))]
      (either (or (some new-cs (partial = bottom-type))
                  (map (some new-cs (partial instance? SumConstraint))
                       (fn [sum-c]
                         (reduce new-cs sum-c intersect)))
                  (and (empty? new-cs)
                       (maybe top-type))
                  (apply = new-cs))
              (.constraints c new-cs))))

  (collection-of [c]
    (Right c))

  (dynamic-fields [c]
    (either (-> constraints
                (remove empty?)
                first)
            []))

  (dynamic-params [c]
    (either (-> constraints
                (remove empty?)
                first)
            []))

  (set-type [c tc]
    (MultiConstraint (map constraints (fn [inner-c]
                                        (set-type inner-c tc)))))

  (extract-var [_]
    (either (some constraints (fn [c]
                                (let [var (extract-var c)]
                                  (or (and (= "" var)
                                           nothing)
                                      (maybe var)))))
            ""))

  (extract-sym [c]
    (some constraints extract-sym))

  (type-map [mc old-mc]
    ;; TODO: this might be a place to gain some performance back
    (let [types-maps (-> mc
                         .constraints
                         (reduce [] (fn [types-maps types-map]
                                      (either (map types-map (partial conj types-maps))
                                              types-maps))))]
      (for [types-map (first types-maps)]
        (let [types-map (-> types-maps
                            rest
                            (reduce types-map (fn [types-map m]
                                                (select-keys types-map (keys m)))))]
          (-> old-mc
              .constraints
              (filter (partial instance? FieldConstraint))
              (reduce types-map (fn [types-map c]
                                  (assert (instance? FieldConstraint c))

                                  (restrict-types c types-map))))))))

  (update-sym [mc sym]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-sym c sym)))))

  (update-var [mc var]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-var c var)))))

  (format-path [_ n]
    (let [max-len (reduce (map constraints (fn [o]
                                             (either (map (get o .path)
                                                          count)
                                                     0)))
                          n
                          (fn [max-len path-len]
                            (either (> max-len path-len)
                                    path-len)))
          paths (map constraints (fn [c]
                                   (format-path c (inc max-len))))]
      (-> paths
          (list-zipper empty-list)
          (map (fn [strs]
                 (to-str (interpose strs "    ")))))))

  (assertion-path [c]
    (format-path c 0)))

(def ValueConstraint (any-of SymbolConstraints
                             MultiConstraint
                             AllValues))

(deftype ResultConstraint [assertion]
  Stringable
  (string-list [_] (list "(ResultConstraint " (str assertion) ")"))

  Constraint
  (update-var [_ new-var]
    (ResultConstraint (update-var assertion new-var)))

  (update-sym [_ new-var]
    (ResultConstraint (update-sym assertion new-var)))

  (type-map [c _]
    ;; TODO: if this is just a bare 'assertion', the types conflict
    (.assertion c)))

(def Constraints (any-of ValueConstraint
                         NoValues
                         ResultConstraint))

;; private operations on Constraints
(defprotocol ConstraintOps
  (items-satisfied [info c]
    (assert (instance? ValueConstraint info))
    (assert (instance? ItemsConstraint c))
    (assert-result r (instance? (maybe-of ValueConstraint) r))

    nothing)

  (mult-satisfied [info c]
    (assert (instance? ValueConstraint info))
    (assert (instance? MultiConstraint c))
    (assert-result r (instance? (maybe-of ValueConstraint) r))

    (let [types-map (extract-type-map c)]
      (and (or (= nothing types-map)
               (flat-map types-map
                         (fn [types-map]
                           (satisfied-by (TypeConstraint types-map empty-list (symbol "<unknown>") nothing "")
                                         info))))
           (every (.constraints c)
                  (fn [inner-c]
                    (satisfied-by inner-c info)))
           (maybe info))))

  (sum-c-satisfies [info c]
    (assert (instance? ValueConstraint c))
    (assert-result r (instance? (maybe-of (maybe-of ValueConstraint)) r))

    nothing)

  (=-multi [y x]
    (assert (instance? MultiConstraint x))
    (assert-result r (instance? Maybe r))

    nothing)

  (intersect-result [c rc]
    (assert (instance? ResultConstraint rc))
    nothing)

  (=-result-constraint [y x]
    (assert (instance? ResultConstraint x))
    nothing)

  (intersect-typec [c tc]
    (assert (instance? TypeConstraint tc))
    (assert-result r (instance? Constraints r)))

  (=-contentsc [x y]
    nothing)

  (intersect-coll-of [c cc]
    (assert (instance? CollectionOf cc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var cc)) cc))

  (=-static-str [y x]
    nothing)

  (intersect-static-str [c slc]
    (assert (instance? StaticStrConstraint slc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var slc)) slc))

  (=-static-len [y x]
    nothing)

  (intersect-static-len [c slc]
    (assert (instance? StaticLengthConstraint slc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var slc)) slc))

  (=-inferred-inner [y x]
    nothing)

  (intersect-sum [c cs]
    (assert (instance? SumConstraint cs))

    (let [inters (map (.alts cs) (partial intersect (update-var c (extract-var cs))))
          goods (remove inters (partial instance? NoValues))]
      (either (and (empty? goods)
                   (maybe (NoValues [c cs])))
              (.alts cs goods))))

  (intersect-inner [c ic]
    (assert (instance? InferredInner ic))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var ic)) ic))

  (=-max-value [y x]
    (assert (instance? MaxValue x))
    nothing)

  (intersect-max-value [c mvc]
    (assert (instance? MaxValue mvc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var mvc)) mvc))

  (=-min-value [y x]
    (assert (instance? MinValue x))
    nothing)

  (intersect-min-value [c mvc]
    (assert (instance? MinValue mvc))
    (assert-result r (instance? Constraints r))

    (intersect c mvc))

  (=-static-int [y x]
    (assert (instance? StaticIntConstraint x))
    nothing)

  (intersect-static-int [c slc]
    (assert (instance? StaticIntConstraint slc))
    (intersect (update-var c (extract-var slc)) slc))

  (=-field-constraint [y x]
    (assert (instance? FieldConstraint x))
    nothing)

  (fieldc-satisfied [info c]
    (assert (instance? FieldConstraint c))
    (assert-result r (instance? (maybe-of ValueConstraint) r))

    (flat-map (extract-type-map info)
              (fn [types-map]
                (and (< 0 (count (restrict-types c types-map)))
                     (maybe info)))))

  (intersect-fieldc [c fc]
    (assert (instance? FieldConstraint fc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var fc)) fc))

  (=-items-constraint [y x]
    (assert (instance? ItemsConstraint x))
    nothing)

  (intersect-itemsc [c ic]
    (assert (instance? ItemsConstraint ic))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var ic)) ic))

  (intersect-multi [c mc]
    (assert (instance? MultiConstraint mc))
    (assert-result r (instance? Constraints r))

    ;; TODO: make sure that intersecting each type of constraint results
    ;; in the smallest set of .constraints in the MultiConstraint
    ;; applies to conj-multi as well.
    )

  (conj-multi [c mc]
    (assert (instance? MultiConstraint mc))))

(defn conflicting-assertions [failing-constraint file-name line-number]
  (apply print-err (list* "Conflicting assertions"
                           (either (= "" file-name)
                                   (str "at " file-name ": " line-number))
                           "\n"
                           (-> failing-constraint
                               ;; TODO: add file-name/line-number to empty paths
                               (format-path 0))))
  nothing)

(extend-type Vector
  Constraint
  (trim [v]
    (map v trim))

  (intersect [v c]
    (intersect (ItemsConstraint v coll-of-any empty-list nothing (extract-var c)) c)))

(extend-type Constraints
  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Constraint
  (coll-constraint [x]
    (collection-of x))

  (old-extract-items-constraints [c n]
    (-> c
        extract-items-constraints
        (comp (repeat n top-type))
        (take n)))

  (contents-constraint [_]
    (Right top-type)))

(extend-type NoValues
  Container
  (map [x f]
    (.constraints x (f (.constraints x))))

  (map [x f embed]
    (-> (.constraints x)
        f
        (map (partial .constraints x))))

  ConstraintOps
  (conj-multi [c mc]
    (maybe c))

  (intersect-typec [c _]
    c))

(extend-type AllValues
  ConstraintOps
  (intersect-sum [c sc] sc)
  (intersect-result [c rc] rc)
  (intersect-typec [c tc] tc)
  (intersect-coll-of [c cc] cc)
  (intersect-static-str [c slc] slc)
  (intersect-static-len [c slc] slc)
  (intersect-inner [c ic] ic)
  (intersect-max-value [c mvc] mvc)
  (intersect-min-value [c mvc] mvc)
  (intersect-static-int [c slc] slc)
  (intersect-fieldc [c fc] fc)
  (intersect-itemsc [c ic] ic)
  (intersect-multi [c mc] mc)
  (conj-multi [c mc]
    (maybe mc)))

(extend-type SymbolConstraints
  Constraint
  (clear-var [c]
    (.var c ""))

  (dynamic-fields [c] [])

  (set-path [c new-path]
    (Left (.path c new-path)))

  (extract-sym [c]
    (.sym c))

  (collection-of [x]
    (Right top-type))

  (extract-var [c]
    (.var c))

  (add-to-path [constraint file-name line-number]
    (let [new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (either (and (= "" file-name)
                   (maybe constraint))
              (.path constraint new-path))))

  (remove-sym [tc]
    (Left (.sym tc nothing)))

  (update-sym [tc new-sym]
    (.sym tc (maybe new-sym)))

  (update-var [tc new-var]
    (.var tc new-var))

  ConstraintOps
  (intersect-multi [c mc]
    (assert (instance? MultiConstraint mc))
    (assert-result r (instance? Constraints r))

    (either (or (-> (.constraints mc)
                    (map (partial intersect c))
                    (some (partial instance? NoValues)))
                (and (some (.constraints mc) (partial = c))
                     (maybe mc)))
            (conj mc c)))

  (conj-multi [c mc]
    (assert (instance? MultiConstraint mc))

    (either (and (some (.constraints mc) (partial = c))
                 (maybe mc))
            (MultiConstraint (conj (.constraints mc) c))))

  (intersect-typec [c tc]
    (assert (instance? TypeConstraint tc))
    (assert-result r (instance? Constraints r))

    (either (flat-map (extract-type-map c)
                      (fn [types-map]
                        (or (and (empty? (select-keys (.type-maps tc) (keys types-map)))
                                 (maybe (NoValues [tc c])))
                            (maybe (MultiConstraint [tc (update-var c (extract-var tc))])))))
            (intersect (update-var c (extract-var tc)) tc))))

(defn clear-vars [c]
  (cata clear-var c))

(defn sum-type [const-cs]
  (assert (instance? Vector const-cs))

  (either (or (and (empty? const-cs)
                   (maybe top-type))
              (some const-cs (partial = top-type))
              (apply = const-cs)
              (and (every const-cs (partial instance? CollectionOf))
                   (-> const-cs
                       (map .contents)
                       sum-type
                       (CollectionOf empty-list nothing "")
                       maybe)))
          (let [type-constraints (filter const-cs (partial instance? TypeConstraint))
                tc (either (empty? type-constraints)
                           [(TypeConstraint (comp* {} (map type-constraints .type-maps))
                                            empty-list
                                            (either (apply = (map type-constraints .type-sym))
                                                    (symbol "<unknown>"))
                                            nothing "")])
                new-cs (-> const-cs
                           (remove (partial instance? TypeConstraint))
                           (reduce tc (fn [new-cs curr]
                                        (either (and (some new-cs (partial = curr))
                                                     (maybe new-cs))
                                                (conj new-cs curr)))))]
            (either (and (= 1 (count new-cs))
                         (first new-cs))
                    (SumConstraint new-cs empty-list nothing "")))))

(extend-type ItemsConstraint
  Container
  (map [x f]
    (-> x
        (.tail-constraint (f (.tail-constraint x)))
        (.items-constraints (map (.items-constraints x) f))))

  (map [x f embed]
    (for [new-tail (f (.tail-constraint x))
          new-items (map (.items-constraints x) f embed)]
      (-> x
          (.tail-constraint new-tail)
          (.items-constraints new-items))))

  Eq
  (=* [x y]
    (=-items-constraint y x))

  ConstraintOps
  (items-satisfied [info c]
    (let [c-items (.items-constraints c)
          info-items (extract-items-constraints info (count c-items))]
      (and (<= (count c-items) (count (.items-constraints info)))
           (every (zip-lists c-items info-items)
                  (fn [[c info]]
                    (satisfied-by c info)))
           (satisfied-by (.tail-constraint c) (.tail-constraint info))
           (maybe info))))

  (intersect-coll-of [c cc]
    (let [new-items (map (.items-constraints c)
                         (fn [c]
                           (-> (.contents cc)
                               (intersect c)
                               (update-var (extract-var c)))))
          new-tail (either (= (.tail-constraint c) bottom-type)
                           (intersect cc (.tail-constraint c)))]
      (either (or (some new-items (partial = bottom-type))
                  (cond (= (.tail-constraint c) bottom-type)
                        nothing
                        (= new-tail bottom-type)))
              (-> c
                  (.items-constraints new-items)
                  (.tail-constraint new-tail)))))

  (intersect-static-str [c slc]
    ;; TODO: could be more precise by destructuring the static string
    (either (and (< (count slc) (count (extract-items-constraints c)))
                 (maybe (NoValues [slc c])))
            (intersect-coll-of c (CollectionOf (TypeConstraint {StringBufferType #{} SubStringType #{}}
                                                               empty-list 'String nothing "")
                                               empty-list nothing ""))))

  (intersect-static-len [c slc]
    (let [items-count (count (extract-items-constraints c))]
      (cond (or (< (.length slc) items-count)
                (and (< items-count (.length slc))
                     (= bottom-type (.tail-constraint c))))
            (NoValues [slc c])
            ;; TODO: return ItemsConstraint with correct number of items-constraints
            ;; and NoValues tail
            (MultiConstraint [slc c]))))

  (intersect-inner [c ic]
    (let [new-items (map (.items-constraints c)
                         (fn [c]
                           (-> (.contents ic)
                               (intersect c)
                               (update-var (extract-var c)))))
          new-tail (either (= (.tail-constraint c) bottom-type)
                           (intersect ic (.tail-constraint c)))]
      (either (or (some new-items (partial = bottom-type))
                  (cond (= (.tail-constraint c) bottom-type)
                        nothing
                        (= new-tail bottom-type)))
              (-> c
                  (.items-constraints new-items)
                  (.tail-constraint new-tail)))))

  (intersect-typec [c tc]
    (assert (instance? TypeConstraint tc))

    (either (for [types-map (extract-type-map tc)
                  good-type-map (extract-type-map c)
                  :let [new-map (select-keys types-map (keys good-type-map))]
                  :when-not (empty? new-map)]
              (MultiConstraint [(.type-maps tc new-map)
                                (update-var c (extract-var tc))]))
            (NoValues [c tc])))

  (intersect-max-value [c mvc]
    (NoValues [mvc c]))

  (intersect-static-int [c slc]
    (NoValues [slc c]))

  (intersect-itemsc [c ic]
    (assert (instance? ItemsConstraint ic))

    (let [c (cata trim c)
          ic (cata trim ic)
          cnt-ic (count (.items-constraints ic))
          cnt-c (count (.items-constraints c))
          max-cnt (either (> cnt-ic cnt-c)
                          cnt-c)
          constraints (map (zip-lists (extract-items-constraints ic max-cnt)
                                      (extract-items-constraints c max-cnt))
                           (fn [[c1 c2]]
                             (intersect c1 c2)))
          new-tail (intersect (.tail-constraint ic)
                              (.tail-constraint c))
          new-ic (-> ic
                     (.tail-constraint new-tail)
                     (.items-constraints (vec constraints)))]
      (either (some constraints (fn [c]
                                  (= c bottom-type)))
              (cond (or (= bottom-type (.tail-constraint ic))
                        (= bottom-type (.tail-constraint c)))
                    new-ic

                    (either (= bottom-type new-tail)
                            new-ic)))))

  (intersect-fieldc [c fc]
    (NoValues [fc c]))

  (intersect-min-value [c mvc]
    (NoValues [mvc c]))

  (=-items-constraint [y x]
    (and (= (.items-constraints y) (.items-constraints x))
         (= (.tail-constraint y) (.tail-constraint x))
         (maybe x)))

  Constraint
  (get-tail-constraint [c old-ic]
    (.tail-constraint c))

  (fixed-items-constraints [c old-ic]
    (comp (.items-constraints old-ic)
          (.tail-constraint c)))

  (old-extract-items-constraints [c n]
    (either (and (<= n 0)
                 (maybe []))
            (let [needed-tail-items (- n (count (.items-constraints c)))
                  tail-items (-> c
                                 .tail-constraint
                                 (old-extract-items-constraints needed-tail-items))]
              (-> c
                  .items-constraints
                  (comp tail-items (repeat n top-type))
                  (take n)))))

  (contents-constraint [c]
    (Left (-> (.items-constraints c)
              (conj (extract-contents-constraint (.tail-constraint c)))
              sum-type)))

  (satisfied-by [c info]
    (items-satisfied info c))

  (intersect [ic c]
    (either (=-items-constraint c ic)
            (intersect-itemsc c ic))))

(extend-type MultiConstraint
  Container
  (map [x f]
    (.constraints x (map (.constraints x) f)))

  (map [x f embed]
    (-> (.constraints x)
        (map f embed)
        (map (partial .constraints x))))

  Eq
  (=* [x y]
    (=-multi y x))

  Collection
  (conj [mc c]
    (assert (instance? SymbolConstraints c))

    (conj-multi c mc))

  ConstraintOps
  (items-satisfied [info c]
    (flat-map (some (.constraints info) (partial instance? ItemsConstraint))
              (fn [info-itemsc]
                (items-satisfied info-itemsc c))))

  (=-multi [y x]
    (and (every (.constraints x)
                (fn [x]
                  (some (.constraints y)
                        (fn [y]
                          (= x y)))))
         (maybe x)))

  (intersect-sum [c sc]
    (either (= (reduce (.constraints c) sc
                       (fn [x y]
                         (either (= (intersect x y) bottom-type)
                                 x)))
               bottom-type)
            (conj (update-var c (extract-var sc)) sc)))

  (intersect-inner [c ic]
    (either (= (reduce (.constraints c) ic
                       (fn [x y]
                         (either (= (intersect x y) bottom-type)
                                 x)))
               bottom-type)
            (conj c ic)))

  (intersect-typec [c tc]
    (intersect c tc))

  (conj-multi [c mc]
    (reduce (.constraints c) mc conj))

  (intersect-multi [c mc]
    (reduce (.constraints c) mc
            (fn [mc new-c]
              (either (= mc bottom-type)
                      (intersect mc new-c)))))

  (mult-satisfied [mult-info mult-c]
    (let [types-map (extract-type-map mult-c)]
      (and (or (= nothing types-map)
               (flat-map types-map
                         (fn [types-map]
                           (satisfied-by (TypeConstraint types-map empty-list (symbol "<unknown>") nothing "")
                                         mult-info))))
           (every (.constraints mult-c)
                  (fn [inner-c]
                    (some (.constraints mult-info)
                          (partial satisfied-by inner-c))))

           (maybe mult-info))))

  Constraint
  (intersect [mc c]
    (intersect-multi c mc))

    (contents-constraint [mc]
    (Left (either (map (some (.constraints mc) (partial instance? StaticLengthConstraint))
                       (fn [len-c]
                         (-> mc
                             (extract-items-constraints (.length len-c))
                             sum-type)))
                  (-> (.constraints mc)
                      (filter (fn [c]
                                (or (instance? CollectionOf c)
                                    (instance? InferredInner c)
                                    (instance? ItemsConstraint c))))
                      (map extract-contents-constraint)
                      (reduce top-type intersect)))))

  (satisfied-by [mult-c info]
    (mult-satisfied info mult-c))

  (get-tail-constraint [mc old-mc]
    (either (map (is-collection? old-mc)
                 (fn [_]
                   (-> (zip-lists (.constraints old-mc) (.constraints mc))
                       (filter (fn [[old-c]]
                                 (is-collection? old-c)))
                       (reduce top-type (fn [final-c [_ curr-c]]
                                          (intersect final-c curr-c))))))
            bottom-type))

  (fixed-items-constraints [mc old-mc]
    (let [coll-c (-> old-mc
                     extract-coll-constraint
                     extract-contents-constraint)
          ics (either (-> (.constraints mc)
                          (some (fn [v]
                                  (and (first v)
                                       (maybe v))))
                          (map (fn [fixed-ic]
                                 (map fixed-ic (fn [c]
                                                 (-> c
                                                     (intersect coll-c)
                                                     (update-var (extract-var c))))))))
                      [])]
      (either (map (some (.constraints old-mc)
                         (partial instance? StaticLengthConstraint))
                   (fn [len-c]
                     (take ics (.length len-c))))
              ics)))

  (old-extract-items-constraints [c n]
    (-> c
        .constraints
        (map (fn [c]
               (old-extract-items-constraints c n)))
        ((partial apply zip-lists))
        (map (fn [cs]
               (reduce cs top-type intersect)))
        vec)))

(extend-type ResultConstraint
  Container
  (map [x f]
    (.assertion x (f (.assertion x))))

  (map [x f embed]
    (-> (.assertion x)
        f
        (map (partial .assertion x))))

  Eq
  (=* [x y]
    (and (or (=-result-constraint y x)
             (=* (.assertion x) y))
         (maybe x)))

  Constraint
  (intersect [rc c]
    (let [intersected (either (intersect-result c rc)
                              (intersect (.assertion rc) c))]
      (either (= intersected bottom-type)
              (ResultConstraint intersected))))

  ConstraintOps
  (=-result-constraint [y x]
    (=* (.assertion x) (.assertion y)))

  (intersect-result [c rc]
    (maybe (intersect (.assertion rc) (.assertion c)))))

(extend-type TypeConstraint
  Constraint

  (contents-constraint [c]
    (Left (cond (or (get (.type-maps c) StringBufferType)
                    (get (.type-maps c) SubStringType))
                c
                top-type)))

  (set-type [c tc]
    ;; only used to switch ListType to VectorType or vice versa
    (either (or (and (= top-type tc)
                     (maybe c))
                (for [c-map (extract-type-map c)
                      tc-map (extract-type-map tc)
                      new-map (or (and (get tc-map ListType)
                                       (-> c-map
                                           (dissoc VectorType)
                                           (assoc ListType #{})
                                           maybe))
                                  (and (get tc-map VectorType)
                                       (-> c-map
                                           (dissoc ListType)
                                           (assoc VectorType #{})
                                           maybe)))]
                  (-> c
                      (.type-maps new-map)
                      (.type-sym (cond (= {ListType #{}} new-map)
                                       'List

                                       (= {VectorType #{}} new-map)
                                       'Vector

                                       (get new-map ListType)
                                       (symbol "List or something else")

                                       (symbol "Vector or something else"))))))
            top-type))

  (intersect [tc c]
    (intersect-typec c tc))

  (satisfied-by [c info]
    (either (sum-c-satisfies info c)
            (flat-map (extract-type-map info)
                      (fn [value-type-map]
                        (and (< 0 (count value-type-map))
                             (every (keys value-type-map)
                                    (partial get (.type-maps c)))
                             (maybe info))))))

  ConstraintOps
  (conj-multi [c mc]
    (intersect-multi c mc))

  (intersect-multi [c mc]
    (assert (instance? MultiConstraint mc))
    (assert-result r (instance? Constraints r))

    (either (or (= (reduce (.constraints mc) c
                           (fn [x y]
                             (either (= (intersect x y) bottom-type)
                                     x)))
                   bottom-type)
                (flat-map (extract-type-map mc)
                          (fn [new-map]
                            (= (intersect-typec c (.type-maps c new-map))
                               bottom-type)))
                (and (some (.constraints mc) (partial = c))
                     (maybe mc)))
            (MultiConstraint (conj (.constraints mc) c))))

  (intersect-coll-of [c ic]
    (let [new-type-map (dissoc (.type-maps c) IntegerType SymbolType)]
      (either (or (and (empty? new-type-map)
                       (maybe (NoValues [ic c])))
                  (= bottom-type (intersect (extract-contents-constraint c)
                                            (.contents ic))))
              (MultiConstraint [ic (-> c
                                       (.type-maps new-type-map)
                                       (update-var (extract-var ic)))]))))

  (intersect-inner [c ic]
    (let [new-type-map (dissoc (.type-maps c) IntegerType SymbolType)]
      (either (or (and (empty? new-type-map)
                       (maybe (NoValues [ic c])))
                  (= bottom-type (intersect (extract-contents-constraint c)
                                            (.contents ic))))
              (MultiConstraint [ic (-> c
                                       (.type-maps new-type-map)
                                       (update-var (extract-var ic)))]))))

  (intersect-fieldc [c fc]
    (let [field (.field fc)
          new-map (reduce (seq (.type-maps c))
                          {}
                          (fn [types-map [type-num fields]]
                            (either (map (fields field) (fn [_]
                                                          (assoc types-map type-num fields)))
                                    types-map)))]
      (either (and (empty? new-map)
                   (maybe (NoValues [fc c])))
              (MultiConstraint [fc (-> c
                                       (.type-maps new-map)
                                       (update-var (extract-var fc)))]))))

  (intersect-typec [c tc]
    (either (or (= tc c)
                (and (empty? (select-keys (.type-maps tc) (keys (.type-maps c))))
                     (maybe (NoValues [tc c])))
                (and (= (.type-maps tc) (keys (.type-maps c)))
                     (cond (< (count (.path tc))
                              (count (.path c)))
                           (maybe c)

                           (maybe tc))))
            (.type-maps tc (filter-keys (.type-maps tc)
                                        (fn [k]
                                          (get (.type-maps c) k)))))))

(extend-type FieldConstraint
  Eq
  (=* [x y]
    (=-field-constraint y x))

  Constraint
  (satisfied-by [c info]
    (either (sum-c-satisfies info c)
            (fieldc-satisfied info c)))

  (intersect [fc c]
    (intersect-fieldc c fc))

  ConstraintOps
  (intersect-coll-of [c cc]
    (MultiConstraint [cc (update-var c (extract-var cc))]))

  (intersect-static-str [c slc]
    (NoValues [slc c]))

  (intersect-static-len [c slc]
    (NoValues [slc c]))

  (intersect-inner [c ic]
    (MultiConstraint [ic (update-var c (extract-var ic))]))

  (intersect-max-value [c mvc]
    (NoValues [mvc c]))

  (=-field-constraint [y x]
    (and (= (.field y) (.field y))
         (maybe x)))

  (fieldc-satisfied [info c]
    (and (= (.field info) (.field c))
         (maybe info)))

  (intersect-fieldc [c fc]
    (either (= c fc)
            (MultiConstraint [fc (update-var c (extract-var fc))])))

  (intersect-static-int [c slc]
    (NoValues [slc c]))

  (intersect-min-value [c mvc]
    (NoValues [mvc c])))

(extend-type StaticIntConstraint
  Eq
  (=* [x y]
    (=-static-int y x))

  Constraint
  (intersect [slc c]
    (intersect-static-int c slc))

  ConstraintOps
  (intersect-coll-of [c cc]
    (NoValues [cc c]))

  (intersect-static-str [c slc]
    (NoValues [slc c]))

  (intersect-static-len [c slc]
    (NoValues [slc c]))

  (intersect-inner [c ic]
    (NoValues [ic c]))

  (=-static-int [y x]
    (and (= (.val y) (.val x))
         (maybe x)))

  (intersect-max-value [c mvc]
    (either (and (<= (.val c) (.max mvc))
                 (maybe c))
            (NoValues [mvc c])))

  (intersect-static-int [c slc]
    (either (= slc c)
            (NoValues [slc c])))

  (intersect-min-value [c mvc]
    (either (and (< (.val c) (.min mvc))
                 (maybe (NoValues [mvc c])))
            c)))

(extend-type MinValue
  Eq
  (=* [x y]
    (=-min-value y x))

  Constraint
  (intersect [mvc c]
    (intersect-min-value c mvc))

  ConstraintOps
  (intersect-static-len [c ic]
    (NoValues [ic c]))

  (intersect-static-str [c ic]
    (NoValues [ic c]))

  (intersect-inner [c ic]
    (NoValues [ic c]))

  (intersect-max-value [c mvc]
    (either (and (<= (.min c) (.max mvc))
                 (maybe (MultiConstraint [c mvc])))
            (NoValues [mvc c])))

  (=-min-value [y x]
    (and (= (.min y) (.min x))
         (maybe x)))

  (intersect-min-value [c mvc]
    (either (=* c mvc)
            (.min mvc (either (< (.min mvc) (.min c))
                              (.min c))))))

(defn core-containers [c]
  (TypeConstraint {VectorType #{}
                   MaybeType #{}
                   ListType #{}
                   BitmapIndexedType #{}
                   ArrayNodeType #{}
                   HashCollisionNodeType #{}}
                  (.path c) 'CoreContainers (.sym c) (extract-var c)))

(extend-type InferredInner
  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (-> (.contents x)
        f
        (map (partial .contents x))))

  Eq
  (=* [x y]
    (=-inferred-inner y x))

  Constraint
  (old-extract-items-constraints [c n]
    (either (and (flat-map (extract-type-map c) empty?)
                 (maybe []))
            (vec (repeat n (.contents c)))))

  (satisfied-by [c coll-info]
    (assert-result r (instance? (maybe-of ValueConstraint) r))

    (and (or (and (= (.contents c) top-type)
                  (satisfied-by (core-containers c) coll-info))
             (satisfied-by (.contents c) (extract-contents-constraint coll-info)))
         (maybe coll-info)))

  (coll-constraint [c]
    (Left (CollectionOf (.contents c) (.path c) (.sym c) (extract-var c))))

  (contents-constraint [c]
    (Left (.contents c)))

  (intersect [ic c]
    (intersect-inner c ic))

  ConstraintOps
  (intersect-multi [c mc]
    (let [new-c (intersect (.contents c)
                           (extract-contents-constraint mc))]
      (either (or (= new-c bottom-type)
                  (and (= new-c top-type)
                       (maybe mc)))
              (-> mc
                  (.constraints (remove (.constraints mc)
                                        (partial instance? InferredInner)))
                  (conj (.contents c new-c))))))

  (intersect-coll-of [c cc]
    (let [new-inner (intersect (.contents cc) (.contents c))]
      (either (= new-inner bottom-type)
              (.contents cc new-inner))))

  (intersect-static-str [c slc]
    (either (= (intersect (.contents c) (TypeConstraint {StringBufferType #{} SubStringType #{}}
                                                     (.path slc) 'String (.sym slc) (extract-var slc)))
               bottom-type)
            slc))

  (intersect-static-len [c slc]
    (MultiConstraint [slc c]))

  (=-inferred-inner [y x]
    (and (= (.contents x) (.contents y))
         (maybe x)))

  (intersect-inner [c ic]
    (let [new-c (intersect (.contents ic) (.contents c))]
      (either (= new-c bottom-type)
              (.contents ic new-c)))))

(extend-type MaxValue
  Eq
  (=* [x y]
    (=-max-value y x))

  ConstraintOps
  (intersect-coll-of [c cc]
    (NoValues [cc c]))

  (intersect-static-str [c slc]
    (NoValues [slc c]))

  (intersect-static-len [c slc]
    (NoValues [slc c]))

  (intersect-inner [c ic]
    (NoValues [ic c]))

  (=-max-value [y x]
    (and (= (.max x) (.max y))
         (maybe x)))

  (intersect-max-value [c mvc]
    (.max mvc (either (< (.max mvc) (.max c))
                      (.max c))))

  Constraint
  (intersect [mvc c]
    (intersect-max-value c mvc)))

(extend-type StaticLengthConstraint
  Eq
  (=* [x y]
    (=-static-len y x))

  Constraint
  (satisfied-by [c info]
    (and (or (and (instance? StaticLengthConstraint info)
                  (<= (.length c) (.length info)))
             (and (instance? ItemsConstraint info)
                  (<= (.length c) (count (.items-constraints info)))))
         (maybe info)))

  (intersect [slc c]
    (intersect-static-len c slc))

  ConstraintOps
  (items-satisfied [info c]
    (and (every (extract-items-constraints c (.length info))
                (partial = top-type))
         (maybe info)))

  (intersect-coll-of [c cc]
    (MultiConstraint [cc (update-var c (extract-var cc))]))

  (intersect-static-str [c slc]
    (MultiConstraint [slc c]))

  (intersect-static-len [c slc]
    (either (= slc c)
            (NoValues [slc c])))

  (=-static-len [y x]
    (and (= (.length x) (.length y))
         (maybe x))))

(extend-type StaticStrConstraint
  Eq
  (=* [x y]
    (=-static-str y x))

  Constraint
  (intersect [slc c]
    (intersect-static-str c slc))

  ConstraintOps
  (=-static-str [y x]
    (and (= (.val x) (.val y))
         (maybe x)))

  (intersect-static-str [c slc]
    (either (= slc c)
            (NoValues [slc c]))))

(extend-type CollectionOf
  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (-> (.contents x)
        f
        (map (partial .contents x))))

  Eq
  (=* [x y]
    (=-contentsc y x))

  Constraint
  (coll-constraint [c]
    (Left c))

  (satisfied-by [c coll-info]
    (assert-result r (instance? (maybe-of ValueConstraint) r))

    (and (or (and (= (.contents c) top-type)
                  (satisfied-by (core-containers c) coll-info))
             (satisfied-by (.contents c) (extract-contents-constraint coll-info)))
         (maybe coll-info)))

  (contents-constraint [c]
    (Left (.contents c)))

  (collection-of [x]
    (Left x))

  (old-extract-items-constraints [c n]
    (either (and (flat-map (extract-type-map c) empty?)
                 (maybe []))
            (vec (repeat n (.contents c)))))

  (type-map [c _]
    (maybe {ListType #{}
            MaybeType #{}
            BitmapIndexedType #{}
            ArrayNodeType #{}
            HashCollisionNodeType #{}
            PromiseType #{}
            HashSetType #{'set-map}
            FutureType #{}
            AgentType #{}
            FunctionType #{}
            VectorType #{}}))

  (intersect [cc c]
    (intersect-coll-of c cc))

  ConstraintOps
  (intersect-multi [c mc]
    (let [inters (map (.constraints mc) (partial intersect c))]
      (either (some inters (partial instance? NoValues))
              (-> mc
                  (.constraints (remove (.constraints mc)
                                        (partial instance? CollectionOf)))
                  (conj (-> (.constraints mc)
                            (filter (partial instance? CollectionOf))
                            (reduce c intersect)))))))

  (intersect-inner [c ic]
    (let [new-c (intersect (.contents c) (.contents ic))]
      (either (= new-c bottom-type)
              (.contents c new-c))))

  (intersect-static-str [c slc]
    (either (= (intersect (.contents c) (TypeConstraint {StringBufferType #{} SubStringType #{}}
                                                        (.path slc) 'String (.sym slc) (extract-var slc)))
               bottom-type)
            slc))

  (intersect-static-len [c slc]
    (MultiConstraint [slc c]))

  (intersect-coll-of [c cc]
    (let [new-cs (intersect (.contents cc) (.contents c))]
      (either (or (= new-cs bottom-type)
                  (= cc c))
              (.contents cc new-cs))))

  (=-contentsc [x y]
    (and (= (.contents x) (.contents y))
         (maybe x))))

(extend-type SumConstraint
  Container
  (map [x f]
    (.alts x (map (.alts x) f)))

  (map [x f embed]
    (-> (.alts x)
        (map f embed)
        (map (partial .alts x))))

  Constraint
  (trim [c]
    (let [all-alts (flat-map (.alts c) (fn [c]
                                         (either (map (instance? SumConstraint c) .alts)
                                                 [c])))
          tcs (filter all-alts (partial instance? TypeConstraint))
          tc (either (map (first tcs) (fn [alt-c]
                                        (-> (either (map (.sym c)
                                                         (partial update-sym alt-c))
                                                    alt-c)
                                            (.type-sym (symbol "<Unknown>"))
                                            (update-var (.var c))
                                            (replace-path (.path c))
                                            (.type-maps (comp* {} (map tcs .type-maps))))))
                     bottom-type)]
      (-> all-alts
          (remove (fn [c]
                    (or (= bottom-type c)
                        (instance? TypeConstraint c))))
          ((fn [new-alts]
             (cond (= bottom-type tc)
                   new-alts

                   (conj new-alts tc))))
          sum-type
          (replace-path (.path c))
          (update-var (.var c))
          ((fn [new-c]
             (either (map (.sym c)
                          (partial update-sym new-c))
                     new-c))))))

  (dynamic-params [c]
    (comp* [] (seq (.alts c))))

  (set-type [c tc]
    (.alts c (-> (.alts c)
                 (map (fn [inner-c]
                        (set-type inner-c tc)))
                 (remove (partial = bottom-type)))))

  (intersect [sc c]
    (intersect-sum c sc))

  (fixed-items-constraints [c old-sumc]
    (-> old-sumc
        (extract-items-constraints (-> (.alts c)
                                       (reduce 0 (fn [max cs]
                                                   (let [n (count cs)]
                                                     (either (> max n)
                                                             n))))))
        (map (fn [c]
               (update-var c "")))))

  (old-extract-items-constraints [c n]
    (-> (apply zip-lists (map (.alts c) (fn [alt]
                                          (old-extract-items-constraints alt n))))
        (map (fn [new-alts]
               (either (or (some new-alts (partial = top-type))
                           (apply = new-alts))
                       (.alts c (vec new-alts)))))
        vec
        (map (fn [c]
               (update-var c "")))))

  (contents-constraint [c]
    (Right c))

  ConstraintOps
  (mult-satisfied [c mult-c]
    (either (sum-c-satisfies c mult-c)
            nothing))

  (sum-c-satisfies [info c]
    (maybe (and (every (.alts info) (partial satisfied-by c))
                (maybe c))))

  (intersect-sum [c1 c2]
    (let [new-alts (for [a1 (.alts c1)
                         a2 (.alts c2)
                         :let [new-alt (intersect a1 a2)]
                         :when-not (= bottom-type new-alt)]
                     new-alt)
          new-alts (reduce new-alts [] (fn [new-alts alt]
                                         (either (and (some new-alts (partial =* alt))
                                                      (maybe new-alts))
                                                 (conj new-alts alt))))]
      (either (or (and (empty? new-alts)
                       (maybe (NoValues [c1 c2])))
                  (and (= 1 (count new-alts))
                       (first new-alts)))
              (-> c1
                  (update-var (extract-var c2))
                  (.alts new-alts))))))

(extend-type DynamicConstraint
  Constraint
  (assertion-path [c]
    (.path c))

  (intersect [c1 c2]
    (either (or (and (= top-type c2)
                     (maybe c1))
                (= c1 c2)
                (map (instance? MultiConstraint c2)
                     (partial intersect-multi c1)))
            (MultiConstraint [c1 c2])))

  (satisfied-by [_ c] (maybe c))
  (update-sym [x sym] (.sym x (maybe sym)))
  (update-var [x v] (.var x v))
  (collection-of [x] (Left top-type))
  (set-type [c _] c)

  ConstraintOps
  (intersect-typec [c tc]
    (MultiConstraint [c tc]))

  (intersect-multi [c mc]
    ;; TODO: only one DynamicConstraint allowed in a MultiConstraint
    (.constraints mc (cond (some (.constraints mc) (partial = c))
                           (.constraints mc)
                           (conj (.constraints mc) c)))))

(extend-type DynamicParamConstraint
  Constraint
  (set-type [c tc]
    (.result-type c tc)))

(extend-type DynamicResultConstraint
  Container
  (map [x f]
    (.invokable-c x (f (.invokable-c x))))

  (map [x f embed]
    (-> (.invokable-c x)
        f
        (map (partial .invokable-c x)))))

(extend-type ReifiedFields
  Container
  (map [x f]
    (.field-cs x (map (.field-cs x) f)))

  (map [x f embed]
    (-> (.field-cs x)
        (map f embed)
        (map (partial .field-cs x))))

  Constraint
  (dynamic-fields [c] (.field-cs c)))

(defn compose-constraints [file-name line-number x y]
  (assert (instance? Constraints x))
  (assert (instance? Constraints y))

  (let [z (intersect x y)]
    (either (and (= bottom-type z)
                 (let [z (either (and (flat-map (get z .constraints)
                                                (fn [constraints]
                                                  (< 1 (count constraints))))
                                      (maybe z))
                                 (NoValues [x y]))]
                   ;; (print-err 'x x)
                   ;; (print-err 'y y)
                   ;; (print-err 'z z)
                   (maybe (conflicting-assertions z file-name line-number))))
            (maybe z))))

(def empty-items-constraint (ItemsConstraint []
                                             (NoValues [])
                                             empty-list nothing ""))

(def fn-constraint (TypeConstraint {FunctionType #{}} empty-list 'Fn nothing ""))
(def sym-constraint (TypeConstraint {SymbolType #{}} empty-list 'Symbol nothing ""))
(def vect-constraint (TypeConstraint {VectorType #{}} empty-list 'Vector nothing ""))
(def list-constraint (TypeConstraint {ListType #{}} empty-list 'List nothing ""))
(def seq-constraint (TypeConstraint {ListType #{}
                                       VectorType #{}} empty-list 'Sequence nothing ""))
(def string-constraint (TypeConstraint {StringBufferType #{} SubStringType #{}}
                                         empty-list 'String nothing ""))
(def hashmap-constraint (TypeConstraint {BitmapIndexedType #{}
                                           ArrayNodeType #{}
                                           HashCollisionNodeType #{}}
                                          empty-list 'HashMap nothing ""))
(def int-constraint (TypeConstraint {IntegerType #{}} empty-list 'Integer nothing ""))
(def maybe-constraint  (TypeConstraint {MaybeType #{}} empty-list 'Maybe nothing ""))
