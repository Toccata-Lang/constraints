
(deftype ToccataCore [s]
  Stringable
  (string-list [_]
    (list "core"))

  Eq
  (=* [x y]
    (identical x y)))

(def FileName (any-of ToccataCore
                      String))

(defn file-name [x]
  (assert (instance? FileName x))
  (cond (instance? ToccataCore x)
        (.s x)

        x))

(deftype Location [file line]
  (assert (instance? FileName file))
  (assert (instance? Integer line))

  Stringable
  (string-list [_]
    (list (str file) ": " (str line)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

;; TODO: remove unused types
(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -2, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FnArityType};"))
;; (def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FunctionType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MaybeType};"))
;; (def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ListType};"))
;; (def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorType};"))
;; (def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SymbolType};"))
(def BitmapIndexedType (inline C Integer "(Value *)&(Integer){IntegerType, -2, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ArrayNodeType};"))
(def HashCollisionNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -2, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, OpaqueType};"))
;; (def NoValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, NoValuesType};"))
;; (def AllValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AllValuesType};"))
;; (def ResultConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ResultConstraintType};"))
;; ;; TODO: what the heck is this used for. Get rid of it
;; (def InferredInnerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InferredInnerType};"))
;; (def ContentsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ContentsConstraintType};"))
(def HashSetType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashSetType};"))
;; (def ProtoDispatcherType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ProtoDispatcherType};"))
;; (def FloatType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FloatType};"))
;; (def SumConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SumConstraintType};"))
;; (def TypeOfConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeOfConstraintType};"))
;; (def InnerTypeOfConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InnerTypeOfConstraintType};"))
;; (def DebugConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, DebugConstraintType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeCount};"))

;; type compoonents
(deftype NoSymbol []
  Stringable
  (string-list [_]
    (list "c/no-symbol"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (instance? NoSymbol y)))

(def OptionalSym (any-of NoSymbol
                         Symbol))

(def no-symbol (NoSymbol))

(deftype NoInt []
  Stringable
  (string-list [_]
    (list "c/no-int"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (instance? NoInt y))

  Ord
  (<* [x y]
    (and (instance? Integer y)
         (maybe x))))

(def OptionalInt (any-of NoInt
                         Integer))
(def no-int (NoInt))

(deftype NoString []
  Stringable
  (string-list [_]
    (list "c/no-string"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (instance? NoString y)))

(def OptionalStr (any-of NoString
                         String))
(def no-string (NoString))

(def NoStatic (any-of NoString
                      NoInt
                      NoSymbol))

(deftype NoTail []
  Stringable
  (string-list [_]
    (list "c/no-tail"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def no-tail (NoTail))

(deftype NoContents []
  Stringable
  (string-list [_]
    (list "c/no-contents"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def no-contents (NoContents))

(deftype NoFields []
  Stringable
  (string-list [_]
    (list "c/no-fields")))

(def no-fields (NoFields))

(deftype NoArgs []
  Stringable
  (string-list [_]
    (list "c/no-args"))

  Eq
  (=* [x y]
    (and (instance? NoArgs y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Seqable
  (first [_]
    nothing))

(def no-args (NoArgs))

(deftype NoVarArg []
  Stringable
  (string-list [_] (list "c/no-var-arg")))

(def no-var-arg (NoVarArg))

(deftype Variadic []
  Stringable
  (string-list [_] (list "c/variadic")))

(def variadic (Variadic))

(def ArityRank (any-of Integer
                       Variadic))

(deftype Field [sym]
  (assert (instance? Symbol sym))

  Stringable
  (string-list [_]
    (list (str "(c/Field (symbol \"" sym "\"))")))

  Eq
  (=* [x y]
    (and (instance? Field y)
         (= sym (.sym y))
         (maybe x)))

  Container
  (map [x _]
    x)

  (map [x _ embed]
    (embed x)))

;; universal types
(deftype AllValues [path var]
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "c/top-type"))

  Eq
  (=* [x y]
    (and (instance? AllValues y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def top-type (AllValues empty-list ""))

(deftype NoValues [constraints]
  Stringable
  (string-list [_]
    (list "(c/NoValues [" (to-str (interpose constraints "\n")) "])"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (and (instance? NoValues y)
         (or (and (empty? constraints)
                  (maybe y))
             (maybe x)))))

;; container types
(deftype CollectionOf [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/coll-of-c " (str contents) ")"))

  Eq
  (=* [x y]
    (and (instance? CollectionOf y)
         (= contents (.contents y))
         (maybe x)))

  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (-> (.contents x)
        f
        (map (partial .contents x)))))

(defn coll-of-c
  ([contents]
   (CollectionOf contents empty-list no-symbol ""))
  ([contents path sym var]
   (CollectionOf contents path sym var)))

(deftype ListConstraint [items tail-c path sym var]
  (assert (instance? Vector items))
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [l]
    (cond (and (empty? items)
               (= no-tail tail-c))
          (list "c/empty-list-constraint")

          (and (empty? items)
               (= tail-c (coll-of-c top-type)))
          (list "c/list-constraint")

          (list "(c/list-c [" (to-str (interpose items "\n")) "]"
                (cond (= tail-c no-tail)
                      ""
                      (str "\n" tail-c))
                ")")))

  Eq
  (=* [x y]
    (and (instance? ListConstraint y)
         (= items (.items y))
         (= tail-c (.tail-c y))
         (maybe x)))

  Container
  (map [c f]
    (-> c
        (.tail-c (f (.tail-c c)))
        (.items (map (.items c) f))))

  (map [c f embed]
    (for [new-tail-c (f (.tail-c c))
          new-items (map (.items c) f embed)]
      (-> c
          (.tail-c new-tail-c)
          (.items new-items)))))
(def empty-list-constraint (ListConstraint [] no-tail empty-list no-symbol ""))

(defn list-c
  ([items]
   (ListConstraint items no-tail empty-list no-symbol ""))
  ([items tail]
   (ListConstraint items tail empty-list no-symbol ""))
  ([items tail path sym var]
   (ListConstraint items tail path sym var)))

(deftype VectorConstraint [items tail-c path sym var]
  (assert (instance? Vector items))
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (cond (and (empty? items)
               (= no-tail tail-c))
          (list "c/empty-vect-constraint")

          (and (empty? items)
               (= tail-c (coll-of-c top-type)))
          (list "c/vect-constraint")

          (list "(c/vect-c [" (to-str (interpose items "\n")) "]"
                (cond (= tail-c no-tail)
                      ""
                      (str "\n" tail-c))
                ")")))

  Eq
  (=* [x y]
    (and (instance? VectorConstraint y)
         (= items (.items y))
         (= tail-c (.tail-c y))
         (maybe x)))

  Container
  (map [c f]
    (-> c
        (.tail-c (f (.tail-c c)))
        (.items (map (.items c) f))))

  (map [c f embed]
    (for [new-tail-c (f (.tail-c c))
          new-items (map (.items c) f embed)]
      (-> c
          (.tail-c new-tail-c)
          (.items new-items)))))
(def empty-vect-constraint (VectorConstraint [] no-tail empty-list no-symbol ""))

(defn vect-c
  ([items]
   (VectorConstraint items no-tail empty-list no-symbol ""))
  ([items tail]
   (VectorConstraint items tail empty-list no-symbol ""))
  ([items tail path sym var]
   (VectorConstraint items tail path sym var)))

(defn sym-str [s]
  (assert-result r (instance? String r))

  (let [st (str s)]
    (cond (flat-map (first st) (partial = "#"))
          (str " (symbol \"" st "\")")

          (= no-symbol s)
          ""

          (instance? Symbol s)
          (str " '" s)

          (str " " st))))

(deftype fn-arity [arity-id param-consts result-const]
  (assert (instance? OptionalSym arity-id))
  (assert (instance? ListConstraint param-consts))

  Stringable
  (string-list [_]
    (list "(c/fn-arity\n" (str "'" arity-id) "\n"
          (str param-consts) "\n;; returns\n" (str result-const) ")"))

  Container
  (map [x f]
    (let [new-fixed (map (.items param-consts) f)
          new-var (f (.tail-c param-consts))]
      (-> x
          (.param-consts (-> empty-list-constraint
                             (.items new-fixed)
                             (.tail-c new-var)))
          (.result-const (f result-const)))))

  (map [x f embed]
    (for [new-fixed (map (.items param-consts) f embed)
          new-var (f (.tail-c param-consts))
          new-result (f (.result-const x))]
      (-> x
          (.param-consts (-> empty-list-constraint
                             (.items new-fixed)
                             (.tail-c new-var)))
          (.result-const new-result)))))

(deftype FnConstraint [required-arities arities path sym var]
  ;; (assert (instance? (map-of ArityRank fn-arity) arities))
  (assert (instance? (vector-of Integer) required-arities))
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Eq
  (=* [x y]
    (and (instance? FnConstraint y)
         (= (count required-arities) (count (.required-arities y)))
         (every (.required-arities y) (fn [arity-rank]
                                       (some required-arities (partial = arity-rank))))
         (=* arities (.arities y))
         (maybe x)))

  Container
  (map [x f]
    (.arities x (map-vals arities f)))

  (map [x f embed]
    (map (contextual-map-vals arities f embed)
         (fn [a]
           (.arities x a)))))

(defn fn-c
  ([required arities]
   (FnConstraint required arities empty-list no-symbol ""))
  ([required arities path sym var]
   (FnConstraint required arities path sym var)))

;; product type
(deftype ReifiedConstraint [type-number type-symbol field-consts fields invoke-fn path sym var]
  (assert (instance? Integer type-number))
  ;; TODO: put this in
  ;; (assert (instance? (min-value 1) type-num))
  (assert (instance? OptionalSym type-symbol))
  (assert (instance? HashMap fields))
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (let [long-form (list "(c/ReifiedConstraint " (str type-number) " " (cond (= no-symbol type-symbol)
                                                                              (str no-symbol)
                                                                              (str "(symbol \"" type-symbol "\")"))
                          "\n" (str field-consts)
                          "\n{" (to-str (map (vec fields) (fn [[k v]]
                                                            (cond (instance? Symbol k)
                                                                  (str "'" k " " v "\n")
                                                                  (str k " " v "\n")))))
                          "}"
                          "\n" (str invoke-fn)
                          ;; (str (interpose (cons 'list path) " "))
                          " empty-list" (either (map (= no-symbol) (partial str " "))
                                                (sym-str sym))
                          " \"" (str var) "\")" )]
      (cond (= type-number MaybeType)
            (either (map (get fields 'contents)
                         (fn [contents]
                           (cond (instance? AllValues contents)
                                 (list "c/maybe-constraint")

                                 (= no-contents contents)
                                 (list "c/nothing-constraint")

                                 (list "(c/MaybeConstraint " (str contents) ")"))))
                    long-form)

            (= type-number IntegerType)
            (either (for [static (get fields 'static-value)
                          min (get fields 'min)
                          max (get fields 'max)]
                      (cond (and (= no-int static)
                                 (= min int-min)
                                 (= max int-max))
                            (list "c/int-constraint")

                            (list "(c/IntegerConstraint " (str static)
                                  " " (str max) " " (str min) ")")))
                    long-form)

            (= type-number SymbolType)
            (either (for [static (get fields 'static-value)]
                      (cond (= no-symbol static)
                            (list "c/sym-constraint")

                            (list "(c/SymbolConstraint " (str "'" static) ")")))
                    long-form)

            (= type-number StringBufferType)
            (either (for [static (get fields 'static-value)]
                      (cond (= no-string static)
                            (list "c/strbuff-constraint")

                            (list "(c/StrBuffConstraint " (str "\"" static "\"") ")")))
                    long-form)

            (= type-number SubStringType)
            (either (for [static (get fields 'static-value)]
                      (cond (= no-string static)
                            (list "c/substr-constraint")

                            (list "(c/SubStrConstraint " (str "\"" static "\"") ")")))
                    long-form)

            (= type-number PromiseType)
            (list "c/promise-constraint")

            (= type-number AgentType)
            (list "c/agent-constraint")

            (= type-number BitmapIndexedType)
            (cond (and (empty? field-consts)
                       (empty? fields))
                  (list "c/bitmap-constraint")

                  long-form)

            (= type-number ArrayNodeType)
            (cond (and (empty? field-consts)
                       (empty? fields))
                  (list "c/array-constraint")

                  long-form)

            (= type-number HashCollisionNodeType)
            (cond (and (empty? field-consts)
                       (empty? fields))
                  (list "c/hash-coll-constraint")

                  long-form)

            long-form)))

  Eq
  ;; TODO: equality must check the field maps as well
  ;; verify this
  (=* [x y]
    (and (instance? ReifiedConstraint y)
         (= type-number (.type-number y))
         (= fields (.fields y))
         (maybe x)))

  Container
  (map [tc f]
    (-> tc
        (.field-consts (-> (.field-consts tc)
                           vec
                           (map (fn [[fld fld-c]]
                                  [(f fld) (f fld-c)]))
                           (reduce {} (fn [m [k v]]
                                        (assoc m k v)))))
        (.fields (-> (.fields tc)
                     vec
                     (map (fn [[fld fld-c]]
                            [(either (instance? Symbol fld)
                                     (f fld))
                             (either (or (instance? OptionalSym fld-c)
                                         (instance? OptionalStr fld-c)
                                         (instance? OptionalInt fld-c))
                                     (f fld-c))]))
                     (reduce {} (fn [m [k v]]
                                  (assoc m k v)))))
        (.invoke-fn (f (.invoke-fn tc)))))

  (map [tc f embed]
    ;; TODO: not even sure this is right. Too tired to step through it
    (for [new-field-cs (-> (.field-consts tc)
                           vec
                           (map (fn [[fld fld-c]]
                                  (for [new-fld (f fld)
                                        new-c (f fld-c)]
                                    [new-fld new-c]))
                                embed)
                           (map (fn [new-flds]
                                  (reduce new-flds {} (fn [m [k v]]
                                                        (assoc m k v))))))
          new-fields (-> (.fields tc)
                         vec
                         (map (fn [[fld fld-c]]
                                (for [new-fld (either (map (instance? Symbol fld) embed)
                                                      (f fld))
                                      new-c (either (map (or (instance? OptionalInt fld-c)
                                                             (instance? OptionalStr fld-c)
                                                             (instance? OptionalSym fld-c))
                                                         embed)
                                                      (f fld-c))]
                                  [new-fld new-c]))
                              embed)
                         (map (fn [new-flds]
                                (reduce new-flds {} (fn [m [k v]]
                                                      (assoc m k v))))))
          new-invoke (f (.invoke-fn tc))]
      (-> tc
          (.field-consts new-field-cs)
          (.fields new-fields)
          (.invoke-fn new-invoke)))))

;; type attributes
;; sum type
(deftype SumConstraint [alts path sym var]
  (assert (instance? Vector alts))
  (assert (instance? (min-count 1) alts))
  (assert (instance? OptionalSym sym))
  (assert (instance? (list-of Vector) path))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list (str "(c/sum-c [" (to-str (interpose alts "\n")) "])")))

  Eq
  (=* [x y]
    (and (instance? SumConstraint y)
         (= (count alts) (count (.alts y)))
         (every (.alts y) (fn [c]
                            (some alts (partial =* c))))
         (maybe x)))

  Container
  (map [x f]
    (.alts x (map (.alts x) f)))

  (map [x f embed]
    (-> (.alts x)
        (map f embed)
        (map (partial .alts x)))))

(defn sum-c
  ([alts]
   (SumConstraint alts empty-list no-symbol ""))

  ([alts path sym var]
   (SumConstraint alts path sym var)))

;; multiple constraint
(deftype MultiConstraint [constraints path sym]
  Stringable
  (string-list [_]
    (list "(c/multi [" (to-str (interpose constraints "\n")) "])"))

  Eq
  (=* [x y]
    (and (instance? MultiConstraint y)
         (= (count constraints) (count (.constraints y)))
         (every constraints (fn [inner]
                              (some (.constraints y) (partial = inner))))
         (maybe x)))

  Container
  (map [x f]
    (.constraints x (map (.constraints x) f)))

  (map [x f embed]
    (map (map (.constraints x) f embed)
         (fn [new-cs]
           (.constraints x new-cs)))))

(defn multi [cs]
  (assert (instance? Vector cs))

  (MultiConstraint cs empty-list no-symbol))

(deftype ParamConstraint [arity param-index path sym var]
  (assert (instance? OptionalSym sym))

  Stringable
  (string-list [_]
    (list "(c/param " (str "'" arity) " " (str param-index) ")"))

  Eq
  (=* [x y]
    (and (instance? ParamConstraint y)
         (or (= arity (.arity y))
             (= (.arity y) arity))
         (= param-index (.param-index y))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(defn param [arity param-index]
  (ParamConstraint arity param-index empty-list no-symbol ""))

;; Get's replaced with the constraint of the param-sym, so not many implementations for it
(deftype TypeOfConstraint [param-sym path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/TypeOfConstraint" (sym-str param-sym)
          " empty-list"
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? TypeOfConstraint y)
         (= param-sym (.param-sym y))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype ProtoImpls [fn-sym default-impl impl-fns]
  (assert (instance? Symbol fn-sym))
  (assert (instance? FnConstraint default-impl))
  (assert (instance? (map-of Integer FnConstraint) impl-fns))

  Stringable
  (string-list [_]
    (list "(c/ProtoImpls\n'" (str fn-sym) "\n" (str default-impl) "\n\n" (str impl-fns) ")"))

  Container
  (map [x f]
    (ProtoImpls fn-sym
                (map default-impl f)
                (map-vals impl-fns f)))

  (map [x f embed]
    (for [def-impl (map default-impl f embed)
          impl-fns (contextual-map-vals impl-fns f embed)]
      (ProtoImpls fn-sym def-impl impl-fns))))

(deftype InnerTypeOf []
  Stringable
  (string-list [_]
    (list "c/inner-type-of-op")))
(def inner-type-of-op (InnerTypeOf))

(deftype FirstOf []
  Stringable
  (string-list [_]
    (list "c/first-of-op")))
(def first-of-op (FirstOf))

(deftype LastOf []
  Stringable
  (string-list [_]
    (list "c/last-of-op")))
(def last-of-op (LastOf))

(deftype RestOf []
  Stringable
  (string-list [_]
    (list "c/rest-of-op")))
(def rest-of-op (RestOf))

(deftype ButLastOf []
  Stringable
  (string-list [_]
    (list "c/butlast-of-op")))
(def butlast-of-op (ButLastOf))

(deftype ListFrom []
  Stringable
  (string-list [_]
    (list "c/list-from-op")))
(def list-from-op (ListFrom))

(deftype VectFrom []
  Stringable
  (string-list [_]
    (list "c/vect-from-op")))
(def vect-from-op (VectFrom))

(deftype ArgOf []
  Stringable
  (string-list [_]
    (list "c/arg-of-op")))
(def arg-of-op (ArgOf))

(deftype GetFrom []
  Stringable
  (string-list [_]
    (list "c/get-from-op")))
(def get-from-op (GetFrom))

(deftype SetTo []
  Stringable
  (string-list [_]
    (list "c/set-to-op")))
(def set-to-op (SetTo))

(deftype CallValue []
  Stringable
  (string-list [_]
    (list "c/call-value-op")))
(def call-value-op (CallValue))

(deftype Concat []
  Stringable
  (string-list [_]
    (list "c/concat-op")))
(def concat-op (Concat))

(deftype Apply []
  Stringable
  (string-list [_]
    (list "c/apply-op")))
(def apply-op (Apply))

;; TODO: should be an enum
(def TypeOpCodes (any-of InnerTypeOf
                         FirstOf
                         LastOf
                         RestOf
                         ButLastOf
                         ListFrom
                         VectFrom
                         ArgOf
                         GetFrom
                         SetTo
                         CallValue
                         Concat
                         Apply))

;; type operations
(deftype TypeOp [op-code base params sym path]
  (assert (instance? TypeOpCodes op-code))
  (assert (instance? (list-of Vector) path))

  Stringable
  (string-list [_]
    (list "(c/type-op " (str op-code) "\n"
          (str base)
          (either (map (instance? Vector params)
                       (fn [_]
                         (str "\n[" (to-str (interpose params "\n")) "]")))
                  (cond (= no-args params) "" (str "\n" params)))
           (sym-str sym) ")" ))

  Eq
  (=* [x y]
    (and (instance? TypeOp y)
         (= op-code (.op-code y))
         (= base (.base y))
         (= params (.params y))
         (maybe x))))

(defn type-op
  ([op-code base]
   (TypeOp op-code base no-args no-symbol empty-list))
  ([op-code base params]
   (TypeOp op-code base params no-symbol empty-list))
  ([op-code base params sym]
   (TypeOp op-code base params sym empty-list))
  ([op-code base params sym path]
   (TypeOp op-code base params sym path)))

(def SymbolConstraints (any-of ReifiedConstraint
                               VectorConstraint
                               ListConstraint
                               FnConstraint
                               CollectionOf
                               SumConstraint
                               TypeOfConstraint
                               ParamConstraint
                               MultiConstraint
                               TypeOp))

(def ValueConstraint (any-of SymbolConstraints
                             AllValues))

(def Constraints (any-of ValueConstraint
                         ProtoImpls
                         NoValues))

(def SeqConstraint (any-of VectorConstraint
                           ListConstraint))

(def empty-fn-constraint (FnConstraint [] {} empty-list no-symbol ""))

(defn IntegerConstraint
  ([static-value]
   (IntegerConstraint static-value 2147483647 -2147483648 empty-list no-symbol ""))
  ([static-value max min]
   (IntegerConstraint static-value max min empty-list no-symbol ""))
  ([static-value max min path sym var]
   ;; TODO: make 'min' and 'max' be constraints as well as integers
   (ReifiedConstraint IntegerType 'Integer {}
                      {'static-value static-value 'max max 'min min}
                      empty-fn-constraint path sym var)))

(def hashmap-names {BitmapIndexedType 'BitmapIndexedNode
                    ArrayNodeType 'ArrayNode
                    HashCollisionNodeType 'HashCollisionNode})

(defn hashmap-c [type-num]
  (ReifiedConstraint type-num (either (get hashmap-names type-num)
                                      'HashMap)
                     {} {} empty-fn-constraint empty-list no-symbol ""))

(defn SymbolConstraint
  ([static-value]
   (SymbolConstraint static-value empty-list no-symbol ""))
  ([static-value path sym var]
   (ReifiedConstraint SymbolType 'Symbol {}
                      {'static-value static-value}
                      empty-fn-constraint path sym var)))

(defn OpaqueConstraint
  ([]
   (OpaqueConstraint empty-list no-symbol ""))
  ([path sym var]
   (ReifiedConstraint OpaqueType 'Opaque {} {} empty-fn-constraint path sym var)))

(defn FutureConstraint
  ([]
   (FutureConstraint empty-list no-symbol ""))
  ([path sym var]
   (ReifiedConstraint FutureType 'Future {} {} empty-fn-constraint path sym var)))

(defn MaybeConstraint
  ([contents]
   (MaybeConstraint contents empty-list no-symbol ""))
  ([contents path sym var]
   (ReifiedConstraint MaybeType 'Maybe {} {'contents contents} empty-fn-constraint path sym var)))

(defn PromiseConstraint
  ([]
   (ReifiedConstraint PromiseType 'Promise {} {} empty-fn-constraint empty-list no-symbol ""))
  ([path sym var]
   (ReifiedConstraint PromiseType 'Promise {} {} empty-fn-constraint path sym var)))

(defn AgentConstraint
  ([]
   (ReifiedConstraint AgentType 'Agent {} {} empty-fn-constraint empty-list no-symbol ""))
  ([path sym var]
   (ReifiedConstraint AgentType 'Agent {} {} empty-fn-constraint path sym var)))

(defn StrBuffConstraint
  ([static-value]
   (StrBuffConstraint static-value empty-list no-symbol ""))
  ([static-value path sym var]
   (ReifiedConstraint StringBufferType 'String {} {'static-value static-value} empty-fn-constraint path sym var)))

(defn SubStrConstraint
  ([static-value]
   (SubStrConstraint static-value empty-list no-symbol ""))
  ([static-value path sym var]
   (ReifiedConstraint SubStringType 'String {} {'static-value static-value} empty-fn-constraint path sym var)))

(def bottom-type (NoValues []))
(def empty-reified (ReifiedConstraint UnknownType no-symbol {} {}
                                      empty-fn-constraint
                                      empty-list  no-symbol ""))
(def not-container (.type-symbol empty-reified (symbol "Can not contain other values")))
(def coll-of-any (CollectionOf top-type empty-list no-symbol ""))
(def list-constraint (ListConstraint [] (coll-of-c top-type) empty-list no-symbol ""))
(def vect-constraint (VectorConstraint [] (coll-of-c top-type) empty-list no-symbol ""))
(def seq-constraint (SumConstraint [vect-constraint list-constraint]
                                     empty-list no-symbol ""))
(def substr-constraint (SubStrConstraint no-string empty-list no-symbol ""))
(def strbuff-constraint (StrBuffConstraint no-string empty-list no-symbol ""))
(def string-constraint (SumConstraint [strbuff-constraint substr-constraint]
                                      empty-list no-symbol ""))
(def fn-constraint (FnConstraint []
                                 {variadic (fn-arity no-symbol list-constraint top-type)
                                  0 (fn-arity no-symbol empty-list-constraint
                                              top-type)
                                  1 (fn-arity no-symbol (ListConstraint (repeat 1 top-type)
                                                                        no-tail empty-list no-symbol "")
                                              top-type)
                                  2 (fn-arity no-symbol (ListConstraint (repeat 2 top-type)
                                                                        no-tail empty-list no-symbol "")
                                              top-type)
                                  3 (fn-arity no-symbol (ListConstraint (repeat 3 top-type)
                                                                        no-tail empty-list no-symbol "")
                                              top-type)
                                  4 (fn-arity no-symbol (ListConstraint (repeat 4 top-type)
                                                                        no-tail empty-list no-symbol "")
                                              top-type)
                                  5 (fn-arity no-symbol (ListConstraint (repeat 5 top-type)
                                                                        no-tail empty-list no-symbol "")
                                              top-type)
                                  6 (fn-arity no-symbol (ListConstraint (repeat 6 top-type)
                                                                        no-tail empty-list no-symbol "")
                                              top-type)
                                  7 (fn-arity no-symbol (ListConstraint (repeat 7 top-type)
                                                                        no-tail empty-list no-symbol "")
                                              top-type)
                                  8 (fn-arity no-symbol (ListConstraint (repeat 8 top-type)
                                                                        no-tail empty-list no-symbol "")
                                              top-type)
                                  9 (fn-arity no-symbol (ListConstraint (repeat 9 top-type)
                                                                        no-tail empty-list no-symbol "")
                                              top-type)}
                                 empty-list no-symbol ""))
(def type-of-constraint (TypeOfConstraint no-symbol empty-list no-symbol ""))
(def sym-constraint (SymbolConstraint no-symbol empty-list no-symbol ""))
(def seq-or-str-constraint (SumConstraint [vect-constraint list-constraint strbuff-constraint substr-constraint]
                                            empty-list no-symbol ""))
(def hash-coll-constraint (hashmap-c HashCollisionNodeType))
(def array-constraint (hashmap-c ArrayNodeType))
(def bitmap-constraint (hashmap-c BitmapIndexedType))
(def hashmap-constraint (SumConstraint [bitmap-constraint array-constraint hash-coll-constraint]
                                         empty-list no-symbol ""))
(def int-constraint (IntegerConstraint no-int int-max int-min empty-list no-symbol ""))
(def maybe-constraint  (MaybeConstraint top-type empty-list no-symbol ""))
(def nothing-constraint  (MaybeConstraint no-contents empty-list no-symbol ""))
(def set-constraint (ReifiedConstraint HashSetType 'HashSet
                                         {(Field (symbol ".set-map")) hashmap-constraint}
                                         {(Field (symbol ".set-map")) hashmap-constraint}
                                         (.arities fn-constraint {}) empty-list no-symbol ""))
(def agent-constraint (AgentConstraint))
(def promise-constraint (PromiseConstraint))
(def future-constraint (FutureConstraint empty-list no-symbol ""))
(def opaque-constraint (OpaqueConstraint empty-list no-symbol ""))
(def arity-constraint (ReifiedConstraint FnArityType 'FnArity {} {}
                                         (.arities fn-constraint {})
                                         empty-list no-symbol ""))
(def inner-type-of (type-op inner-type-of-op top-type))
(def first-of (multi [maybe-constraint
                      (type-op first-of-op top-type)]))
(def last-of (multi [maybe-constraint
                     (type-op last-of-op top-type)]))
(def rest-of (type-op rest-of-op top-type))
(def butlast-of (type-op butlast-of-op top-type))
(def list-from (type-op list-from-op top-type))
(def vect-from (type-op vect-from-op top-type))
(def result-of (type-op call-value-op top-type))
(def concat (type-op concat-op list-constraint))
(def apply-fn (type-op apply-op list-constraint))

(def core-type-constraints {'Integer int-constraint
                            'StringBuffer strbuff-constraint
                            'SubString substr-constraint
                            'FnArity arity-constraint
                            'BitmapIndexedNode bitmap-constraint
                            'ArrayNode array-constraint
                            'HashCollisionNode hash-coll-constraint
                            'Fn fn-constraint
                            'List list-constraint
                            'Maybe maybe-constraint
                            'Vector vect-constraint
                            'Symbol sym-constraint
                            'HashMap hashmap-constraint
                            'Promise promise-constraint
                            'Future future-constraint
                            'Agent agent-constraint
                            'Opaque opaque-constraint})

(defn missing-field [fld]
  (ReifiedConstraint UnknownType (symbol (str "Field/index '" fld "' required"))
                     {} {} empty-fn-constraint
                     empty-list no-symbol ""))

(defn cant-set-contents [x fld-path]
  (either (map (first fld-path)
               (fn [fld]
                 (NoValues [x (missing-field fld)])))
          (NoValues [x (ReifiedConstraint UnknownType (symbol "Unable to set contents")
                                          {} {} empty-fn-constraint
                                          empty-list no-symbol "")])))

(defprotocol Constraint
  (descend? [c]
    (RecurseWith c))

  (set-path [c new-path]
    (assert (instance? (list-of Vector) new-path))
    (assert-result r (instance? RecurseNext r))

    (RecurseWith c))

  (extract-sym [tc]
    (assert-result r (instance? OptionalSym r))

    no-symbol)

  (update-sym [c new-sym]
    (assert (instance? OptionalSym new-sym))

    c)

  (add-to-path [constraint loc]
    (assert (instance? Location loc))
    constraint)

  (type-num [c]
    (assert-result r (instance? Integer r))

    UnknownType)

  (type-sym [c]
    (assert-result r (instance? OptionalSym r)))

  (assertion-path [x])

  (format-path [x n]
    (assert-result r (instance? (list-of String) r)))

  (show-full [c]
    (assert-result b (instance? (list-of String) b)))

  (set-to [x fld-path fld-c]
    (cond (empty? fld-path)
          fld-c

          (cant-set-contents x fld-path)))

  (get-from [x fld]
    (NoValues [x (missing-field fld)]))

  (contents-constraint [c]
    (NoValues [c not-container]))

  ;; replace any ParamConstraints for 'arity' with their corresponding values
  (reify-const [c arity args]
    c)

  (find-constraint [c pred]
    (assert-result x (instance? (maybe-of Constraints) x))
    nothing)

  (found-constraint [c]
    nothing)

  (find-param [c]
    (assert-result t (instance? RecurseNext t))

    (RecurseWith c))

  ;; get only the fixeditems from a list or vector
  (get-items [c]
    (assert-result r (instance? Vector r))

    [])

  (get-tail [c]
    no-tail)

  (get-items [c items-count]
    (assert-result r (instance? Vector r))

    [])

  ;; Ensure constraint is as small as possible
  (trim-const [c]
    c)

  ;; derive a new type by applying a type operation
  (derive-const [op]
    ;; TODO: perhaps this is a better impl
    ;; (fn [c]
    ;;   (intersect (map op (fn [f]
    ;;                        (f top-type)))
    ;;              c))

    ;; TODO: Make sure (fn [_] op) works as well
    (constantly op))

  ;; produces the type required by the type operation
  ;; (required [c op]
  ;;   (intersect c op))

  (intersect [c1 c2]
    ;; 'top-type' is the undefined result
    top-type))

(defn update-path [c loc]
  (cata (fn [c]
          (add-to-path c loc))
        c))

(defn set-items [c items]
  (assert (instance? Vector items))

  (apo (fn [c]
         (cond (instance? SeqConstraint c)
               (RecurseFinal (.items c items))

               (RecurseWith c)))
       c))

(defn set-tail [c tail]
  (apo (fn [c]
         (cond (instance? SeqConstraint c)
               (RecurseFinal (.tail-c c tail))

               (RecurseWith c)))
       c))
