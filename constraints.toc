;;
(def SymbolOrString (any-of Symbol
                            String))

(deftype Location [file line]
  (assert (instance? SymbolOrString file))
  (assert (instance? Integer line))

  Stringable
  (string-list [_]
    (list (either (and (= file 'core)
                       (maybe "core"))
                  (str file))
          ": " (str line)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(defn sym-str [s]
  (assert-result r (instance? String r))

  (let [st (str s)]
    (cond (= "#result" st)
          (str "(symbol \"#result\")")

          (instance? Symbol s)
          (str "'" s)

          st)))

;; TODO: remove unused types
(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -2, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FunctionType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MaybeType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ListType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SymbolType};"))
(def BitmapIndexedType (inline C Integer "(Value *)&(Integer){IntegerType, -2, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ArrayNodeType};"))
(def HashCollisionNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -2, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, OpaqueType};"))
(def NoValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, NoValuesType};"))
(def AllValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AllValuesType};"))
(def ResultConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ResultConstraintType};"))
;; TODO: what the heck is this used for. Get rid of it
(def InferredInnerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InferredInnerType};"))
(def ContentsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ContentsConstraintType};"))
(def HashSetType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashSetType};"))
(def ProtoDispatcherType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ProtoDispatcherType};"))
(def FloatType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FloatType};"))
(def SumConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SumConstraintType};"))
(def TypeOfConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeOfConstraintType};"))
(def InnerTypeOfConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InnerTypeOfConstraintType};"))
(def DebugConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, DebugConstraintType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeCount};"))

;; type compoonents
(deftype NoSymbol []
  Stringable
  (string-list [_]
    (list "c/no-symbol"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (instance? NoSymbol y)))

(def OptionalSym (any-of NoSymbol
                         Symbol))

(def no-symbol (NoSymbol))

(deftype NoInt []
  Stringable
  (string-list [_]
    (list "c/no-int"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (instance? NoInt y))

  Ord
  (<* [x y]
    (and (instance? Integer y)
         (maybe x))))

(def OptionalInt (any-of NoInt
                         Integer))
(def no-int (NoInt))

(deftype NoString []
  Stringable
  (string-list [_]
    (list "c/no-string"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (instance? NoString y)))

(def OptionalStr (any-of NoString
                         String))
(def no-string (NoString))

(def NoStatic (any-of NoString
                      NoInt
                      NoSymbol))

(deftype NoTail []
  Stringable
  (string-list [_]
    (list "c/no-tail"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def no-tail (NoTail))

(deftype NoFields []
  Stringable
  (string-list [_]
    (list "c/no-fields")))

(def no-fields (NoFields))

(deftype NoArgs []
  Stringable
  (string-list [_]
    (list "c/no-args"))

  Eq
  (=* [x y]
    (and (instance? NoArgs y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def no-args (NoArgs))

(deftype Variadic []
  Stringable
  (string-list [_] (list "c/variadic")))

(def variadic (Variadic))

(def ArityRank (any-of Integer
                       Variadic))

(deftype Field [sym]
  (assert (instance? Symbol sym))

  Stringable
  (string-list [_]
    (list (str "(c/Field (symbol \"" sym "\"))")))

  Eq
  (=* [x y]
    (and (instance? Field y)
         (= sym (.sym y))
         (maybe x)))

  Container
  (map [x _]
    x)

  (map [x _ embed]
    (embed x)))

;; universal types
(deftype AllValues [path var]
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "c/top-type"))

  Eq
  (=* [x y]
    (and (instance? AllValues y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype NoValues [constraints]
  Stringable
  (string-list [_]
    (list "(c/NoValues [" (to-str (interpose constraints "\n")) "])"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (and (instance? NoValues y)
         (or (and (empty? constraints)
                  (maybe y))
             (maybe x)))))

;; container types
(deftype ListConstraint [items tail-c path sym var]
  (assert (instance? Vector items))
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [l]
    (cond (and (empty? items)
               (= no-tail tail-c))
          (list "c/empty-list-constraint")

          (and (empty? items)
               (instance? AllValues tail-c))
          (list "c/list-constraint")

          (list "(c/ListConstraint [" (to-str (interpose items "\n")) "]\n"
                (str tail-c)
                " "
                "empty-list "
                ;; (str (cons 'list path)) " "
                (sym-str sym) " \"" (str var) "\")" )))

  Eq
  (=* [x y]
    (and (instance? ListConstraint y)
         (= items (.items y))
         (= tail-c (.tail-c y))
         (maybe x)))

  Container
  (map [c f]
    (-> c
        (.tail-c (f (.tail-c c)))
        (.items (map (.items c) f))))

  (map [c f embed]
    (for [new-tail-c (f (.tail-c c))
          new-items (map (.items c) f embed)]
      (-> c
          (.tail-c new-tail-c)
          (.items new-items)))))
(def empty-list-constraint (ListConstraint [] no-tail empty-list no-symbol ""))

(defn params-list
  ([items]
   (ListConstraint items no-tail empty-list no-symbol ""))
  ([items tail]
   (ListConstraint items tail empty-list no-symbol "")))

(defn list-c
  ([items]
   (ListConstraint items no-tail empty-list no-symbol ""))
  ([items tail]
   (ListConstraint items tail empty-list no-symbol ""))
  ([items tail path sym var]
   (ListConstraint items tail path sym var)))

(deftype VectorConstraint [items tail-c path sym var]
  (assert (instance? Vector items))
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (cond (and (empty? items)
               (= no-tail tail-c))
          (list "c/empty-vect-constraint")

          (and (empty? items)
               (instance? AllValues tail-c))
          (list "c/vect-constraint")

          (list "(c/VectorConstraint [" (to-str (interpose items "\n")) "]\n"
                (str tail-c)
                " "
                "empty-list "
                ;; (str (cons 'list path))
                (sym-str sym) " \"" (str var) "\")" )))

  Eq
  (=* [x y]
    (and (instance? VectorConstraint y)
         (= items (.items y))
         (= tail-c (.tail-c y))
         (maybe x)))

  Container
  (map [c f]
    (-> c
        (.tail-c (f (.tail-c c)))
        (.items (map (.items c) f))))

  (map [c f embed]
    (for [new-tail-c (f (.tail-c c))
          new-items (map (.items c) f embed)]
      (-> c
          (.tail-c new-tail-c)
          (.items new-items)))))
(def empty-vect-constraint (VectorConstraint [] no-tail empty-list no-symbol ""))

(defn vect-c
  ([items]
   (VectorConstraint items no-tail empty-list no-symbol ""))
  ([items tail]
   (VectorConstraint items tail empty-list no-symbol ""))
  ([items tail path sym var]
   (VectorConstraint items tail path sym var)))

(deftype HashMapConstraint [type-num kv-pairs keys-c vals-c path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/HashMapConstraint " (str type-num) " " (str kv-pairs) " "
          (str keys-c) " " (str vals-c) " "
          "empty-list "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? HashMapConstraint y)
         (= kv-pairs (.kv-pairs y))
         (= keys-c (.keys-c y))
         (= vals-c (.vals-c y))
         (maybe x)))

  Container
  (map [c f]
    (-> c
        (.keys-c (f (.keys-c c)))
        (.vals-c (f (.vals-c c)))
        (.kv-pairs (-> (.kv-pairs c)
                       vec
                       (reduce {} (fn [m [k v]]
                                    (assoc m
                                      (f k) (f v))))))))

  (map [c f embed]
    (for [new-keys (f (.keys-c c))
          new-vals (f (.vals-c c))
          new-kv (-> (.kv-pairs c)
                     vec
                     (map (fn [[key-c val-c]]
                            (for [new-key (f key-c)
                                  new-val (f val-c)]
                              [new-key new-val]))
                          embed))]
      (-> c
          (.keys-c new-keys)
          (.vals-c new-vals)
          (.kv-pairs (reduce new-kv {} (fn [m [k v]]
                                         (assoc m k v))))))))


(deftype fn-arity [arity-id param-consts result-const]
  (assert (instance? OptionalSym arity-id))
  (assert (instance? ListConstraint param-consts))

  Stringable
  (string-list [_]
    (list "(c/fn-arity " (str "'" arity-id) "\n"
          "(c/parms-list " (to-str (interpose (.items param-consts) "\n")) " "
          (str (.tail-c param-consts)) ")"
          "\n" (str result-const) ")"))

  Container
  (map [x f]
    (let [new-fixed (map (.items param-consts) f)
          new-var (f (.tail-c param-consts))]
      (-> x
          (.param-consts (-> empty-list-constraint
                             (.items new-fixed)
                             (.tail-c new-var)))
          (.result-const (f result-const)))))

  (map [x f embed]
    (for [new-fixed (map (.items param-consts) f embed)
          new-var (f (.tail-c param-consts))
          new-result (f (.result-const x))]
      (-> x
          (.param-consts (-> empty-list-constraint
                             (.items new-fixed)
                             (.tail-c new-var)))
          (.result-const new-result)))))

(deftype FnConstraint [required-arities arities path sym var]
  ;; (assert (instance? (map-of ArityRank fn-arity) arities))
  (assert (instance? (vector-of Integer) required-arities))
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/FnConstraint\n[" (to-str (interpose required-arities " ")) "]"
          "\n" (str arities)
          "\n empty-list "
          ;; "\n" (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? FnConstraint y)
         (= (count required-arities) (count (.required-arities y)))
         (every (.required-arities y) (fn [arity-rank]
                                       (some required-arities (partial = arity-rank))))
         (=* arities (.arities y))
         (maybe x)))

  Container
  (map [x f]
    (.arities x (map-vals arities f)))

  (map [x f embed]
    (map (contextual-map-vals arities f embed)
         (fn [a]
           (.arities x a)))))

(defn fn-c
  ([required arities]
   (FnConstraint required arities empty-list no-symbol ""))
  ([required arities path sym var]
   (FnConstraint required arities path sym var)))

;; product type
(deftype ReifiedConstraint [type-number type-symbol field-consts fields invoke-fn path sym var]
  (assert (instance? Integer type-number))
  ;; TODO: put this in
  ;; (assert (instance? (min-value 1) type-num))
  (assert (instance? OptionalSym type-symbol))
  (assert (instance? HashMap fields))
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/ReifiedConstraint " (str type-number) " " (cond (= no-symbol type-symbol)
                                                              (str no-symbol)
                                                              (str "(symbol \"" type-symbol "\")"))
          "\n" (str field-consts)
          "\n{" (to-str (map (vec fields) (fn [[k v]]
                                            (cond (instance? Symbol k)
                                                  (str "'" k " " v "\n")
                                                  (str k " " v "\n")))))
          "}"
          "\n" (str invoke-fn)
          ;; (str (interpose (cons 'list path) " "))
          " empty-list "
          " " (sym-str sym) " \"" (str var) "\")" ))

  Eq
  ;; TODO: equality must check the field maps as well
  ;; verify this
  (=* [x y]
    (and (instance? ReifiedConstraint y)
         (= type-number (.type-number y))
         (= fields (.fields y))
         (maybe x)))

  Container
  (map [tc f]
    (-> tc
        (.field-consts (-> (.field-consts tc)
                           vec
                           (map (fn [[fld fld-c]]
                                  [(f fld) (f fld-c)]))
                           (reduce {} (fn [m [k v]]
                                        (assoc m k v)))))
        (.fields (-> (.fields tc)
                     vec
                     (map (fn [[fld fld-c]]
                            [(either (instance? Symbol fld)
                                     (f fld))
                             (either (or (instance? OptionalSym fld-c)
                                         (instance? OptionalStr fld-c)
                                         (instance? OptionalInt fld-c))
                                     (f fld-c))]))
                     (reduce {} (fn [m [k v]]
                                  (assoc m k v)))))
        (.invoke-fn (f (.invoke-fn tc)))))

  (map [tc f embed]
    ;; TODO: not even sure this is right. Too tired to step through it
    (for [new-field-cs (-> (.field-consts tc)
                           vec
                           (map (fn [[fld fld-c]]
                                  (for [new-fld (f fld)
                                        new-c (f fld-c)]
                                    [new-fld new-c]))
                                embed)
                           (map (fn [new-flds]
                                  (reduce new-flds {} (fn [m [k v]]
                                                        (assoc m k v))))))
          new-fields (-> (.fields tc)
                         vec
                         (map (fn [[fld fld-c]]
                                (for [new-fld (either (map (instance? Symbol fld) embed)
                                                      (f fld))
                                      new-c (either (map (or (instance? OptionalInt fld-c)
                                                             (instance? OptionalStr fld-c)
                                                             (instance? OptionalSym fld-c))
                                                         embed)
                                                      (f fld-c))]
                                  [new-fld new-c]))
                              embed)
                         (map (fn [new-flds]
                                (reduce new-flds {} (fn [m [k v]]
                                                      (assoc m k v))))))
          new-invoke (f (.invoke-fn tc))]
      (-> tc
          (.field-consts new-field-cs)
          (.fields new-fields)
          (.invoke-fn new-invoke)))))

;; type attributes
(deftype CollectionOf [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/CollectionOf\n" (str contents)
          "\nempty-list "
          ;; " (list "
          ;; (either (map (first path) (fn [[f l]]
          ;;                             (str "[\"" f "\" " l "]")))
          ;;         "")
          ;; ") "
          (sym-str sym) " \"" (str var) "\")"))

  Eq
  (=* [x y]
    (and (instance? CollectionOf y)
         (= contents (.contents y))
         (maybe x)))

  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (-> (.contents x)
        f
        (map (partial .contents x)))))

(defn coll-of-c
  ([contents]
   (CollectionOf contents empty-list no-symbol ""))
  ([contents path sym var]
   (CollectionOf contents path sym var)))

;; sum type
(deftype SumConstraint [alts path sym var]
  (assert (instance? Vector alts))
  (assert (instance? (min-count 1) alts))
  (assert (instance? OptionalSym sym))
  (assert (instance? (list-of Vector) path))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list (str "(c/SumConstraint\n[" (to-str (interpose alts "\n\n")) "]"
               " empty-list "
               ;; "\n(list" (either (map (first path) (fn [[f l]]
               ;;                             (str "[\"" f "\" " l "]")))
               ;;         "") ") "
               (sym-str sym) " "
               (str "\"" var "\"") ")")))

  Eq
  (=* [x y]
    (and (instance? SumConstraint y)
         (= (count alts) (count (.alts y)))
         (every (.alts y) (fn [c]
                            (some alts (partial =* c))))
         (maybe x)))

  Container
  (map [x f]
    (.alts x (map (.alts x) f)))

  (map [x f embed]
    (-> (.alts x)
        (map f embed)
        (map (partial .alts x)))))

(defn sum-c
  ([alts]
   (SumConstraint alts empty-list no-symbol ""))
  ([alts path sym var]
   (SumConstraint alts path sym var)))

;; computed types
(deftype ComputedConstraint [mods path sym var]
  (assert (instance? OptionalSym sym))

  Stringable
  (string-list [_]
    (list "(c/ComputedConstraint "
          "\n[" (to-str (interpose mods "\n"))
          "]\n"
           "empty-list"
          ;; (str " " (cons 'list path))
          " " (sym-str sym)
          " " (str "\"" var "\"")
          ")"))

  Eq
  (=* [x y]
    (and (instance? ComputedConstraint y)
         (= mods (.mods y))
         (maybe x)))

  Container
  (map [x f]
    (.mods x (map (.mods x) f)))

  (map [x f embed]
    (map (map (.mods x) f embed)
         (fn [new-mods]
           (.mods x new-mods)))))

(defn compute-c
  ([mods]
   (ComputedConstraint mods empty-list no-symbol ""))
  ([mods path sym var]
   (ComputedConstraint mods path sym var)))

(deftype ParamConstraint [arity param-index path sym var]
  (assert (instance? OptionalSym sym))

  Stringable
  (string-list [_]
    (list "(c/param " (str "'" arity) " " (str param-index) ")"))

  Eq
  (=* [x y]
    (and (instance? ParamConstraint y)
         (or (= arity (.arity y))
             (= (.arity y) arity))
         (= param-index (.param-index y))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(defn param [arity param-index]
  (ParamConstraint arity param-index empty-list no-symbol ""))

;; Get's replaced with the constraint of the param-sym, so not many implementations for it
(deftype TypeOfConstraint [param-sym path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? OptionalSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/TypeOfConstraint " (sym-str param-sym)
          " empty-list "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? TypeOfConstraint y)
         (= param-sym (.param-sym y))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype InnerTypeOf []
  Stringable
  (string-list [_]
    (list "c/inner-type-of-op")))
(def inner-type-of-op (InnerTypeOf))

(deftype FirstOf []
  Stringable
  (string-list [_]
    (list "c/first-of-op")))
(def first-of-op (FirstOf))

(deftype LastOf []
  Stringable
  (string-list [_]
    (list "c/last-of-op")))
(def last-of-op (LastOf))

(deftype RestOf []
  Stringable
  (string-list [_]
    (list "c/rest-of-op")))
(def rest-of-op (RestOf))

(deftype ButLastOf []
  Stringable
  (string-list [_]
    (list "c/butlast-of-op")))
(def butlast-of-op (ButLastOf))

(deftype ListFrom []
  Stringable
  (string-list [_]
    (list "c/list-from-op")))
(def list-from-op (ListFrom))

(deftype VectFrom []
  Stringable
  (string-list [_]
    (list "c/vect-from-op")))
(def vect-from-op (VectFrom))

(deftype ArgOf []
  Stringable
  (string-list [_]
    (list "c/arg-of-op")))
(def arg-of-op (ArgOf))

(deftype GetFrom []
  Stringable
  (string-list [_]
    (list "c/get-from-op")))
(def get-from-op (GetFrom))

(deftype SetTo []
  Stringable
  (string-list [_]
    (list "c/set-to-op")))
(def set-to-op (SetTo))

(deftype CallValue []
  Stringable
  (string-list [_]
    (list "c/call-value-op")))
(def call-value-op (CallValue))

;; TODO: should be an enum
(def TypeOpCodes (any-of InnerTypeOf
                         FirstOf
                         LastOf
                         RestOf
                         ButLastOf
                         ListFrom
                         VectFrom
                         ArgOf
                         GetFrom
                         SetTo
                         CallValue))

;; type operations
(deftype TypeOp [op-code params path]
  (assert (instance? TypeOpCodes op-code))
  (assert (instance? (list-of Vector) path))

  Stringable
  (string-list [_]
    (list "(c/TypeOp " (str op-code) " "
          (str params) " "
          "empty-list"
          ;; (str (cons 'list path))
          ")" ))

  Eq
  (=* [x y]
    (and (instance? TypeOp y)
         (= op-code (.op-code y))
         (= params (.params y))
         (maybe x)))

  Container
  (map [tc f]
    (cond (= op-code set-to-op)
          (let [[path v] (.params tc)]
            (.params tc [(map path f) (f v)]))

          (instance? Vector params)
          (.params tc (map (.params tc) f))

          tc))

  (map [tc f embed]
    (cond (= op-code set-to-op)
          (let [[path v] (.params tc)]
            (for [new-path (map path f embed)
                  new-v (f v)]
              (.params tc [new-path new-v])))

          (instance? Vector params)
          (map (map params f embed)
               (partial .params tc))

          (embed tc))))

(defn type-op
  ([op-code params]
   (TypeOp op-code params empty-list))
  ([op-code params path]
   (TypeOp op-code params path)))

(def inner-type-of (TypeOp inner-type-of-op [] empty-list))
(def first-of (TypeOp first-of-op [] empty-list))
(def last-of (TypeOp last-of-op [] empty-list))
(def rest-of (TypeOp rest-of-op [] empty-list))
(def butlast-of (TypeOp butlast-of-op [] empty-list))
(def list-from (TypeOp list-from-op [] empty-list))
(def vect-from (TypeOp vect-from-op [] empty-list))
(def result-of (TypeOp call-value-op no-args empty-list))

(def SymbolConstraints (any-of ReifiedConstraint
                               VectorConstraint
                               ListConstraint
                               HashMapConstraint
                               FnConstraint
                               CollectionOf
                               SumConstraint
                               TypeOfConstraint
                               ParamConstraint
                               ComputedConstraint))

(def ValueConstraint (any-of SymbolConstraints
                             AllValues))

(def Constraints (any-of ValueConstraint
                         NoValues))

(def SeqConstraint (any-of VectorConstraint
                           ListConstraint))

(def top-type (AllValues empty-list ""))
(def bottom-type (NoValues []))
(def empty-fn-constraint (FnConstraint [] {} empty-list no-symbol ""))
(def not-container (ReifiedConstraint UnknownType (symbol "Can not contain other values")
                                      {} {} empty-fn-constraint
                                      empty-list no-symbol ""))
(def empty-reified (ReifiedConstraint 0 no-symbol {} {}
                                      empty-fn-constraint
                                      empty-list  no-symbol ""))

(defn IntegerConstraint
  ([static-value]
   (IntegerConstraint static-value 2147483647 -2147483648 empty-list no-symbol ""))
  ([static-value max min]
   (IntegerConstraint static-value max min empty-list no-symbol ""))
  ([static-value max min path sym var]
   (ReifiedConstraint IntegerType 'Integer {}
                      {'static-value static-value 'max max 'min min}
                      empty-fn-constraint path sym var)))

(defn SymbolConstraint
  ([static-value]
   (SymbolConstraint static-value empty-list no-symbol ""))
  ([static-value path sym var]
   (ReifiedConstraint SymbolType 'Symbol {}
                      {'static-value static-value}
                      empty-fn-constraint path sym var)))

(defn OpaqueConstraint
  ([]
   (OpaqueConstraint empty-list no-symbol ""))
  ([path sym var]
   (ReifiedConstraint OpaqueType 'Opaque {} {} empty-fn-constraint path sym var)))

(defn FutureConstraint
  ([]
   (FutureConstraint empty-list no-symbol ""))
  ([path sym var]
   (ReifiedConstraint FutureType 'Future {} {} empty-fn-constraint path sym var)))

(defn MaybeConstraint
  ([contents]
   (MaybeConstraint contents empty-list no-symbol ""))
  ([contents path sym var]
   (ReifiedConstraint MaybeType 'Maybe {} {'contents contents} empty-fn-constraint path sym var)))

(defn PromiseConstraint
  ([contents]
   (PromiseConstraint contents empty-list no-symbol ""))
  ([contents path sym var]
   (ReifiedConstraint PromiseType 'Promise {} {'contents contents} empty-fn-constraint path sym var)))

(defn AgentConstraint
  ([contents]
   (AgentConstraint contents empty-list no-symbol ""))
  ([contents path sym var]
   (ReifiedConstraint AgentType 'Agent {} {'contents contents} empty-fn-constraint path sym var)))

(defn StrBuffConstraint
  ([static-value]
   (StrBuffConstraint static-value empty-list no-symbol ""))
  ([static-value path sym var]
   (ReifiedConstraint StringBufferType 'String {} {'static-value static-value} empty-fn-constraint path sym var)))

(defn SubStrConstraint
  ([static-value]
   (SubStrConstraint static-value empty-list no-symbol ""))
  ([static-value path sym var]
   (ReifiedConstraint SubStringType 'String {} {'static-value static-value} empty-fn-constraint path sym var)))


(def coll-of-any (CollectionOf top-type empty-list no-symbol ""))
(def list-constraint (ListConstraint [] top-type empty-list no-symbol ""))
(def vect-constraint (VectorConstraint [] top-type empty-list no-symbol ""))
(def seq-constraint (SumConstraint [vect-constraint list-constraint]
                                     empty-list no-symbol ""))
(def substr-constraint (SubStrConstraint no-string empty-list no-symbol ""))
(def strbuff-constraint (StrBuffConstraint no-string empty-list no-symbol ""))
(def string-constraint (SumConstraint [strbuff-constraint substr-constraint]
                                      empty-list no-symbol ""))
(def fn-constraint (FnConstraint []
                                   {variadic (fn-arity no-symbol list-constraint top-type)
                                    0 (fn-arity no-symbol empty-list-constraint
                                                  top-type)
                                    1 (fn-arity no-symbol (ListConstraint (repeat 1 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)
                                    2 (fn-arity no-symbol (ListConstraint (repeat 2 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)
                                    3 (fn-arity no-symbol (ListConstraint (repeat 3 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)
                                    4 (fn-arity no-symbol (ListConstraint (repeat 4 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)
                                    5 (fn-arity no-symbol (ListConstraint (repeat 5 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)
                                    6 (fn-arity no-symbol (ListConstraint (repeat 6 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)
                                    7 (fn-arity no-symbol (ListConstraint (repeat 7 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)
                                    8 (fn-arity no-symbol (ListConstraint (repeat 8 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)
                                    9 (fn-arity no-symbol (ListConstraint (repeat 9 top-type)
                                                                                no-tail empty-list no-symbol "")
                                                  top-type)}
                                   empty-list no-symbol ""))
(def type-of-constraint (TypeOfConstraint no-symbol empty-list no-symbol ""))
(def sym-constraint (SymbolConstraint no-symbol empty-list no-symbol ""))
(def seq-or-str-constraint (SumConstraint [vect-constraint list-constraint strbuff-constraint substr-constraint]
                                            empty-list no-symbol ""))
(def hash-coll-constraint (HashMapConstraint HashCollisionNodeType {} top-type top-type empty-list no-symbol ""))
(def array-constraint (HashMapConstraint ArrayNodeType {} top-type top-type empty-list no-symbol ""))
(def bitmap-constraint (HashMapConstraint BitmapIndexedType {} top-type top-type empty-list no-symbol ""))
(def hashmap-constraint (SumConstraint [bitmap-constraint array-constraint hash-coll-constraint]
                                         empty-list no-symbol ""))
(def int-constraint (IntegerConstraint no-int int-max int-min empty-list no-symbol ""))
(def maybe-constraint  (MaybeConstraint top-type empty-list no-symbol ""))
(def set-constraint (ReifiedConstraint HashSetType 'HashSet
                                         {(Field (symbol ".set-map")) hashmap-constraint}
                                         {(Field (symbol ".set-map")) hashmap-constraint}
                                         (.arities fn-constraint {}) empty-list no-symbol ""))
(def agent-constraint (AgentConstraint top-type empty-list no-symbol ""))
(def promise-constraint (PromiseConstraint top-type empty-list no-symbol ""))
(def future-constraint (FutureConstraint empty-list no-symbol ""))
(def opaque-constraint (OpaqueConstraint empty-list no-symbol ""))
(def arity-constraint (ReifiedConstraint FnArityType 'FnArity {} {}
                                         (.arities fn-constraint {})
                                         empty-list no-symbol ""))


(defn sum-type [const-cs]
  (assert (instance? Vector const-cs))

  (either (or (flat-map (every const-cs (partial = bottom-type))
                        (fn [_]
                          (first const-cs)))
              (let [const-cs (remove const-cs (partial = bottom-type))]
                (or (and (= 1 (count const-cs))
                         (first const-cs))
                    (and (empty? const-cs)
                         (maybe top-type))
                    (some const-cs (partial = top-type))
                    (apply = const-cs)
                    (and (every const-cs (partial instance? CollectionOf))
                         (-> const-cs
                             (map .contents)
                             sum-type
                             (CollectionOf empty-list no-symbol "")
                             maybe))
                    (and (< 1 (count const-cs))
                         (maybe (SumConstraint const-cs empty-list no-symbol ""))))))
          top-type))

(defn missing-field [fld]
  (ReifiedConstraint UnknownType (symbol (str "Field/index '" fld "' required"))
                     {} {} empty-fn-constraint
                     empty-list no-symbol ""))

(defn cant-set-contents [x fld-path]
  (either (map (first fld-path)
               (fn [fld]
                 (NoValues [x (missing-field fld)])))
          (NoValues [x (ReifiedConstraint UnknownType (symbol "Unable to set contents")
                                          {} {} empty-fn-constraint
                                          empty-list no-symbol "")])))

(defprotocol Constraint
  (set-path [c new-path]
    (assert (instance? (list-of Vector) new-path))
    (assert-result r (instance? RecurseNext r))

    (RecurseWith c))

  (extract-sym [tc]
    (assert-result r (instance? OptionalSym r))

    no-symbol)

  (update-sym [c new-sym]
    (assert (instance? OptionalSym new-sym))

    c)

  (add-to-path [constraint file-name line-number]
    constraint)

  (type-num [c]
    (assert-result r (instance? Integer r))

    UnknownType)

  (type-sym [c]
    (assert-result r (instance? OptionalSym r)))

  (assertion-path [x])

  (format-path [x n]
    (assert-result r (instance? (list-of String) r)))

  (show-full [c]
    (assert-result b (instance? (list-of String) b)))

  (set-to [x fld-path fld-c]
    (cond (empty? fld-path)
          fld-c

          (cant-set-contents x fld-path)))

  (get-from [x fld]
    (NoValues [x (missing-field fld)]))

  (contents-constraint [c]
    (NoValues [c not-container]))

  ;; replace any ParamConstraints for 'arity' with their corresponding values
  (reify-const [c arity args]
    (cata find-bottom c))

  ;; is the constraint a NoValues type, or contains one
  (find-bottom [c]
    c)

  ;; get a minimum number of items from a list or vector
  (get-items [c items-count]
    (assert-result r (instance? Vector r))

    [])

  ;; Ensure constraint is as small as possible
  (trim-const [c]
    c)

  ;; derive a new type by applying a type operation
  (derive-const [op]
    ;; TODO: perhaps this is a better impl
    ;; (fn [c]
    ;;   (intersect (map op (fn [f]
    ;;                        (f top-type)))
    ;;              c))

    ;; TODO: Make sure (fn [_] op) works as well
    (constantly op))

  ;; produces the type required by the type operation
  ;; (required [c op]
  ;;   (intersect c op))

  (intersect [c1 c2]
    ;; 'top-type' is the undefined result
    top-type))

(defn format-path* [path desired-len]
  (assert (instance? List path))
  (assert (instance? Integer desired-len))

  (either (map (first path)
               (fn [[header]]
                 (let [path (-> (rest path)
                                (remove (fn [[file line]]
                                          (either (and (instance? Symbol file)
                                                       (maybe nothing))
                                                  (or (empty? file)
                                                      (= 0 line)))))
                                (map (fn [[file line]]
                                       (let [file (str file)]
                                         (str (either (-> file
                                                          str
                                                          (split-string (partial = "/"))
                                                          last
                                                          (map (fn [file]
                                                                 (either (and (flat-map (first file)
                                                                                        (partial = "/"))
                                                                              (maybe file))
                                                                         file))))
                                                      file)
                                              ": " line)))))
                       max-width (reduce path (count header)
                                         (fn [max s]
                                           (let [n (count s)]
                                             (either (> max n)
                                                     n))))
                       path (either (and (< (count path) desired-len)
                                         (maybe (comp path (repeat (- desired-len (count path))
                                                                   (spaces max-width)))))
                                    path)]
                   (map (cons header path)
                        (fn [x]
                          (str x (spaces (- max-width (count x)))))))))
          path))

(defn replace-path [c new-path]
  (apo (fn [c]
         (set-path c new-path))
       c))

(defn update-path
  ([c loc]
   (assert (instance? Location loc))
   (update-path c (.file loc) (.line loc)))

  ([c file-name line-number]
   (cata (fn [c]
           (add-to-path c file-name line-number))
         c)))

(defn trim [c]
  (cata trim-const c))

(defn derive [op c]
  ((cata derive-const op) c))

(defn do-call-value [x y]
  (assert (instance? TypeOp x))

  (cond (instance? FnConstraint y)
        (let [args (.params x)]
          (either (or (map (instance? NoArgs args)
                           (fn [_]
                             (-> (.arities y)
                                 vals
                                 (reduce [] (fn [arities arity]
                                              (assert (instance? fn-arity arity))
                                              (conj arities (derive (.result-const arity) top-type))))
                                 sum-type)))
                      (map (or (get-in y [.arities (count args)])
                               (get-in y [.arities variadic]))
                           (fn [arity]
                             ;; TODO: make sure all param constraints are satisfied by the arg constraints
                             (let [new-args (intersect (.items empty-list-constraint args)
                                                       (.param-consts arity))
                                   reified (cond (= bottom-type new-args)
                                                 new-args

                                                 (let [fixed-count (-> arity .param-consts .items count)
                                                       [reqd var] (split (get-items new-args (count args))
                                                                          fixed-count)
                                                       new-args (conj reqd (.items empty-list-constraint var))
                                                       new-args (cata (fn [c]
                                                                        (reify-const c (.arity-id arity)
                                                                                     (repeat (count new-args)
                                                                                             top-type)))
                                                                      new-args)]
                                                   (cata (fn [c]
                                                           (reify-const c (.arity-id arity)
                                                                        new-args))
                                                         arity)))
                                   reified (cata find-bottom reified)]
                               (either (= bottom-type reified)
                                       (.result-const reified))))))

                  (NoValues [x y])))

        (instance? ReifiedConstraint y)
        (cond (instance? NoArgs (.params x))
              (do-call-value x (.invoke-fn y))

              (do-call-value (.params x (comp [y] (.params x)))
                             (.invoke-fn y)))

        (NoValues [x y])))

(defn do-set-to [x y]
  (assert (instance? TypeOp x))

  (let [[path v] (.params x)]
    (cond (empty? path)
          y

          (or (instance? ListConstraint y)
              (instance? VectorConstraint y)
              (instance? ReifiedConstraint y))
          (set-to y path v)

          (NoValues [x y]))))

(defn do-get-from [x y]
  (assert (instance? TypeOp x))

  (cond (empty? (.params x))
        y

        (or (instance? ListConstraint y)
            (instance? VectorConstraint y)
            (instance? ReifiedConstraint y))
        (either (map (first (.params x))
                     (fn [fld]
                       (do-get-from (.params x (rest (.params x)))
                                    (get-from y fld))))

                y)

        (NoValues [x y])))

(defn do-arg-of [x y]
  (assert (instance? TypeOp x))

  (let [arg-pos (.params x)]
    (cond (instance? FnConstraint y)
          (let [num-args (inc arg-pos)
                arity-args (-> (.arities y)
                               vals
                               (reduce [] (fn [arities arity]
                                            (assert (instance? fn-arity arity))
                                            (either (map (-> (.param-consts arity)
                                                             (get-items num-args)
                                                             (nth arg-pos))
                                                         (partial conj arities))
                                                    arities))))]
            (cond (empty? arity-args)
                  (NoValues [x y])

                  (sum-type arity-args)))

          (instance? ReifiedConstraint y)
          (do-arg-of (.params x (inc arg-pos))
                     (.invoke-fn y))

          (NoValues [x y]))))

(defn seq-from-str [c seq-c]
  (either (map (get-in c [.fields 'static-value])
               (fn [static]
                 (cond (= static no-string)
                       (.tail-c seq-c string-constraint)
                       (.items seq-c
                               (map (vec static)
                                    (fn [s]
                                      (cond (instance? SubString s)
                                            (assoc-in substr-constraint [.fields 'static-value]
                                                      s)
                                            (assoc-in strbuff-constraint [.fields 'static-value]
                                                      s))))))))
          (.tail-c seq-c string-constraint)))

(def type-op-fn {inner-type-of-op (fn [x y]
                                    (assert (instance? TypeOp x))

                                    (contents-constraint y))
                 first-of-op (fn [x y]
                               (assert (instance? TypeOp x))

                               (cond (instance? SeqConstraint y)
                                     (MaybeConstraint (either (first (get-items y 1))
                                                              top-type)
                                                      empty-list no-symbol "")

                                      (and (instance? ReifiedConstraint y)
                                           (or (= (.type-number y) StringBufferType)
                                               (= (.type-number y) SubStringType)))
                                      (MaybeConstraint string-constraint empty-list no-symbol "")

                                     (NoValues [x y])))
                 last-of-op (fn [x y]
                              (assert (instance? TypeOp x))

                              (cond (instance? SeqConstraint y)
                                    (let [y (trim y)]
                                      (MaybeConstraint (either (and (= no-tail (.tail-c y))
                                                                    (last (.items y)))

                                                               (either (first (get-items (.tail-c y) 1))
                                                                       top-type))
                                                       empty-list no-symbol ""))

                                      (and (instance? ReifiedConstraint y)
                                           (or (= (.type-number y) StringBufferType)
                                               (= (.type-number y) SubStringType)))
                                      (MaybeConstraint string-constraint empty-list no-symbol "")

                                    (NoValues [x y])))
                 rest-of-op (fn [x y]
                              (assert (instance? TypeOp x))

                              (cond (instance? SeqConstraint y)
                                    (let [y (trim y)]
                                      (.items y (rest (.items y))))

                                      (and (instance? ReifiedConstraint y)
                                           (or (= (.type-number y) StringBufferType)
                                               (= (.type-number y) SubStringType)))
                                      string-constraint

                                    (NoValues [x y])))
                 butlast-of-op (fn [x y]
                                 (assert (instance? TypeOp x))

                                 (cond (instance? SeqConstraint y)
                                       (let [y (trim y)]
                                         (cond (= (.tail-c y) no-tail)
                                               (.items y (butlast (.items y)))

                                               y))

                                      (and (instance? ReifiedConstraint y)
                                           (or (= (.type-number y) StringBufferType)
                                               (= (.type-number y) SubStringType)))
                                      string-constraint

                                       (NoValues [x y])))
                 list-from-op (fn [x y]
                                (assert (instance? TypeOp x))

                                (cond (instance? ListConstraint y)
                                      y

                                      (instance? VectorConstraint y)
                                      (let [y (trim y)]
                                        (-> empty-list-constraint
                                            (.items (.items y))
                                            (.tail-c (.tail-c y))
                                            (.path (comp (.path y) (.path x)))))

                                      (and (instance? ReifiedConstraint y)
                                           (or (= (.type-number y) StringBufferType)
                                               (= (.type-number y) SubStringType)))
                                      (-> (seq-from-str y empty-list-constraint)
                                          (.path (comp (.path y) (.path x))))

                                      (NoValues [x y])))
                 vect-from-op (fn [x y]
                                (assert (instance? TypeOp x))

                                (cond (instance? VectorConstraint y)
                                      y

                                      (instance? ListConstraint y)
                                      (let [y (trim y)]
                                        (-> empty-vect-constraint
                                            (.items (.items y))
                                            (.tail-c (.tail-c y))
                                            (.path (comp (.path y) (.path x)))))

                                      (and (instance? ReifiedConstraint y)
                                           (or (= (.type-number y) StringBufferType)
                                               (= (.type-number y) SubStringType)))
                                      (-> (seq-from-str y empty-vect-constraint)
                                          (.path (comp (.path y) (.path x))))

                                      (NoValues [x y])))
                 arg-of-op do-arg-of
                 get-from-op do-get-from
                 set-to-op do-set-to
                 call-value-op do-call-value})

(defn execute-type-op [x y]
  (assert (instance? TypeOp y))

  (cond (=* x y)
        x

        (or (instance? AllValues x)
            (instance? NoValues x)
            (instance? ParamConstraint x)
            (instance? ComputedConstraint x)
            (instance? SumConstraint x))
        (intersect y x)

        (instance? TypeOp x)
        (ComputedConstraint [x y] empty-list no-symbol "")

        (either (map (get type-op-fn (.op-code y))
                     (fn [f]
                       (f y x)))
                top-type)))

(extend-type ValueConstraint
  Constraint
  (add-to-path [c file line]
    (cond (or (= file "")
              (some (.path c) (partial = [file line])))
          c
          (.path c (cons [file line] (.path c))))))

(extend-type SymbolConstraints
  Constraint
  (set-path [c new-path]
    (RecurseFinal (.path c new-path)))

  (extract-sym [c]
    (.sym c))

  (update-sym [c new-sym]
    (.sym c new-sym)))

(extend-type NoTail
  Constraint
  (assertion-path [_] empty-list)

  (format-path [_ n]
    (list "No Tail for sequence"))

  (show-full [c]
    (list "c/no-tail")))

(extend-type AllValues
  Constraint
  (format-path [x desired-len]
    (list "<Unknown Type>"))

  (show-full [c]
    (format-path c 0))

  (contents-constraint [c]
    c)

  (get-items [c items-count]
    (repeat items-count c))

  (intersect [x y]
    (cond (instance? TypeOp y)
          x
          y)))

(extend-type NoValues
  Constraint
  (format-path [c n]
    (let [max-len (-> (trim c)
                      .constraints
                      (map (fn [c] (count (assertion-path c))))
                      (reduce n (fn [max-len path-len]
                                  (either (> max-len path-len)
                                          path-len)))
                      inc)]
      (-> (.constraints c)
          (map (fn [c]
                 (format-path c max-len)))
          (list-zipper empty-list)
          (map (fn [strs]
                 (str (to-str (interpose strs "    "))
                      "\n"))))))

  (show-full [c]
    (comp (list "Conflicting types")
          (map (.constraints c) (partial str "  "))))

  (contents-constraint [c]
    c)

  (reify-const [c arity args]
    c)

  (trim-const [c]
    (.constraints c (comp (remove (.constraints c) (partial instance? NoValues))
                          (-> (.constraints c)
                              (filter (partial instance? NoValues))
                              (flat-map .constraints)))))

  (intersect [x _] x))

(defn str-inner [sc]
  (either (map (get-in sc [.fields 'static-value])
               (fn [sv]
                 (cond (= sv no-string)
                       string-constraint

                       (-> sv
                           vec
                           (map (fn [c]
                                  (StrBuffConstraint c empty-list no-symbol "")))
                           sum-type))))
          string-constraint))

(defn intersect-seqs [l1 l2]
  (assert (instance? SeqConstraint l1))
  (assert (instance? SeqConstraint l2))

  (let [l1 (trim l1)
        l1-tail (.tail-c l1)
        l2 (trim l2)
        l2-tail (.tail-c l2)
        cnt-ic (count (.items l2))
        cnt-c (count (.items l1))
        max-cnt (either (> cnt-ic cnt-c)
                        cnt-c)
        items (map (zip-lists (get-items l1 max-cnt)
                              (get-items l2 max-cnt))
                   (fn [[c1 c2]]
                     (intersect c1 c2)))
        new-tail (either (or (= no-tail l1-tail)
                             (= no-tail l2-tail))
                         (intersect l1-tail l2-tail))
        new-ic (-> l2
                   (.tail-c new-tail)
                   (.items (vec items)))]
    (either (map (or (some items (partial = bottom-type))
                     (= bottom-type new-tail))
                 (fn [failure]
                   (cond (empty? (.constraints failure))
                         (NoValues [l1 l2])

                         failure)))
            (cond (< (count items) max-cnt)
                  (NoValues [l1 l2])

                  new-ic))))

(extend-type ListConstraint
  Constraint
  (type-num [c] ListType)

  (type-sym [_] 'List)

  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons ["List from:" ""] (.path x))
                  desired-len))

  (show-full [c]
    (comp (format-path c 0)
          ["--items--"]
          (-> (.items c)
              (interpose ["----"])
              (flat-map (fn [item-strs]
                          (map item-strs (partial str "  ")))))
          (cond (= (show-full bottom-type) (.tail-c c))
                []
                (comp ["--tail--"]
                      (map (.tail-c c) (partial str "  "))))
          ["===="]))

  (set-to [x fld-path fld-c]
    (-> (cond (empty? fld-path)
              fld-c

              (either (for [idx (first fld-path)
                            :when (and (instance? ReifiedConstraint idx)
                                       (= IntegerType (.type-number idx)))
                            idx (get-in idx [.fields 'static-value])
                            :when-not (= idx no-int)
                            :let [items-count (inc idx)
                                  old-items (cond (<= items-count (count (.items x)))
                                                  (.items x)

                                                  (get-items x items-count))]
                            old-item (nth old-items idx)
                            new-items (store old-items idx
                                             (set-to old-item (rest fld-path) fld-c))]
                        (.items x new-items))
                      (cant-set-contents x fld-path)))
        find-bottom))

  (get-from [x idx]
    (either (for [_ (and (instance? ReifiedConstraint idx)
                         (= IntegerType (.type-number idx)))
                  idx (get-in idx [.fields 'static-value])
                  :when-not (= idx no-int)
                  item (nth (get-items x (inc idx)) idx)]
              item)
            (NoValues [x (missing-field idx)])))

  (contents-constraint [c]
    (cond (and (empty? (.items c))
               (= no-tail (.tail-c c)))
          top-type

          (-> (.items c)
              (conj (either (map (= no-tail (.tail-c c)) (fn [_]
                                                           top-type))
                            (.tail-c c)))
              (remove (partial = top-type))
              sum-type)))

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [contents]
                           (contents top-type)))
                 c)))

  (find-bottom [c]
    (either (or (some (.items c) (partial = bottom-type))
                (= bottom-type (.tail-c c)))
            c))

  (get-items [c items-count]
    (let [fixed (take (.items c) items-count)
          fixed-count (count fixed)]
      (cond (= fixed-count items-count)
            fixed

            (= no-tail (.tail-c c))
            []

            (comp fixed
                  (get-items (.tail-c c) (- items-count fixed-count))))))

  (trim-const [lc]
    (either (map (instance? SeqConstraint (.tail-c lc))
                 (fn [tail-c]
                   (-> lc
                       (.items (comp (.items lc) (.items tail-c)))
                       (.tail-c (.tail-c tail-c)))))
            lc))

  (intersect [x y]
    (cond (or (instance? ParamConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? ComputedConstraint y)
              (instance? SumConstraint y))
          (intersect y x)

          (instance? TypeOp y)
          (execute-type-op x y)

          (instance? ListConstraint y)
          (intersect-seqs x y)

          (instance? CollectionOf y)
          (intersect-seqs x (.tail-c empty-list-constraint y))

          (NoValues [x y]))))

(extend-type VectorConstraint
  Constraint
  (type-num [c] VectorType)

  (type-sym [_] 'Vector)

  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons ["Vector from:" ""] (.path x))
                  desired-len))

  (show-full [c]
    (comp (format-path c 0)
          ["--items--"]
          (-> (.items c)
              (interpose ["----"])
              (flat-map (fn [item-strs]
                          (map item-strs (partial str "  ")))))
          (cond (= (show-full bottom-type) (.tail-c c))
                []
                (comp ["--tail--"]
                      (map (.tail-c c) (partial str "  "))))
          ["===="]))

  (set-to [x fld-path fld-c]
    (-> (cond (empty? fld-path)
              fld-c

              (either (for [idx (first fld-path)
                            :when (and (instance? ReifiedConstraint idx)
                                       (= IntegerType (.type-number idx)))
                            idx (get-in idx [.fields 'static-value])
                            :when-not (= idx no-int)
                            :let [items-count (inc idx)
                                  old-items (cond (<= items-count (count (.items x)))
                                                  (.items x)

                                                  (get-items x items-count))]
                            old-item (nth old-items idx)
                            new-items (store old-items idx
                                             (set-to old-item (rest fld-path) fld-c))]
                        (.items x new-items))
                      (cant-set-contents x fld-path)))
        find-bottom))

  (get-from [x idx]
    (either (for [_ (and (instance? ReifiedConstraint idx)
                         (= IntegerType (.type-number idx)))
                  idx (get-in idx [.fields 'static-value])
                  :when-not (= idx no-int)
                  item (nth (get-items x (inc idx)) idx)]
              item)
            (NoValues [x (missing-field idx)])))

  (contents-constraint [c]
    (cond (and (empty? (.items c))
               (= no-tail (.tail-c c)))
          top-type

          (-> (.items c)
              (conj (either (map (= no-tail (.tail-c c)) (fn [_]
                                                           top-type))
                            (.tail-c c)))
              (remove (partial = top-type))
              sum-type)))

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [contents]
                           (contents top-type)))
                 c)))

  (find-bottom [c]
    (either (or (some (.items c) (partial = bottom-type))
                (= bottom-type (.tail-c c)))
            c))

  (get-items [c items-count]
    (let [fixed (take (.items c) items-count)
          fixed-count (count fixed)]
      (cond (= fixed-count items-count)
            fixed

            (= no-tail (.tail-c c))
            []

            (comp fixed
                  (get-items (.tail-c c) (- items-count fixed-count))))))

  (trim-const [vc]
    (either (map (instance? SeqConstraint (.tail-c vc))
                 (fn [tail-c]
                   (-> vc
                       (.items (comp (.items vc) (.items tail-c)))
                       (.tail-c (.tail-c tail-c)))))
            vc))

  (intersect [x y]
    (cond (or (instance? ParamConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? ComputedConstraint y)
              (instance? SumConstraint y))
          (intersect y x)

          (instance? TypeOp y)
          (execute-type-op x y)

          (instance? VectorConstraint y)
          (intersect-seqs x y)

          (instance? CollectionOf y)
          (intersect-seqs x (.tail-c empty-vect-constraint y))

          (NoValues [x y]))))

(extend-type SumConstraint
  Constraint
  (type-num [c]
    (either (apply = (map (.alts c) type-num))
            UnknownType))

  (assertion-path [c] (.path c))

  (format-path [c n]
    (let [sum-sym (either (apply = (map (.alts c) type-sym))
                          "Sum Type")]
      (format-path* (cons [(str sum-sym " from") ""] (.path c))
                    n)))

  (show-full [c]
    (comp (format-path c 0)
          (-> (.alts c)
              (interpose ["----"])
              (flat-map (fn [alt-strs]
                          (map alt-strs (partial str "  ")))))))

  (contents-constraint [c]
    c)

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [contents]
                           (contents top-type)))
                 c)))

  (find-bottom [c]
    (either (flat-map (every (.alts c) (partial = bottom-type))
                      first)
            (.alts c (remove (.alts c) (partial = bottom-type)))))

  (get-items [c items-count]
    (let [alts-items (-> (.alts c)
                         (map (fn [alt]
                                (get-items alt items-count)))
                         (filter (fn [alt]
                                   (= items-count (count alt)))))]
      (either (empty? alts-items)
              (-> (apply zip-lists alts-items)
                  (map (fn [alts]
                         (sum-type (vec alts))))
                  vec))))

  (trim-const [c]
    (let [all-alts (flat-map (.alts c) (fn [c]
                                         (either (map (instance? SumConstraint c) .alts)
                                                 [c])))
          new-c (sum-type all-alts)
          trimmed (cond (instance? SymbolConstraints new-c)
                        (.sym new-c (.sym c))
                        new-c)]
      (either (map (instance? SumConstraint trimmed)
                   (fn [_]
                     (.path trimmed (.path c))))
              trimmed)))

  (intersect [x y]
    (cond (= x y)
          x

          (instance? SumConstraint y)
          (let [new-alts (for [a1 (.alts x)
                               a2 (.alts y)
                               :let [new-alt (intersect a1 a2)]
                               :when-not (= bottom-type new-alt)]
                           new-alt)
                new-alts (reduce new-alts [] (fn [new-alts alt]
                                               (either (and (some new-alts (partial =* alt))
                                                            (maybe new-alts))
                                                       (conj new-alts alt))))]
            (either (or (and (empty? new-alts)
                             (maybe (NoValues [x y])))
                        (and (= 1 (count new-alts))
                             (first new-alts)))
                    (.alts x new-alts)))

          (instance? ParamConstraint y)
          (ComputedConstraint [x y] (.path x) (.sym x) (.var x))

          (instance? ComputedConstraint y)
          (cond (some (.mods y) (partial = x))
                y
                (.mods y (comp [x] (.mods y))))

          (let [inters (map (.alts x) (fn [alt]
                                        (intersect alt y)))
                goods (-> inters
                          (remove (partial instance? NoValues))
                          (reduce [] (fn [goods y]
                                       (either (and (some goods (partial = y))
                                                    (maybe goods))
                                               (conj goods y)))))]
            (either (or (and (empty? goods)
                             (or (apply = inters)
                                 (maybe (NoValues [x y]))))
                        (and (= (count goods) 1)
                             (first goods)))
                    (.alts x goods))))))

(extend-type CollectionOf
  Constraint
  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (cons ["Contents from" ""] (.path c))
                  desired-len))

  (show-full [c]
    (comp (format-path c 0)
          (map (.contents c) (partial str "  "))))

  (contents-constraint [c]
    (.contents c))

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [contents]
                           (contents top-type)))
                 c)))

  (find-bottom [c]
    (either (= bottom-type (.contents c))
            c))

  (get-items [c items-count]
    (repeat items-count (.contents c)))

  (intersect [x y]
    (cond (instance? CollectionOf y)
          (let [new-cs (intersect (.contents y) (.contents x))]
            (either (or (= new-cs bottom-type)
                        (= x y))
                    (.contents x new-cs)))

          (instance? TypeOp y)
          (execute-type-op x y)

          (intersect y x))))

(defn merge-mods [mods1 mods2 new-c]
  (assert (instance? Sequence mods1))
  (assert (instance? Sequence mods2))
  (assert (instance? ComputedConstraint new-c))

  (cond (empty? mods1)
        (.mods new-c (comp (.mods new-c) mods2))

        (empty? mods2)
        (.mods new-c (comp (.mods new-c) mods1))

        (let [[mod1 & rest-mods1] mods1
              [mod2 & rest-mods2] mods2]
          (cond (and (instance? TypeOp mod1)
                     (instance? TypeOp mod2))
                (either (map (= mod1 mod2)
                             (fn [_]
                               (merge-mods rest-mods1 rest-mods2
                                           (.mods new-c (conj (.mods new-c) mod1)))))
                        (intersect mod1 mod2))

                (instance? ComputedConstraint mod1)
                (merge-mods (comp (.mods mod1) rest-mods1) mods2
                            new-c)

                (instance? ComputedConstraint mod2)
                (merge-mods mods1 (comp (.mods mod2) rest-mods2)
                            new-c)

                (instance? TypeOp mod1)
                (merge-mods mods1 rest-mods2
                            (.mods new-c (conj (.mods new-c) mod2)))

                (instance? TypeOp mod2)
                (merge-mods rest-mods1 mods2
                            (.mods new-c (conj (.mods new-c) mod1)))

                (let [new-mod (intersect mod1 mod2)]
                  (either (= bottom-type new-mod)
                          (merge-mods rest-mods1 rest-mods2
                                      (.mods new-c (conj (.mods new-c) new-mod)))))))))

(extend-type ComputedConstraint
  Constraint
  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (cons ["Type computed by" ""] (.path c))
                  desired-len))

  (show-full [c]
    (comp (format-path c 0)
          (-> (.mods c)
              (interpose (list "---"))
              (flat-map (fn [mod-strs]
                          (map mod-strs (partial str "  ")))))))

  (contents-constraint [c]
    (intersect c inner-type-of))

  (reify-const [c arity args]
    (let [[mod & mods] (.mods c)]
      (reduce mods mod intersect)))

  (type-num [c]
    (let [new-c (derive c top-type)]
      (cond (instance? ComputedConstraint new-c)
            UnknownType

            (type-num new-c))))

  (derive-const [op]
    (fn [c]
      (reduce (.mods op) c
              (fn [c op-fn]
                (op-fn c)))))

  (find-bottom [c]
    (either (= bottom-type (derive c top-type))
            c))

  (get-items [c items-count]
    (get-items (derive c top-type) items-count))

  (trim-const [c]
    (.mods c (reduce (.mods c) []
                     (fn [new-mods mod]
                       (cond (instance? ComputedConstraint mod)
                             (comp new-mods (.mods mod))
                             (conj new-mods mod))))))

  (intersect [x y]
    (cond (=* x y)
          x

          (or (instance? AllValues y)
              (instance? NoValues y))
          (intersect y x)

          (instance? ComputedConstraint y)
          ;; TODO: this logic seems complex. Try to simplify
          (cond (or (some (.mods x) (partial instance? TypeOp))
                    (some (.mods y) (partial instance? TypeOp)))
                (merge-mods (.mods x) (.mods y) (.mods x []))
                ;; (either (or (and (= (subvec (.mods y) 0 (count (.mods x)))
                ;;                     (.mods x))
                ;;                  (maybe y))
                ;;             (and (= (subvec (.mods x) 0 (count (.mods y)))
                ;;                     (.mods y))
                ;;                  (maybe x)))
                ;;         (do
                ;;           (print-err "Dropping ComputedConstraint" _FILE_ _LINE_
                ;;                      "\n\n" 'x x
                ;;                      "\n\n" 'y y)
                ;;           top-type))


                (.mods x (reduce (.mods y) (.mods x)
                                 (fn [mods mod]
                                   (cond (some mods (partial = mod))
                                         mods
                                         (conj mods mod))))))

          (let [x-mods (.mods x)]
            (cond (some x-mods (partial instance? TypeOp))
                  (.mods x (conj x-mods y))

                  (some x-mods (partial = y))
                  x

                  (.mods x (conj x-mods y)))))))

(extend-type ParamConstraint
  Constraint
  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (cons [(str "Parameter " (.param-index c) " from") ""] (.path c))
                  desired-len))

  (show-full [c]
    (format-path c 0))

  (contents-constraint [c]
    (intersect c inner-type-of))

  (reify-const [c arity args]
    (cond (= (.arity c) arity)
          (either (get args (.param-index c))
                  top-type)

          c))

  (derive-const [op]
    (fn [c]
      c))

  (intersect [x y]
    (cond (=* x y)
          x

          (or (instance? AllValues y)
              (instance? NoValues y))
          (intersect y x)

          (instance? ComputedConstraint y)
          (cond (some (.mods y) (partial = x))
                y
                (.mods y (comp [x] (.mods y))))

          (ComputedConstraint [x y] (.path x) (.sym x) (.var x)))))

(extend-type fn-arity
  Eq
  (=* [x y]
    (flat-map (instance? fn-arity y)
              (fn [_]
                (let [old-id (.arity-id y)
                      y (cata (fn [c]
                                (cond (and (instance? ParamConstraint c)
                                           (= old-id (.arity c)))
                                      (.arity c (.arity-id x))

                                      c))
                              y)]
                  (and (= (.param-consts x) (.param-consts y))
                       (= (.result-const x) (.result-const y))
                       (maybe x))))))

  Constraint
  (show-full [c]
    (comp (list (str "arity: " (.arity-id c))
                "--parameters--")
          (->  (.param-consts c)
               (.items)
               (interpose ["----"])
               (flat-map (fn [item-strs]
                           (map item-strs (partial str "  ")))))
          (let [tail-c (.tail-c (.param-consts c))]
            (cond (first tail-c)
                  (comp ["--variadic params--"]
                        (map tail-c (partial str "  ")))
                  []))
          ["--result--"]
          (map (.result-const c) (partial str "  "))))

  (derive-const [op]
    (fn [c]
      (map op (fn [contents]
                (contents top-type)))))

  (find-bottom [c]
    (either (or (-> (.param-consts c)
                    .items
                    (some (partial = bottom-type)))
                (-> (.param-consts c)
                    .tail-c
                    (= bottom-type))
                (= bottom-type (.result-const c)))
            c))

  (intersect [ar1 ar2]
    (assert (instance? fn-arity ar2))

    (let [param-cs (intersect (.param-consts ar1) (.param-consts ar2))
          result-c (intersect (.result-const ar1) (.result-const ar2))
          arity-id (cond (= no-symbol (.arity-id ar1))
                         (.arity-id ar2)

                         (.arity-id ar1))]
      (either (or (= bottom-type (cata find-bottom param-cs))
                  (= bottom-type (cata find-bottom result-c)))

              (-> ar1
                  (.arity-id arity-id)
                  (.param-consts param-cs)
                  (.result-const result-c))))))

(defn intersect-fns [y x]
  (either (or (=* x y)
              (and (empty? (.arities x))
                   (maybe y))
              (and (empty? (.arities y))
                   (maybe x)))
          (let [new-required (reduce (.required-arities x) (.required-arities y)
                                     (fn [new-reqd arity-rank]
                                       (cond (some new-reqd (partial = arity-rank))
                                             new-reqd

                                             (conj new-reqd arity-rank))))
                maybe-variadic-x (get-in x [.arities variadic])
                maybe-variadic-y (get-in y [.arities variadic])
                new-arities (reduce (vec (.arities y)) {}
                                    (fn [arities [idx y-arity]]
                                      (either (for [_ (instance? Integer idx)
                                                    x-arity (or (get-in x [.arities idx])
                                                                maybe-variadic-x)]
                                                (assoc arities idx (intersect x-arity y-arity)))
                                              arities)))
                new-arities (reduce (vec (.arities x)) new-arities
                                    (fn [arities [idx x-arity]]
                                      (cond (get arities idx)
                                            arities

                                            (either (for [_ (instance? Integer idx)
                                                          y-arity (or (get-in y [.arities idx])
                                                                      maybe-variadic-y)]
                                                      (assoc arities idx (intersect x-arity y-arity)))
                                                    arities))))
                new-arities (either (for [variadic-x maybe-variadic-x
                                          variadic-y maybe-variadic-y]
                                      (assoc new-arities variadic (intersect variadic-x variadic-y)))
                                    new-arities)
                new-arities (reduce (vec new-arities) {}
                                    (fn [new-arities [k v]]
                                      (cond (= bottom-type v)
                                            new-arities

                                            (assoc new-arities k v))))]
            (cond (empty? new-arities)
                  (NoValues [x y])

                  (every new-required (partial get new-arities))
                  (-> x
                      (.required-arities new-required)
                      (.arities new-arities))

                  (NoValues [x y])))))

(extend-type FnConstraint
  Constraint
  (type-num [c] FunctionType)

  (type-sym [_] 'Fn)

  (assertion-path [c] (.path c))

  (format-path [x desired-len]
    (format-path* (cons ["Function from" ""] (.path x))
                  desired-len))

  (show-full [c]
    (comp (format-path c 0)
          ["---------"]
          (-> (.arities c)
              vals
              (interpose ["----"])
              flatten
              (map (partial str "  ")))))

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [contents]
                           (contents top-type)))
                 c)))

  (find-bottom [c]
    (either (some (vals (.arities c)) (partial = bottom-type))
            c))

  (intersect [x y]
    (cond (=* x y)
          x

          (or (instance? ParamConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? ComputedConstraint y)
              (instance? SumConstraint y)
              (instance? ReifiedConstraint y))
          (intersect y x)

          (instance? TypeOp y)
          (execute-type-op x y)

          (instance? CollectionOf y)
          (let [new-result (.contents y)]
            (cata find-bottom
                  (map x (fn [arity]
                           (.result-const arity (intersect (.result-const arity) new-result))))))

          (instance? FnConstraint y)
          (intersect-fns x y)

          (NoValues [x y]))))

(defn intersect-simple-container [x y]
  (either (for [_ (= (type-num x) (type-num y))
                cnts-x (get-in x [.fields 'contents])
                cnts-y (get-in y [.fields 'contents])]
            (let [new-cnts (intersect cnts-x cnts-y)]
              (either (= bottom-type new-cnts)
                      (assoc-in x [.fields 'contents] new-cnts))))

          (NoValues [x y])))

(defn intersect-int [x y]
  (either (for [min-x (get-in x [.fields 'min])
                max-x (get-in x [.fields 'max])
                static-x (get-in x [.fields 'static-value])
                min-y (get-in y [.fields 'min])
                max-y (get-in y [.fields 'max])
                static-y (get-in y [.fields 'static-value])
                :let [new-min (either (> min-x min-y)
                                      min-y)
                      new-max (either (< max-x max-y)
                                      max-y)]
                new-static (or (= static-x static-y)
                               (flat-map (or (= static-x static-y)
                                             (and (= static-x no-int)
                                                  (maybe static-y))
                                             (and (= static-y no-int)
                                                  (maybe static-x)))
                                         (fn [new-static]
                                           (and (<= new-min new-static new-max)
                                                (maybe new-static)))))]
            ;; TODO: use the path from the most restrictive constraint
            ;; determined by satisfied-by
            (.fields x {'min new-min 'max new-max 'static-value new-static}))
          (NoValues [x y])))

(defn intersect-static [x y]
  (either (for [sv-x (get-in x [.fields 'static-value])
                sv-y (get-in y [.fields 'static-value])
                new-sv (or (= sv-x sv-y)
                           (and (instance? NoStatic sv-x)
                                (maybe sv-y))
                           (and (instance? NoStatic sv-y)
                                (maybe sv-x)))]
            (assoc-in x [.fields 'static-value] new-sv))
          (NoValues [x y])))

(def intersectors {IntegerType intersect-int
                   SymbolType intersect-static
                   SubStringType intersect-static
                   StringBufferType intersect-static
                   OpaqueType (fn [x y] (NoValues [x y]))
                   FutureType (fn [x y] (NoValues [x y]))
                   MaybeType intersect-simple-container
                   PromiseType intersect-simple-container
                   AgentType intersect-simple-container})

(defn intersect-reified [x y]
  (either (map (get intersectors (type-num x))
               (fn [f]
                 (f x y)))

          (cata find-bottom (.fields x (merge-with intersect (.fields x) (.fields y))))))

(defn format-static-value [c]
  (assert (instance? ReifiedConstraint c))

  (either (map (get (.fields c) 'static-value)
               (fn [sv]
                 (cond (or (= no-symbol sv)
                           (= no-int sv)
                           (= IntegerType (type-num c)))
                       (str sv " ")

                       (= SymbolType (type-num c))
                       (str "'" sv " ")

                       "")))
          ""))

(extend-type ReifiedConstraint
  Constraint
  (contents-constraint [c]
    (either (or (map (or (= StringBufferType (type-num c))
                         (= SubStringType (type-num c)))
                     (fn [_]
                       (str-inner c)))
                (get-in c [.fields 'contents]))
            (NoValues [c not-container])))

  (type-sym [c]
    (.type-symbol c))

  (type-num [c]
    (.type-number c))

  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (cons [(str (type-sym c) " " (format-static-value c) "from:") ""]
                        (.path c))
                  desired-len))

  (show-full [c]
    (cons (str "Type: " (type-sym c))
          (show-full (.invoke-fn c))))

  (set-to [x fld-path fld-c]
    (-> (cond (empty? fld-path)
              fld-c

              (either (for [fld (first fld-path)
                            field-check (get (.field-consts x) fld)
                            curr-field (get (.fields x) fld)
                            :let [new-field (set-to curr-field (rest fld-path) fld-c)
                                  final-field (intersect field-check new-field)]
                            final-field (or (= bottom-type final-field)
                                            (= final-field new-field))]
                        (.fields x (assoc (.fields x) fld final-field)))
                      (cant-set-contents x fld-path)))
        find-bottom))

  (get-from [c fld-c]
    (either (or (get (.fields c) fld-c)
                (get (.field-consts c) fld-c))
            (NoValues [c (missing-field fld-c)])))

  (derive-const [op]
    (fn [c]
      (intersect (map op (fn [contents]
                           (contents top-type)))
                 c)))

  (find-bottom [c]
    (either (or (some (seq (.fields c)) (fn [[fld-c val-c]]
                                          (or (= bottom-type fld-c)
                                              (= bottom-type val-c))))
                (= bottom-type (.invoke-fn c)))
            c))

  (intersect [x y]
    (cond (=* x y)
          x

          (or (instance? ParamConstraint y)
              (instance? AllValues y)
              (instance? NoValues y)
              (instance? ComputedConstraint y)
              (instance? SumConstraint y))
          (intersect y x)

          (instance? TypeOp y)
          (execute-type-op x y)

          (instance? CollectionOf y)
          (either (or (map (or (= StringBufferType (type-num x))
                               (= SubStringType (type-num x)))
                           (fn [_]
                             (let [intersected (intersect (str-inner x) (.contents y))]
                               (cond (= intersected bottom-type)
                                     (NoValues [x y])

                                     intersected))))
                      (for [cnts-x (or (get-in x [.fields 'contents])
                                       (maybe (NoValues [x not-container])))
                            cnts-y (get y .contents)]
                        (let [new-cnts (intersect cnts-x cnts-y)]
                          (either (= bottom-type new-cnts)
                                  (assoc-in x [.fields 'contents] new-cnts)))))

                  (NoValues [x y]))

          (instance? FnConstraint y)
          (let [new-invoke (intersect-fns (.invoke-fn x) y)]
            (either (= bottom-type new-invoke)
                    (.invoke-fn x new-invoke)))

          (and (instance? ReifiedConstraint y)
               (= (type-num x) (type-num y)))
          (intersect-reified x y)

          (NoValues [x y]))))

(def type-op-msg {inner-type-of-op (constantly ["Inner type of value from" ""])
                  first-of-op (constantly ["First value of seq" ""])
                  last-of-op (constantly ["Last value of seq" ""])
                  rest-of-op (constantly ["Rest of seq" ""])
                  butlast-of-op (constantly ["All but the last value of seq" ""])
                  list-from-op (constantly ["List from value" ""])
                  vect-from-op (constantly ["Vector from value" ""])
                  ;; TODO: make these fns that take a parameter
                  arg-of-op (constantly [(str "Argument ?? of") ""])
                  call-value-op (fn [c] ["Called at " ""])})

(extend-type TypeOp
  Constraint
  (derive-const [op]
    (fn [c]
      (let [op (map op (fn [f]
                         (f top-type)))]
        (cond (= c top-type)
              c

              (instance? TypeOp op)
              (intersect c op)

              (trim (ComputedConstraint [c op]
                                        empty-list no-symbol ""))))))

  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (cons (either (map (get type-op-msg (.op-code c))
                                     (fn [msg-f]
                                       (msg-f c)))
                                [(str "Type operation" (.op-code c)) ""])
                        (.path c))
                  desired-len))

  (show-full [c]
    (format-path c 0))

  (intersect [x y]
    (cond (=* x y)
          x

          (or (instance? AllValues y)
              (instance? NoValues y))
          (intersect y x)

          (instance? ComputedConstraint y)
          (cond (some (.mods y) (partial = x))
                y
                (.mods y (comp [x] (.mods y))))

          (ComputedConstraint [x y] empty-list no-symbol ""))))

(extend-type Field
  Constraint
  (show-full [c]
    (list "Field " (str (.sym c)))))

(extend-type TypeOfConstraint
  Constraint
  (assertion-path [c] (.path c))

  (format-path [c desired-len]
    (format-path* (cons ["Type of value from" ""] (.path c))
                  desired-len))

  (show-full [c]
    (string-list c)))

;; (extend-type HashMapConstraint)


;; misc
;; Going to try and do without these
;; DebugConstraint

(def core-type-constraints {'Integer int-constraint
                            'StringBuffer strbuff-constraint
                            'SubString substr-constraint
                            'FnArity arity-constraint
                            'BitmapIndexedNode bitmap-constraint
                            'ArrayNode array-constraint
                            'HashCollisionNode hash-coll-constraint
                            'Fn fn-constraint
                            'List list-constraint
                            'Maybe maybe-constraint
                            'Vector vect-constraint
                            'Symbol sym-constraint
                            'HashMap hashmap-constraint
                            'Promise promise-constraint
                            'Future future-constraint
                            'Agent agent-constraint
                            'Opaque opaque-constraint})

;; combine two constraints to produce a new constraint
;; that is the same or more restrictive than either constraint

(defn is-bottom [c]
  (cata find-bottom c))

(defn set-items [c items]
  (assert (instance? Vector items))

  (apo (fn [c]
         (cond (instance? SeqConstraint c)
               (RecurseFinal (.items c items))

               (RecurseWith c)))
       c))

(defn set-tail [c tail]
  (apo (fn [c]
         (cond (instance? SeqConstraint c)
               (RecurseFinal (.tail-c c tail))

               (RecurseWith c)))
       c))

(defn reify-type-constraint [arity arity-id arg-cs loc]
  (assert (instance? Vector arg-cs))

  ;; (or ;; (= (.file loc) 'core)
  ;;     ;; (= (.line loc) 0)
  ;;     (and (= arity-id 'extract)
  ;;          (do
  ;;            (print-err 'reifying _LINE_ loc arity-id "\n"
  ;;                       arity "\n\n"
  ;;                       'args arg-cs)
  ;;            nothing)))
  (let [r (cata (fn [c]
                  (reify-const c arity-id arg-cs))
                arity)]
    (-> r
        trim
        (update-path loc))))
