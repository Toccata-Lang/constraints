
;; TODO: don't need this after hash-map literals are properly encoded
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -1, ListType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -1, VectorType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -1, IntegerType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -1, SymbolType};"))

(defprotocol Constraint
  (assertion-path [x])

  (format-path [x n])

  (intersect [c1 c2])

  (restrict-types [c type-map]
    type-map)

  (extract-type-map [_]
    (assert-result r (instance? Maybe r)))

  (extract-items-constraints [_]
    (assert-result r (instance? Vector r))
    [])

  (extract-inner-constraint [_])

  (update-path [constraint file-name line-number]
    constraint)

  (update-sym [tc new-sym]
    (assert (instance? Tagged new-sym)))

  (update-var [tc new-var]
    (assert (instance? String new-var)))

  (satisfied-by [c info]
    (assert-result r (instance? Maybe r))
    ;; TODO: the whole idea behind this function is suspect
    nothing))

;; TODO: constraints to add
;; min count (instead of ItemsConstraint)
;; min value
;; keys required in a hash map
;; key constraint on hash maps

(defn format-path* [path desired-len]
  (either (empty? path)
          (let [path (-> path
                         (remove (fn [[file line]]
                                   (either (and (instance? Symbol file)
                                                (maybe nothing))
                                           (or (empty? file)
                                               (= 0 line)))))
                         (map (fn [[file line]]
                                (str file ": " line))))
                max-width (reduce path 0 (fn [max s]
                                           (let [n (count s)]
                                             (either (> max n)
                                                     n))))
                path (either (and (< (count path) desired-len)
                                  (maybe (comp path (repeat (- desired-len (count path))
                                                            (spaces max-width)))))
                             path)]
            (map path
                 (fn [x]
                   (str x (spaces (- max-width (count x)))))))))

(deftype NoValues [constraints]
  Stringable
  (string-list [_]
    (list "<NoValues " (str constraints) ">"))

  Constraint
  (intersect [nv _] nv)
  (update-sym [x _] x)
  (update-var [x _] x)

  (format-path [_ n]
    (let [max-len (reduce (map constraints (fn [c] (count (assertion-path c))))
                          n
                          (fn [max-len path-len]
                            (either (> max-len path-len)
                                    path-len)))
          paths (map constraints (fn [c]
                                   (format-path c (inc max-len))))]
      (-> paths
          (list-zipper empty-list)
          (map (fn [strs]
                 (str (to-str (interpose strs "    "))
                      "\n"))))))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (or (and (< (count (.constraints x)) (count (.constraints y)))
                  (maybe y))
             (maybe x)))))

(deftype AllValues []
  Stringable
  (string-list [_]
    (list "<AllValues>"))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (maybe x)))

  Constraint
  (intersect [_ c] c)
  (update-sym [x _] x)

  (update-var [x _] x)
  (extract-type-map [_] nothing))

(def bottom-type (NoValues []))
(def top-type (AllValues))

(deftype TypeConstraint [type-maps path type-sym sym var]
  (assert (instance? HashMap type-maps))
  (assert (instance? List path))
  (assert (instance? Tagged type-sym))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "<TypeConstraint " (str type-sym) " " (str type-maps)
          " " (str sym) " '" (str var) "' " (str (either (first path) "")) ">" ))

  Eq
  (=* [x y]
    (and (instance? TypeConstraint y)
         (= type-maps (.type-maps y))
         (maybe x)))

  Constraint
  (assertion-path [_] path)

  (satisfied-by [c info]
    (flat-map (extract-type-map info)
              (fn [value-type-map]
                (and (< 0 (count value-type-map))
                     (every (keys value-type-map)
                            (partial get type-maps))))))

  (extract-type-map [_]
    (maybe type-maps))

  (format-path [x desired-len]
    (format-path* (cons [(str "Type '" type-sym "' from") ""]
                        path)
                  desired-len)))

(deftype ItemsConstraint [items-constraints path sym var]
  (assert (instance? Vector items-constraints))
  (assert (instance? List path))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Collection
  (empty? [_]
    (every items-constraints empty?))

  Eq
  (=* [x y]
    (and (instance? ItemsConstraint y)
         (= items-constraints (.items-constraints y))
         (maybe x)))

  Stringable
  (string-list [_]
    (list "<ItemsConstraint " (str items-constraints) " " (str sym) ">"))

  Constraint
  (assertion-path [_]
    path)
  
  (extract-type-map [_]
    (maybe {ListType #{}
            VectorType #{}}))

    (extract-items-constraints [_]
    items-constraints)

  (format-path [x desired-len]
    (format-path* (cons ["Sequence from" ""] path)
                  desired-len)))

(deftype MultiConstraint [constraints]
  (assert (instance? Vector constraints))

  Stringable
  (string-list [_] (list "<MultiConstraint \n" (to-str (interpose constraints "\n-- ")) ">"))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (= constraints (.constraints y))
         (maybe x)))

  Collection
  (conj [mc c]
    (either (or (or (= bottom-type c)
                    (and (some constraints (partial = c))
                         (maybe mc)))
                (and (= top-type c)
                     (maybe mc))
                (and (instance? MultiConstraint c)
                     (maybe (MultiConstraint (comp constraints
                                                   (.constraints c))))))
            (MultiConstraint (conj constraints c))))

  Constraint
  (satisfied-by [c info]
    (let [type-map (extract-type-map c)]
      (or (flat-map type-map
                    (fn [type-map]
                      (satisfied-by (TypeConstraint type-map empty-list (symbol "<unknown>") nothing "")
                                    info)))
          (and (= nothing type-map)
               (every (.constraints c)
                      (fn [inner-c]
                        (satisfied-by inner-c info)))))))

  (extract-type-map [mc]
    (reduce (.constraints mc) nothing
            (fn [type-map c]
              (or (map type-map (partial restrict-types c))
                  (extract-type-map c)))))

  (extract-items-constraints [mc]
    (either (-> (.constraints mc)
                (some (partial instance? ItemsConstraint))
                (map .items-constraints))
            []))

  (update-sym [mc sym]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-sym c sym)))))

  (update-var [mc var]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-var c var)))))

  (format-path [_ n]
    (let [max-len (reduce (map constraints (fn [o]
                                             (count (.path o))))
                          n
                          (fn [max-len path-len]
                            (either (> max-len path-len)
                                    path-len)))
          paths (map constraints (fn [c]
                                   (format-path c (inc max-len))))]
      (-> paths
          (list-zipper empty-list)
          (map (fn [strs]
                 (to-str (interpose strs "    ")))))))

  (assertion-path [c]
    (format-path c 0))

  (update-sym [mc sym]
    (.constraints mc (map constraints (fn [c]
                                        (update-sym c sym)))))

  (update-var [mc var]
    (.constraints mc (map constraints (fn [c]
                                        (update-var c var)))))

  (update-path [mc file-name line-number]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-path c file-name line-number)))))

  (intersect [mc c]
    (either (or (and (instance? MultiConstraint c)
                     (maybe (reduce (.constraints c) mc
                                    (fn [cs new-c]
                                      (either (= cs bottom-type)
                                              (intersect new-c cs))))))
                (= bottom-type (intersect c mc))
                (and (some constraints (partial = c))
                     (maybe mc)))
            (MultiConstraint (conj constraints c)))))

(defn intersect-multiconstraint [c mc]
  (and (instance? MultiConstraint mc)
       (or (= bottom-type (reduce (.constraints mc) c
                                  (fn [x y]
                                    (either (= bottom-type (intersect x y))
                                            x))))
           (maybe (conj mc c)))))

(deftype FieldConstraint [field field-var path sym var]
  (assert (instance? Tagged field))
  (assert (instance? List path))
  (assert (instance? Maybe sym))

  Eq
  (=* [x y]
    (and (instance? FieldConstraint y)
         (= field (.field y))
         (maybe x)))

  Stringable
  (string-list [_]
    (list "<FieldConstraint " (str field) " " (str sym)
          ;; "\n" (str (interpose path "\n"))
          ">"))

  Constraint
  (assertion-path [_]
    path)

  (satisfied-by [c info]
    (let [type-map (extract-type-map info)]
      (or (flat-map type-map
                    (fn [type-map]
                      (first (seq (restrict-types c type-map)))))
          (and (= nothing type-map)
               (or (and (instance? FieldConstraint info)
                        (= (.field c) (.field info)))
                   (and (instance? MultiConstraint info)
                        (some (.constraints info)
                              (partial satisfied-by c))))))))

  (extract-type-map [_] nothing)

  (restrict-types [c type-map]
    (reduce (seq type-map) {}
            (fn [type-map [type-num field-set]]
              (either (map (field-set field)
                           (fn [_] (assoc type-map type-num field-set)))
                      type-map))))

  (format-path [x desired-len]
    (format-path* (cons [(str "Field '" (subs (str field) 1) "' required from") ""]
                        path)
                  desired-len))

  (intersect [fc c]
    (either (or (= fc c)
                (intersect-multiconstraint fc c)
                (and (instance? FieldConstraint c)
                     (maybe (MultiConstraint [fc (update-var c (.var fc))])))
                (and (instance? TypeConstraint c)
                     (let [field (.field fc)]
                       (and (empty? (filter (vals (.type-maps c)) (fn [fields]
                                                                    (fields field))))
                            (maybe (NoValues [fc c]))))))
            (intersect (update-var c (.var fc)) fc))))

(def intersect-resultconstraint)

(deftype StaticLengthConstraint [length path sym var]
  (assert (instance? Integer length))
  (assert (instance? List path))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Eq
  (=* [x y]
    (and (instance? StaticLengthConstraint y)
         (= (.length x) (.length y))
         (maybe x)))

  Stringable
  (string-list [c]
    (list "<StaticLengthConstraint " (str (.length c)) " " (str (.sym c)) "\n"
          (to-str (interpose (seq (.path c)) "\n")) ">"))

  Constraint
  (assertion-path [c]
    (.path c))

  (format-path [x desired-len]
    (format-path* (cons [(str "Length from") ""]
                          (.path x))
                    desired-len))

  (extract-type-map [_]
    (maybe {ListType #{}
            VectorType #{}}))

  (intersect [slc c]
    (either (or (= slc c)
                (= c bottom-type)
                (and (= c top-type) (maybe slc))
                (intersect-resultconstraint slc c)
                (intersect-multiconstraint slc c)
                (and (instance? FieldConstraint c)
                     (maybe (NoValues [slc c])))
                (and (instance? ItemsConstraint c)
                     (< (.length slc) (count (.items-constraints c)))
                     (maybe (NoValues [slc c]))))
            (MultiConstraint [slc (update-var c (.var slc))]))))

(deftype StaticIntConstraint [val path sym var]
  (assert (instance? Integer val))
  (assert (instance? List path))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "<StaticInt " (str val) ", " (str sym) ", " (str (either (first path) "")) ">"))

  Eq
  (=* [x y]
    (and (instance? StaticIntConstraint y)
         (= val (.val y))
         (maybe x)))

  Constraint
  (assertion-path [c]
    (.path c))

  (format-path [x desired-len]
    (format-path* (cons ["Integer from" ""] path)
                  desired-len))

  (extract-type-map [_]
    (maybe {IntegerType #{}}))

  (intersect [slc c]
    (either (or (= slc c)
                (and (instance? StaticIntConstraint c)
                     (maybe (NoValues [slc c])))
                (intersect-resultconstraint slc c)
                (intersect-multiconstraint slc c)
                (and (instance? FieldConstraint c)
                     (maybe (NoValues [slc c]))))
            (intersect (update-var c (.var slc)) slc))))

(deftype StaticStrConstraint [val path sym var]
  (assert (instance? String val))
  (assert (instance? List path))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "<StaticString " (str val) ", " (str sym) ", " (str (either (first path) "")) ">"))

  Eq
  (=* [x y]
    (and (instance? StaticStrConstraint y)
         (= val (.val y))
         (maybe x)))

  Constraint
  (assertion-path [c]
    (.path c))

  (intersect [slc c]
    (either (or (= slc c)
                (intersect-resultconstraint slc c)
                (intersect-multiconstraint slc c)
                (and (instance? FieldConstraint c)
                     (maybe (NoValues [slc c]))))
            (intersect (update-var c (.var slc)) slc))))

(def StaticConstraints (comp StaticLengthConstraint
                             StaticStrConstraint
                             StaticIntConstraint))

(def empty-items-constraint (ItemsConstraint [] empty-list nothing ""))

(extend-type TypeConstraint
  Constraint
  (intersect [tc c]
    (either (or (= tc c)
                (intersect-multiconstraint tc c)
                (intersect-resultconstraint tc c)
                (and (= top-type c)
                     (maybe tc))
                (and (= bottom-type c)
                     (maybe c))
                (flat-map (extract-type-map c)
                          (fn [type-map]
                            (and (empty? (select-keys (.type-maps tc) (keys type-map)))
                                 (maybe (NoValues [c tc])))))
                (and (instance? TypeConstraint c)
                     (let [c-map (.type-maps c)
                           new-map (filter-keys (.type-maps tc)
                                                (fn [k]
                                                  (get c-map k)))]
                       (maybe (.type-maps tc new-map))))
                (and (instance? FieldConstraint c)
                     (let [field (.field c)]
                       (and (empty? (filter (vals (.type-maps tc)) (fn [fields]
                                                                     (fields field))))
                            (maybe (NoValues [tc c]))))))
            (MultiConstraint [tc (update-var c (.var tc))]))))

(deftype MaxValue [max path sym var]
  (assert (instance? Integer max))
  (assert (instance? List path))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "<MaxValue " (str max) " " (str sym) " '" (str var) "' " (str (either (first path) "")) ">" ))

  Eq
  (=* [x y]
    (and (instance? MaxValue y)
         (= max (.max y))
         (maybe x)))

  Constraint
  (assertion-path [_]
    path)

  (extract-type-map [_]
    (maybe {IntegerType #{}}))

  (format-path [x desired-len]
    (format-path* (cons [(str "Max value of " max " from") ""] path)
                  desired-len))

  (intersect [mvc c]
    (either (or (= mvc c)
                (intersect-multiconstraint mvc c)
                (and (instance? ItemsConstraint c)
                     (maybe (NoValues [mvc c])))
                (and (instance? FieldConstraint c)
                     (maybe (NoValues [mvc c])))
                (and (instance? MaxValue c)
                     (maybe (.max mvc (either (< max (.max c))
                                              (.max c)))))
                (and (instance? StaticIntConstraint c)
                     (or (and (< max (.val c))
                              (maybe (NoValues [mvc c])))
                         (maybe c))))
            (intersect (update-var c (.var mvc)) mvc))))

(deftype InnerConstraint [inner path sym var]
  (assert (instance? List path))
  (assert (instance? Maybe sym))
  (assert (instance? String var))

  Eq
  (=* [x y]
    (and (instance? InnerConstraint y)
         (= inner (.inner y))
         (maybe x)))

  Stringable
  (string-list [_]
    (list "<InnerConstraint " (str inner) ", " (str sym) ", " (str (either (first path) "")) ">"))

  Constraint
  (extract-type-map [_]
    nothing)

  (assertion-path [_]
    path)

  (format-path [x desired-len]
    (format-path* (cons ["Sequence from" ""] path)
                  desired-len))

  (intersect [ic c]
    (either (or (= ic c)
                (intersect-multiconstraint ic (update-var c (.var ic)))
                (and (instance? InnerConstraint c)
                     (let [new-c (intersect inner (.inner c))]
                       (or (= bottom-type new-c)
                           (maybe (.inner ic new-c)))))
                (and (instance? ItemsConstraint c)
                     (let [constraints (map (.items-constraints c)
                                            (fn [c2]
                                              (intersect inner c2)))]
                       (or (some constraints (partial = bottom-type))
                           (maybe (MultiConstraint [ic (update-var c (.var ic))])))))
                (and (instance? FieldConstraint c)
                     (maybe (MultiConstraint [ic (update-var c (.var ic))])))
                (and (instance? TypeConstraint c)
                     (let [new-type-map (dissoc (.type-maps c) IntegerType SymbolType)]
                       ;; TODO: incomplete. need to account for Strings
                       ;; also account for Fn's
                       (or (and (empty? new-type-map)
                                (maybe (NoValues [ic c])))
                           (maybe (MultiConstraint [ic (-> c
                                                           (.type-maps new-type-map)
                                                           (update-var (.var ic)))])))))
                (and (instance? MaxValue c)
                     (maybe (NoValues [ic c]))))
            (intersect (update-var c (.var ic)) ic))))

(def SymbolConstraints (comp TypeConstraint
                             MaxValue
                             InnerConstraint
                             StaticConstraints
                             ItemsConstraint
                             FieldConstraint))

(extend-type SymbolConstraints
  Constraint
  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (either (and (= "" file-name)
                   (maybe constraint))
              (.path constraint new-path))))

  (update-sym [tc new-sym]
    (.sym tc (maybe new-sym)))

  (update-var [tc new-var]
    (.var tc new-var)))

(def ValueConstraint (comp SymbolConstraints
                           MultiConstraint
                           AllValues))

(deftype ResultConstraint [assertion]
  (assert (instance? ValueConstraint assertion))

  Stringable
  (string-list [_] (list "<ResultConstraint " (str assertion) ">"))

  Constraint
  (update-var [_ new-var]
    (ResultConstraint (update-var assertion new-var)))

  (update-sym [_ new-var]
    (ResultConstraint (update-sym assertion new-var)))

  (extract-type-map [_]
    (extract-type-map assertion))

  (intersect [rc c]
    (let [intersected (either (and (instance? ResultConstraint c)
                                   (maybe (intersect assertion (.assertion c))))
                              (intersect assertion c))]
      (either (= bottom-type intersected)
              (ResultConstraint intersected))))

  Eq
  (=* [x y]
    (and (or (and (instance? ResultConstraint y)
                  (=* assertion (.assertion y)))
             (=* assertion y))
         (maybe x))))

(defn intersect-resultconstraint [c rc]
  (and (instance? ResultConstraint rc)
       (let [result-constraint (intersect c (.assertion rc))]
         (or (and (= bottom-type result-constraint)
                  (maybe (NoValues [c (.assertion rc)])))
             (maybe (ResultConstraint result-constraint))))))

(def Constraints (comp AllValues
                       NoValues
                       MultiConstraint
                       SymbolConstraints
                       ResultConstraint))

(extend-type Constraints
  Constraint
  (extract-inner-constraint [_]
    top-type))

(extend-type MultiConstraint
  Constraint
  (extract-inner-constraint [c]
    (either (some (.constraints c) (fn [c]
                                     (instance? InnerConstraint c)))
            top-type)))

(extend-type InnerConstraint
  Constraint
  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (-> constraint
          (.inner (update-path (.inner constraint) file-name line-number))
          (.path new-path))))

  (extract-inner-constraint [c]
    c))

(extend-type ItemsConstraint
  Constraint
  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (ItemsConstraint (map (.items-constraints constraint)
                            (fn [constraints]
                              (update-path constraints file-name line-number)))
                       new-path
                       (.sym constraint) (.var constraint))))

  (intersect [ic c]
    (either (or (= ic c)
                (intersect-multiconstraint ic c)
                (and (instance? StaticLengthConstraint c)
                     (< (.length c) (count (.items-constraints ic)))
                     (maybe (NoValues [ic c])))
                (and (instance? ItemsConstraint c)
                     (let [constraints (map (zip-lists (.items-constraints ic) (.items-constraints c))
                                            (fn [[c1 c2]]
                                              (intersect c1 c2)))]
                       (or (some constraints (partial = bottom-type))
                           (maybe (.items-constraints ic (vec constraints))))))
                (and (instance? FieldConstraint c)
                     (maybe (NoValues [ic c]))))
            (intersect (update-var c (.var ic)) ic))))

(defn conflicting-assertions [failing-constraint file-name line-number]
  (apply print-err (list* "Conflicting assertions"
                           (either (= "" file-name)
                                   (str "at " file-name ": " line-number))
                           "\n"
                           (format-path failing-constraint 0)))
  nothing)

(defn compose-constraints [file-name line-number x y]
  (assert (instance? Constraints x))
  (assert (instance? Constraints y))

  (let [z (intersect x y)
        file-name (either (and (= file-name 'core)
                               (maybe "$TOCCATA_DIR/core.toc"))
                          file-name)]
    (either (and (= bottom-type z)
                 (let [z (either (and (< 1 (count (.constraints z)))
                                      (maybe z))
                                 (NoValues [x y]))]
                   (maybe (conflicting-assertions z file-name line-number))))
            (maybe z))))
