
(def default-extract-items-constraints)

;; Public interface for Constraints
(defprotocol Constraint
  (assertion-path [x])

  (format-path [x n]
    (assert-result r (instance? (list-of String) r)))

  (intersect [c1 c2])

  (restrict-types [c type-map]
    type-map)

  (extract-type-map [_]
    (assert-result r (instance? Maybe r)))

  (extract-items-constraints [_]
    (assert-result r (instance? Vector r))
    [])

  (extract-contents-constraint [_])

  (extract-items-constraints [c n]
    (assert (instance? Integer n))
    (assert-result r (instance? Vector r))

    (default-extract-items-constraints c n))

  (extract-coll-type [_])

  (extract-inner-constraint [_])

  (update-path [constraint file-name line-number]
    constraint)

  (extract-sym [tc]
    (assert-result r (instance? Maybe r))
    nothing)

  (update-sym [tc new-sym]
    (assert (instance? Tagged new-sym)))

  (clear-sym [tc])

  (extract-var [c])

  (update-var [c new-var])

  (satisfied-by [c info]
    (assert-result r (instance? Maybe r))
    ;; TODO: the whole idea behind this function is suspect
    nothing))

(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -2, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FunctionType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MaybeType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ListType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SymbolType};"))
(def BitmapIndexedType (inline C Integer "(Value *)&(Integer){IntegerType, -2, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ArrayNodeType};"))
(def HashCollisionNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -2, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, OpaqueType};"))
(def TypeConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeConstraintType};"))
(def NoValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, NoValuesType};"))
(def AllValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AllValuesType};"))
(def MultiConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MultiConstraintType};"))
(def ResultConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ResultConstraintType};"))
(def ItemsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ItemsConstraintType};"))
(def FieldConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FieldConstraintType};"))
(def StaticIntConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StaticIntConstraintType};"))
(def MinValueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MinValueType};"))
(def MaxValueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MaxValueType};"))
(def InferredInnerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InferredInnerType};"))
(def StaticLengthConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2,
    StaticLengthConstraintType};"))
(def StaticStrConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StaticStrConstraintType};"))
(def ContentsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ContentsConstraintType};"))
(def HashSetType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashSetType};"))
(def ProtoDispatcherType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ProtoDispatcherType};"))
(def FloatType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FloatType};"))
(def SumConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SumConstraintType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeCount};"))

;; TODO: constraints to add
;; min count (instead of ItemsConstraint)
;; keys required in a hash map
;; key constraint on hash maps

(defn format-path* [path desired-len]
  (assert (instance? List path))
  (assert (instance? Integer desired-len))

  (either (map (first path)
               (fn [[header]]
                 (let [path (-> (rest path)
                                (remove (fn [[file line]]
                                          (either (and (instance? Symbol file)
                                                       (maybe nothing))
                                                  (or (empty? file)
                                                      (= 0 line)))))
                                (map (fn [[file line]]
                                       (let [file (str file)]
                                         (str (either (map (> (count file) 30)
                                                           (fn [len]
                                                             (subs file (- len 15))))
                                                      file)
                                              ": " line)))))
                       max-width (reduce path 0 (fn [max s]
                                                  (let [n (count s)]
                                                    (either (> max n)
                                                            n))))
                       path (either (and (< (count path) desired-len)
                                         (maybe (comp path (repeat (- desired-len (count path))
                                                                   (spaces max-width)))))
                                    path)]
                   (map (cons header path)
                        (fn [x]
                          (str x (spaces (- max-width (count x)))))))))
          path))

(deftype AllValues [var]
  Stringable
  (string-list [_]
    (list "(AllValues " (str var) ")"))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (maybe x)))

  Constraint
  (intersect [_ c] c)
  (clear-sym [x] x)
  (update-sym [x _] x)
  (extract-var [_] var)
  (update-var [x v] (AllValues v))
  (extract-coll-type [x] x)
  (extract-type-map [_] nothing))

(def top-type (AllValues ""))

(defn default-extract-items-constraints [c n]
  (assert (instance? Integer n))
  (assert-result r (instance? Vector r))

  (take (comp (extract-items-constraints c)
              (repeat n top-type))
        n))

(defn sym-str [s]
  (either (map s (fn [s]
                   (str "(maybe '" s ")")))
          "nothing"))

;; InferredInner is a weaker version of CollectionOf
;; TODO: change 'inner' to 'contents'
(deftype InferredInner [inner path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(InferredInner " (str inner) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (extract-items-constraints [c n]
    (vec (repeat n inner)))

  (extract-type-map [_]
    nothing)

  (assertion-path [_]
    path)

  (format-path [x desired-len]
    (format-path* (cons ["Contents restriction from" ""] path)
                  desired-len)))

;; CollectionOf is a stronger version of InferredInner
;; TODO: change 'constraints' to 'contents'
(deftype CollectionOf [constraints path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(CollectionOf " (str constraints) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (update-var [c new-var]
    (.var c new-var))

  (update-sym [c new-sym]
    (.sym c new-sym))

  (extract-type-map [_]
    nothing)

  (assertion-path [_]
    path)

  (format-path [x desired-len]
    (format-path* (cons ["Contents from" ""] path)
                  desired-len)))

(def coll-of-any (CollectionOf top-type empty-list nothing ""))

(deftype ItemsConstraint [items-constraints tail-constraint path sym var]
  (assert (instance? Vector items-constraints))
  (assert (instance? (any-of ItemsConstraint
                             CollectionOf
                             InferredInner)
                     tail-constraint))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(ItemsConstraint [" (to-str (interpose items-constraints "\n"))
          "]\n" (str tail-constraint) "\n(list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" "\")"))

  Constraint
  (extract-items-constraints [_]
    (comp items-constraints
          (extract-items-constraints tail-constraint)))

  (extract-items-constraints [c n]
    (either (and (<= n 0)
                 (maybe []))
            (take (comp items-constraints
                        (extract-items-constraints tail-constraint (- n (count items-constraints)))
                        (repeat n top-type))
                  n)))

  (assertion-path [_]
    path)

  (extract-type-map [_]
    (maybe {ListType #{}
            VectorType #{}}))

  (format-path [x desired-len]
    (format-path* (cons ["Sequence from" ""] path)
                  desired-len)))

(deftype TypeConstraint [type-maps path type-sym sym var]
  (assert (instance? (map-of Integer HashSet) type-maps))
  (assert (instance? (list-of Vector) path))
  (assert (instance? Tagged type-sym))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(TypeConstraint "  (str type-maps) " (list"
          (either (map (first path) (fn [[f l]]
                                      (let [f (str f)]
                                        (str "[\"" (either (map (> (count f) 15)
                                                                (fn [len]
                                                                  (subs f (- len 15))))
                                                           f)
                                             "\" " l "]"))))
                  "")
          ") "
          (str "'" type-sym) " " (sym-str sym)
          " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (for [_ (instance? TypeConstraint y)
          y-maps (get y .type-maps)
          _ (= type-maps y-maps)]
      x))

  Constraint
  (assertion-path [_] path)

  (extract-type-map [_]
    (maybe type-maps))

  (format-path [x desired-len]
    (format-path* (cons [(str "Type '" type-sym "' from") ""]
                        path)
                  desired-len)))

(deftype FieldConstraint [field field-var path sym var]
  (assert (instance? Tagged field))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(FieldConstraint (symbol \"" (str field) "\") \"" (str field-var) "\" (list"
          (either (map (first path) (fn [[f l]]
                                      (let [f (str f)]
                                        (str "[\"" (either (map (> (count f) 15)
                                                                (fn [len]
                                                                  (subs f (- len 15))))
                                                           f)
                                             "\" " l "]"))))
                  "")
          ") " (sym-str sym)
          " \"" (str var) "\")"))

  Constraint
  (assertion-path [_]
    path)

  (extract-type-map [_]
    nothing)

  (restrict-types [c type-map]
    (reduce (seq type-map) {}
            (fn [type-map [type-num field-set]]
              (either (map (field-set field)
                           (fn [_] (assoc type-map type-num field-set)))
                      type-map))))

  (format-path [x desired-len]
    (format-path* (cons [(str "Field '" (subs (str field) 1) "' required from") ""]
                        path)
                  desired-len)))

(deftype StaticIntConstraint [val path sym var]
  (assert (instance? Integer val))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(StaticIntConstraint " (str val) " (list"
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (assertion-path [c]
    path)

  (format-path [x desired-len]
    (format-path* (cons ["Integer from" ""] path)
                  desired-len))

  (extract-type-map [_]
    (maybe {IntegerType #{}})))

(deftype MinValue [min path sym var]
  (assert (instance? Integer min))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(MinValue " (str min) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (assertion-path [_]
    path)

  (extract-type-map [_]
    (maybe {IntegerType #{}}))

  (format-path [x desired-len]
    (format-path* (cons [(str "Min value of " min " from") ""] path)
                  desired-len))

  (update-var [c new-var]
    (.var c new-var))

  (intersect [mvc c]
    (either (= mvc c)
            (intersect (update-var c (.var mvc)) mvc))))

(deftype MaxValue [max path sym var]
  (assert (instance? Integer max))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(MaxValue " (str max) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (assertion-path [_]
    path)

  (extract-type-map [_]
    (maybe {IntegerType #{}}))

  (format-path [x desired-len]
    (format-path* (cons [(str "Max value of " max " from") ""] path)
                  desired-len)))

(deftype StaticLengthConstraint [length path sym var]
  (assert (instance? Integer length))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [c]
    (list "(StaticLengthConstraint " (str length) " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (assertion-path [c]
    path)

  (format-path [x desired-len]
    (format-path* (cons [(str "Length from") ""]
                          (.path x))
                    desired-len))

  (extract-type-map [_]
    (maybe {ListType #{}
            VectorType #{}})))

(deftype StaticStrConstraint [val path sym var]
  (assert (instance? String val))
  (assert (instance? (list-of Vector) path))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(StaticStrConstraint " val " (list "
          (either (map (first path) (fn [[f l]]
                                      (str "[\"" f "\" " l "]")))
                  "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (format-path [x desired-len]
    (format-path* (cons ["String from" ""] path)
                  desired-len))

  (extract-type-map [_]
    (maybe {StringBufferType #{}
            SubStringType #{}}))

  (assertion-path [c]
    path))

(def StaticConstraints (comp StaticLengthConstraint
                             StaticStrConstraint
                             StaticIntConstraint))

;; TODO: implement =*
(deftype SumConstraint [alts path sym var]
  (assert (min-count alts 1))
  (assert (instance? (maybe-of Symbol) sym))
  (assert (instance? (list-of Vector) path))

  Stringable
  (string-list [_]
    (list (str "(SumConstraint " (str alts) " " (str path) " " (either (map sym str) 'nothing) ")")))

  Constraint
  (assertion-path [x]
    path)

  (format-path [_ n]
    (print-err 'sum-format-path)
    (format-path* (cons ["Sum Type from" ""] path)
                  n))

  (extract-type-map [_]
    (reduce alts nothing (fn [m c]
                           (let [c-m (extract-type-map c)]
                             (or (apply (maybe comp) [m c-m])
                                 c-m)))))

  (extract-items-constraints [_]
    [])

  (extract-items-constraints [c n]
    [])

  (extract-contents-constraint [_]
    (print-err 'sum-extract-contents-constraint)
    (abort))

  (update-path [constraint file-name line-number]
    (print-err 'sum-update-path file-name line-number)
    (-> constraint
        (.path (cons [file-name line-number] path))
        (.alts (map alts
                    (fn [c]
                      (update-path c file-name line-number))))))

  (extract-sym [tc]
    sym)

  (update-sym [tc new-sym]
    (.sym tc (maybe new-sym)))

  (clear-sym [tc]
    (.sym tc nothing))

  (extract-var [c]
    var)

  (update-var [c new-var]
    (.var c new-var))

  (satisfied-by [c info]
    (some alts (fn [c]
                 (satisfied-by c info)))))

(defn sum-type [cs]
  (either (or (and (empty? cs)
                   (maybe top-type))
              (some cs (partial = top-type)))
          (let [new-cs (reduce cs []
                               (fn [new-cs curr]
                                 (either (and (some new-cs (fn [c]
                                                             (= c (intersect c curr))))
                                              (maybe new-cs))
                                         (conj new-cs curr))))]
            (either (and (= 1 (count new-cs))
                         (first new-cs))
                    (SumConstraint new-cs empty-list nothing "")))))

(def SymbolConstraints (comp TypeConstraint
                             MinValue
                             MaxValue
                             InferredInner
                             StaticConstraints
                             ItemsConstraint
                             CollectionOf
                             FieldConstraint
                             SumConstraint))

(deftype NoValues [constraints]
  (assert (instance? (vector-of (any-of SymbolConstraints
                                        Symbol))
                     constraints))

  Stringable
  (string-list [_]
    (list "(NoValues [" (to-str (interpose constraints "\n")) "])"))

  Constraint
  (intersect [nv _] nv)
  (clear-sym [x] x)
  (update-sym [x _] x)
  (update-var [x _] x)
  (extract-coll-type [x] x)

  (format-path [_ n]
    (let [max-len (reduce (map constraints (fn [c] (count (assertion-path c))))
                          n
                          (fn [max-len path-len]
                            (either (> max-len path-len)
                                    path-len)))
          paths (map constraints (fn [c]
                                   (format-path c (inc max-len))))]
      (-> paths
          (list-zipper empty-list)
          (map (fn [strs]
                 (str (to-str (interpose strs "    "))
                      "\n"))))))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (or (and (empty? constraints)
                  (maybe y))
             (maybe x)))))

;; TODO: this should throw an assertion error because of the empty vector
(def bottom-type (NoValues []))

(extend-type Integer
  Constraint
  (intersect [x c]
    (intersect (StaticIntConstraint x empty-list nothing "") c)))

(extend-type String
  Constraint
  (intersect [x c]
    (intersect (StaticStrConstraint x empty-list nothing "") c)))

(extend-type Vector
  Constraint
  (intersect [v c]
    (intersect (ItemsConstraint v coll-of-any empty-list nothing "") c)))

(extend-type Symbol
  Constraint
  (assertion-path [_]
    empty-list)

  (format-path [_ desired-len]
    (format-path* (list ["Symbol from" ""])
                  desired-len))

  (extract-type-map [_]
    (maybe {SymbolType #{}}))

  (intersect [slc c]
    (either (or (= slc c)
                (and (instance? Symbol c)
                     (maybe (NoValues [slc c])))
                (for [type-map (extract-type-map c)
                      :when (get type-map SymbolType)]
                  slc))
            (NoValues [slc c]))))

(deftype MultiConstraint [constraints]
  (assert (instance? (vector-of SymbolConstraints) constraints))

  Stringable
  (string-list [_] (list "(MultiConstraint [" (to-str (interpose constraints "\n")) "])"))

  Constraint
  (extract-var [_]
    (either (some constraints (fn [c]
                                (let [var (extract-var c)]
                                  (or (and (= "" var)
                                           nothing)
                                      (maybe var)))))
            ""))

  (extract-sym [c]
    (some constraints extract-sym))

  (extract-type-map [mc]
    (reduce (.constraints mc) nothing
            (fn [type-map c]
              (or (map type-map (partial restrict-types c))
                  (extract-type-map c)))))

  (clear-sym [mc]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (clear-sym c)))))

  (update-sym [mc sym]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-sym c sym)))))

  (update-var [mc var]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-var c var)))))

  (format-path [_ n]
    (let [max-len (reduce (map constraints (fn [o]
                                             (count (.path o))))
                          n
                          (fn [max-len path-len]
                            (either (> max-len path-len)
                                    path-len)))
          paths (map constraints (fn [c]
                                   (format-path c (inc max-len))))]
      (-> paths
          (list-zipper empty-list)
          (map (fn [strs]
                 (to-str (interpose strs "    ")))))))

  (assertion-path [c]
    (format-path c 0))

  (update-path [mc file-name line-number]
    (.constraints mc (map (.constraints mc)
                          (fn [c]
                            (update-path c file-name line-number))))))

(def ValueConstraint (comp SymbolConstraints
                           MultiConstraint
                           AllValues))

(deftype ResultConstraint [assertion]
  (assert (instance? ValueConstraint assertion))

  Stringable
  (string-list [_] (list "(ResultConstraint " (str assertion) ")"))

  Constraint
  (update-var [_ new-var]
    (ResultConstraint (update-var assertion new-var)))

  (clear-sym [_]
    (ResultConstraint (clear-sym assertion)))

  (update-sym [_ new-var]
    (ResultConstraint (update-sym assertion new-var)))

  (extract-type-map [_]
    (extract-type-map assertion)))

(def Constraints (comp AllValues
                       NoValues
                       MultiConstraint
                       SymbolConstraints
                       ResultConstraint))

;; private operations on Constraints
(defprotocol ConstraintOps
  (sum-satisfies [info c]
    (assert (instance? ValueConstraint info))
    (assert (instance? ValueConstraint c))

    nothing)

  (=-multi [y x]
    (assert (instance? MultiConstraint x))
    (assert-result r (instance? Maybe r))

    nothing)

  (intersect-result [c rc]
    (assert (instance? ResultConstraint rc))
    nothing)

  (=-result-constraint [y x]
    (assert (instance? ResultConstraint x))
    nothing)

  (intersect-typec [c tc]
    (assert (instance? TypeConstraint tc))
    (assert-result r (instance? Constraints r)))

  (=-contentsc [x y]
    nothing)

  (intersect-coll-of [c cc]
    (assert (instance? CollectionOf cc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (.var cc)) cc))

  (=-static-str [y x]
    nothing)

  (intersect-static-str [c slc]
    (assert (instance? StaticStrConstraint slc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (.var slc)) slc))

  (=-static-len [y x]
    nothing)

  (intersect-static-len [c slc]
    (assert (instance? StaticLengthConstraint slc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (.var slc)) slc))

  (=-inferred-inner [y x]
    nothing)

  (intersect-sum [c cs]
    (assert (instance? SumConstraint cs))

    (let [inters (map (.alts cs) (partial intersect c))
          goods (remove inters (partial instance? NoValues))]
      (either (and (empty? goods)
                   (maybe (NoValues [c cs])))
              (.alts cs goods))))

  (intersect-inner [c ic]
    (assert (instance? InferredInner ic))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (.var ic)) ic))

  (=-max-value [y x]
    (assert (instance? MaxValue x))
    nothing)

  (intersect-max-value [c mvc]
    (assert (instance? MaxValue mvc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (.var mvc)) mvc))

  (=-min-value [y x]
    (assert (instance? MinValue x))
    nothing)

  (intersect-min-value [c mvc]
    (assert (instance? MinValue mvc))
    (assert-result r (instance? Constraints r))

    (intersect c mvc))

  (=-static-int [y x]
    (assert (instance? StaticIntConstraint x))
    nothing)

  (intersect-static-int [c slc]
    (assert (instance? StaticIntConstraint slc))
    (intersect (update-var c (.var slc)) slc))

  (=-field-constraint [y x]
    (assert (instance? FieldConstraint x))
    nothing)

  (fieldc-satisfied [info c]
    (assert (instance? FieldConstraint c))
    (flat-map (extract-type-map info)
              (fn [type-map]
                (first (seq (restrict-types c type-map))))))

  (intersect-fieldc [c fc]
    (assert (instance? FieldConstraint fc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (.var fc)) fc))

  (=-items-constraint [y x]
    (assert (instance? ItemsConstraint x))
    nothing)

  (intersect-itemsc [c ic]
    (assert (instance? ItemsConstraint ic))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (.var ic)) ic))

  (intersect-multi [c mc]
    (assert (instance? MultiConstraint mc))
    (assert-result r (instance? Constraints r)))

  (conj-multi [c mc]
    (assert (instance? MultiConstraint mc))))

(extend-type NoValues
  ConstraintOps
  (conj-multi [c mc]
    (maybe c)))

(extend-type AllValues
  ConstraintOps
  (intersect-sum [c sc] sc) 
  (intersect-result [c rc] rc) 
  (intersect-typec [c tc] tc) 
  (intersect-coll-of [c cc] cc) 
  (intersect-static-str [c slc] slc) 
  (intersect-static-len [c slc] slc) 
  (intersect-inner [c ic] ic) 
  (intersect-max-value [c mvc] mvc) 
  (intersect-min-value [c mvc] mvc) 
  (intersect-static-int [c slc] slc) 
  (intersect-fieldc [c fc] fc) 
  (intersect-itemsc [c ic] ic) 
  (intersect-multi [c mc] mc) 
  (conj-multi [c mc]
    (maybe mc)))

(extend-type SymbolConstraints
  Constraint
  (extract-sym [c]
    (.sym c))

  (extract-var [c]
    (.var c))

  (extract-coll-type [_]
    top-type)

  (update-path [constraint file-name line-number]
    (let [new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (either (and (= "" file-name)
                   (maybe constraint))
              (.path constraint new-path))))

  (clear-sym [tc]
    (.sym tc nothing))

  (update-sym [tc new-sym]
    (.sym tc (maybe new-sym)))

  (update-var [tc new-var]
    (.var tc new-var))

  ConstraintOps
  (intersect-multi [c mc]
    (assert (instance? MultiConstraint mc))
    (assert-result r (instance? Constraints r))

    (either (or (-> (.constraints mc)
                    (map (partial intersect c))
                    (some (partial instance? NoValues)))
                (and (some (.constraints mc) (partial = c))
                     (maybe mc)))
            (conj mc c)))

  (conj-multi [c mc]
    (assert (instance? MultiConstraint mc))

    (either (and (some (.constraints mc) (partial = c))
                 (maybe c))
            (MultiConstraint (conj (.constraints mc) c))))

  (intersect-typec [c tc]
    (assert (instance? TypeConstraint tc))
    (assert-result r (instance? Constraints r))

    (either (flat-map (extract-type-map c)
                      (fn [type-map]
                        (or (and (empty? (select-keys (.type-maps tc) (keys type-map)))
                                 (maybe (NoValues [tc c])))
                            (maybe (MultiConstraint [tc (update-var c (.var tc))])))))
            (intersect (update-var c (.var tc)) tc))))

(extend-type Constraints
  Constraint
  (extract-contents-constraint [_]
    top-type)

  (extract-inner-constraint [_]
    top-type))

(extend-type ItemsConstraint
  Eq
  (=* [x y]
    (=-items-constraint y x))

  ConstraintOps
  (intersect-coll-of [c cc]
    (either (or (= (reduce (.items-constraints c)
                           top-type
                           (fn [r c]
                             (either (= r bottom-type)
                                     (-> (.constraints cc)
                                         (intersect c)
                                         (update-var (extract-var c))))))
                   bottom-type)
                (= (intersect cc (.tail-constraint c))
                   bottom-type))
            (MultiConstraint [cc (update-var c (.var cc))])))

  (intersect-static-str [c slc]
    (either (and (< (count slc) (count (extract-items-constraints c)))
                 (maybe (NoValues [slc c])))
            (MultiConstraint [slc c])))

  (intersect-static-len [c slc]
    (either (and (< (.length slc) (count (extract-items-constraints c)))
                 (maybe (NoValues [slc c])))
            (MultiConstraint [slc c])))

  (intersect-inner [c ic]
    (either (or (-> (.items-constraints c)
                    (map (fn [c2]
                           (intersect (.inner ic) c2)))
                    (some (fn [c]
                            (= c bottom-type))))
                (= (intersect (.tail-constraint c) ic)
                   bottom-type))
            (MultiConstraint [ic (update-var c (.var ic))])))

  (intersect-typec [c tc]
    (assert (instance? TypeConstraint tc))

    (MultiConstraint [tc (update-var c (.var tc))]))

  (intersect-max-value [c mvc]
    (NoValues [mvc c]))

  (intersect-static-int [c slc]
    (NoValues [slc c]))

  (=-items-constraint [y x]
    (and (= (.items-constraints y) (.items-constraints x))
         (= (.tail-constraint y) (.tail-constraint x))
         (maybe x)))

  (intersect-itemsc [c ic]
    (assert (instance? ItemsConstraint ic))

    (let [cnt-ic (count (.items-constraints ic))
          cnt-c (count (.items-constraints c))
          max-cnt (either (> cnt-ic cnt-c)
                          cnt-c)
          constraints (map (zip-lists (extract-items-constraints ic max-cnt)
                                      (extract-items-constraints c max-cnt))
                           (fn [[c1 c2]]
                             (intersect c1 c2)))
          new-tail (intersect (.tail-constraint ic)
                              (.tail-constraint c))]
      (either (or (some constraints (fn [c]
                                      (= c bottom-type)))
                  (= new-tail bottom-type))
              (-> ic
                  (.tail-constraint new-tail)
                  (.items-constraints (vec constraints))))))

  (intersect-fieldc [c fc]
    (NoValues [fc c]))

  (intersect-min-value [c mvc]
    (NoValues [mvc c]))

  Constraint
  (intersect [ic c]
    (either (=-items-constraint c ic)
            (intersect-itemsc c ic)))

  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (ItemsConstraint (map (.items-constraints constraint)
                            (fn [constraints]
                              (update-path constraints file-name line-number)))
                       (update-path (.tail-constraint constraint) file-name line-number)
                       new-path
                       (.sym constraint) (.var constraint)))))

(extend-type MultiConstraint
  Eq
  (=* [x y]
    (=-multi y x))

  Collection
  (conj [mc c]
    (assert (instance? SymbolConstraints c))

    (conj-multi c mc))

  ConstraintOps
  (=-multi [y x]
    (and (every (.constraints x)
                (fn [x]
                  (some (.constraints y)
                        (fn [y]
                          (= x y)))))
         (maybe x)))

  (intersect-sum [c sc]
    (either (= (reduce (.constraints c) sc
                       (fn [x y]
                         (either (= (intersect x y) bottom-type)
                                 x)))
               bottom-type)
            (conj c sc)))

  (intersect-inner [c ic]
    (either (= (reduce (.constraints c) ic
                       (fn [x y]
                         (either (= (intersect x y) bottom-type)
                                 x)))
               bottom-type)
            (conj c ic)))

  (intersect-typec [c tc]
    (intersect c tc))

  (conj-multi [c mc]
    (reduce (.constraints c) mc conj))

  (intersect-multi [c mc]
    (reduce (.constraints c) mc
            (fn [mc new-c]
              (either (= mc bottom-type)
                      (intersect mc new-c)))))

  Constraint
  (intersect [mc c]
    (intersect-multi c mc))

  (extract-contents-constraint [mc]
    (-> (.constraints mc)
        (filter (fn [c]
                  (or (instance? CollectionOf c)
                      (instance? InferredInner c))))
        (map extract-contents-constraint)
        (reduce top-type intersect)))

  (extract-coll-type [mc]
    (-> (.constraints mc)
        (filter (partial instance? CollectionOf))
        (reduce top-type intersect)))

  (satisfied-by [c info]
    (or (sum-satisfies info c)
        (let [type-map (extract-type-map c)]
          (and (or (= nothing type-map)
                   (flat-map type-map
                             (fn [type-map]
                               (satisfied-by (TypeConstraint type-map empty-list (symbol "<unknown>") nothing "")
                                             info))))
               (every (.constraints c)
                      (fn [inner-c]
                        (satisfied-by inner-c info)))))))

  (extract-items-constraints [mc]
    (let [coll-c (-> mc
                     extract-inner-constraint
                     extract-contents-constraint)]
      (either (-> (.constraints mc)
                  (some (partial instance? ItemsConstraint))
                  (map (fn [ic]
                         (-> (extract-items-constraints ic)
                             (map (fn [c]
                                    (-> c
                                        (intersect coll-c)
                                        (update-var (extract-var c)))))))))
              [])))

  (extract-inner-constraint [c]
    (let [inferred (either (some (.constraints c) (fn [c]
                                                    (instance? InferredInner c)))
                           top-type)
          coll-of (either (some (.constraints c) (fn [c]
                                                   (instance? CollectionOf c)))
                          top-type)]
      (intersect inferred coll-of))))

(extend-type ResultConstraint
  Eq
  (=* [x y]
    (and (or (=-result-constraint y x)
             (=* (.assertion x) y))
         (maybe x)))

  Constraint
  (intersect [rc c]
    (let [intersected (either (intersect-result c rc)
                              (intersect (.assertion rc) c))]
      (either (= intersected bottom-type)
              (ResultConstraint intersected))))

  ConstraintOps
  (=-result-constraint [y x]
    (=* (.assertion x) (.assertion y)))

  (intersect-result [c rc]
    (maybe (intersect (.assertion rc) (.assertion c)))))

(extend-type TypeConstraint
  Constraint
  (intersect [tc c]
    (intersect-typec c tc))

  (satisfied-by [c info]
    (or (sum-satisfies info c)
        (flat-map (extract-type-map info)
                  (fn [value-type-map]
                    (and (< 0 (count value-type-map))
                         (every (keys value-type-map)
                                (partial get (.type-maps c))))))))
  ConstraintOps
  (conj-multi [c mc]
    (intersect-multi c mc))

  (intersect-multi [c mc]
    (let [new-c (-> (.constraints mc)
                    (filter (partial instance? TypeConstraint))
                    (reduce c intersect))]
      (either (= new-c bottom-type)
              (.constraints mc (conj (remove (.constraints mc)
                                             (partial instance? TypeConstraint))
                                     new-c)))))

  (intersect-coll-of [c ic]
    (let [new-type-map (dissoc (.type-maps c) IntegerType SymbolType)]
      ;; TODO: incomplete. need to account for Strings
      ;; also account for Fn's
      (either (and (empty? new-type-map)
                   (maybe (NoValues [ic c])))
              (MultiConstraint [ic (-> c
                                       (.type-maps new-type-map)
                                       (update-var (.var ic)))]))))

  (intersect-inner [c ic]
    (let [new-type-map (dissoc (.type-maps c) IntegerType SymbolType)]
      ;; TODO: incomplete. need to account for Strings
      ;; also account for Fn's
      (either (and (empty? new-type-map)
                   (maybe (NoValues [ic c])))
              (MultiConstraint [ic (-> c
                                       (.type-maps new-type-map)
                                       (update-var (.var ic)))]))))

  (intersect-fieldc [c fc]
    (let [field (.field fc)
          new-map (reduce (seq (.type-maps c))
                          {}
                          (fn [type-map [type-num fields]]
                            (either (map (fields field) (fn [_]
                                                          (assoc type-map type-num fields)))
                                    type-map)))]
      (either (and (empty? new-map)
                   (maybe (NoValues [fc c])))
              (MultiConstraint [fc (-> c
                                       (.type-maps new-map)
                                       (update-var (.var fc)))]))))

  (intersect-typec [c tc]
    (either (or (= tc c)
                (and (empty? (select-keys (.type-maps tc) (keys (.type-maps c))))
                     (maybe (NoValues [tc c]))))
            (.type-maps tc (filter-keys (.type-maps tc)
                                        (fn [k]
                                          (get (.type-maps c) k)))))))

(extend-type FieldConstraint
  Eq
  (=* [x y]
    (=-field-constraint y x))

  Constraint
  (satisfied-by [c info]
    (or (sum-satisfies info c)
        (fieldc-satisfied info c)))

  (intersect [fc c]
    (intersect-fieldc c fc))

  ConstraintOps
  (intersect-coll-of [c cc]
    (either (and (= (.field c) '.set-map)
                 (maybe (MultiConstraint [cc (update-var c (.var cc))])))
            (NoValues [cc c])))

  (intersect-static-str [c slc]
    (NoValues [slc c]))

  (intersect-static-len [c slc]
    (NoValues [slc c]))

  (intersect-inner [c ic]
    (either (and (= (.field c) '.set-map)
                 (maybe (MultiConstraint [ic (update-var c (.var ic))])))
            (NoValues [ic c])))

  (intersect-max-value [c mvc]
    (NoValues [mvc c]))

  (=-field-constraint [y x]
    (and (= (.field y) (.field y))
         (maybe x)))

  (fieldc-satisfied [info c]
    (= (.field info) (.field c)))

  (intersect-fieldc [c fc]
    (MultiConstraint [fc (update-var c (.var fc))]))

  (intersect-static-int [c slc]
    (NoValues [slc c]))

  (intersect-min-value [c mvc]
    (NoValues [mvc c])))

(extend-type StaticIntConstraint
  Eq
  (=* [x y]
    (=-static-int y x))

  Constraint
  (intersect [slc c]
    (intersect-static-int c slc))

  ConstraintOps
  (intersect-coll-of [c cc]
    (NoValues [cc c]))

  (intersect-static-str [c slc]
    (NoValues [slc c]))

  (intersect-static-len [c slc]
    (NoValues [slc c]))

  (intersect-inner [c ic]
    (NoValues [ic c]))

  (=-static-int [y x]
    (and (= (.val y) (.val x))
         (maybe x)))

  (intersect-max-value [c mvc]
    (either (<= (.val c) (.max mvc))
            (NoValues [mvc c])))

  (intersect-static-int [c slc]
    (either (= slc c)
            (NoValues [slc c])))

  (intersect-min-value [c mvc]
    (either (and (< (.val c) (.min mvc))
                 (maybe (NoValues [mvc c])))
            c)))

(extend-type MinValue
  Eq
  (=* [x y]
    (=-min-value y x))

  Constraint
  (intersect [mvc c]
    (intersect-min-value c mvc))

  ConstraintOps
  (intersect-static-len [c ic]
    (NoValues [ic c]))

  (intersect-static-str [c ic]
    (NoValues [ic c]))

  (intersect-inner [c ic]
    (NoValues [ic c]))

  (intersect-max-value [c mvc]
    (either (and (<= (.min c) (.max mvc))
                 (maybe (MultiConstraint [c mvc])))
            (NoValues [mvc c])))

  (=-min-value [y x]
    (and (= (.min y) (.min x))
         (maybe x)))

  (intersect-min-value [c mvc]
    (either (=* c mvc)
            (.min mvc (either (< (.min mvc) (.min c))
                              (.min c))))))

(extend-type InferredInner
  Eq
  (=* [x y]
    (=-inferred-inner y x))

  Constraint
  (extract-contents-constraint [c]
    (.inner c))

  (intersect [ic c]
    (intersect-inner c ic))

  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (-> constraint
          (.inner (update-path (.inner constraint) file-name line-number))
          (.path new-path))))

  (extract-inner-constraint [c]
    c)

  ConstraintOps
  (intersect-multi [c mc]
    (let [new-c (-> (.constraints mc)
                  (filter (partial instance? InferredInner))
                  (reduce c intersect))]
      (either (= new-c bottom-type)
              (-> mc
                  (.constraints (remove (.constraints mc)
                                        (partial instance? InferredInner)))
                  (conj new-c)))))

  (intersect-coll-of [c cc]
    (let [new-inner (intersect (.constraints cc) (.inner c))]
      (either (= new-inner bottom-type)
              (MultiConstraint [(.constraints cc new-inner)
                                (-> c
                                    (.inner new-inner)
                                    (update-var (.var cc)))]))))

  (intersect-static-str [c slc]
    (either (= (intersect (.inner c) (TypeConstraint {StringBufferType #{} SubStringType #{}}
                                                     (.path slc) 'String (.sym slc) (.var slc)))
               bottom-type)
            slc))

  (intersect-static-len [c slc]
    (MultiConstraint [slc c]))

  (=-inferred-inner [y x]
    (and (= (.inner x) (.inner y))
         (maybe x)))

  (intersect-inner [c ic]
    (let [new-c (intersect (.inner ic) (.inner c))]
      (either (= new-c bottom-type)
              (.inner ic new-c)))))

(extend-type MaxValue
  Eq
  (=* [x y]
    (=-max-value y x))

  ConstraintOps
  (intersect-coll-of [c cc]
    (NoValues [cc c]))

  (intersect-static-str [c slc]
    (NoValues [slc c]))

  (intersect-static-len [c slc]
    (NoValues [slc c]))

  (intersect-inner [c ic]
    (NoValues [ic c]))

  (=-max-value [y x]
    (and (= (.max x) (.max y))
         (maybe x)))

  (intersect-max-value [c mvc]
    (.max mvc (either (< (.max mvc) (.max c))
                      (.max c))))

  Constraint
  (intersect [mvc c]
    (intersect-max-value c mvc)))

(extend-type StaticLengthConstraint
  Eq
  (=* [x y]
    (=-static-len y x))

  Constraint
  (intersect [slc c]
    (intersect-static-len c slc))

  ConstraintOps
  (intersect-coll-of [c cc]
    (MultiConstraint [cc (update-var c (.var cc))]))

  (intersect-static-str [c slc]
    (MultiConstraint [slc c]))

  (intersect-static-len [c slc]
    (either (= slc c)
            (NoValues [slc c])))

  (=-static-len [y x]
    (and (= (.length x) (.length y))
         (maybe x))))

(extend-type StaticStrConstraint
  Eq
  (=* [x y]
    (=-static-str y x))

  Constraint
  (intersect [slc c]
    (intersect-static-str c slc))

  ConstraintOps
  (=-static-str [y x]
    (and (= (.val x) (.val y))
         (maybe x)))

  (intersect-static-str [c slc]
    (either (= slc c)
            (NoValues [slc c]))))

(extend-type CollectionOf
  Eq
  (=* [x y]
    (=-contentsc y x))

  Constraint
  (extract-inner-constraint [c]
    c)

  (extract-contents-constraint [c]
    (.constraints c))

  (extract-coll-type [x]
    x)

  (update-path [constraint file-name line-number]
    (let [file-name (either (and (= file-name 'core)
                                 (maybe "$TOCCATA_DIR/core.toc"))
                            file-name)
          new-path (either (for [[top-file top-line] (first (.path constraint))
                                 _ (and (= top-line line-number)
                                        (= top-file file-name))]
                             (.path constraint))
                           (cons [file-name line-number] (.path constraint)))]
      (CollectionOf (update-path (.constraints constraint) file-name line-number)
                    new-path
                    (.sym constraint) (.var constraint))))


  (extract-type-map [c]
    (maybe {ListType #{}
            MaybeType #{}
            BitmapIndexedType #{}
            ArrayNodeType #{}
            HashCollisionNodeType #{}
            PromiseType #{}
            HashSetType #{'set-map}
            FutureType #{}
            AgentType #{}
            VectorType #{}}))

  (intersect [cc c]
    (intersect-coll-of c cc))

  ConstraintOps
  (intersect-multi [c mc]
    (let [inters (map (.constraints mc) (partial intersect c))]
      (either (some inters (partial instance? NoValues))
              (-> mc
                  (.constraints (remove (.constraints mc)
                                        (partial instance? CollectionOf)))
                  (conj (-> (.constraints mc)
                            (filter (partial instance? CollectionOf))
                            (reduce c intersect)))))))

  (intersect-static-str [c slc]
    (either (= (intersect (.constraints c) (TypeConstraint {StringBufferType #{} SubStringType #{}}
                                                           (.path slc) 'String (.sym slc) (.var slc)))
               bottom-type)
            slc))

  (intersect-static-len [c slc]
    (MultiConstraint [slc c]))

  (intersect-coll-of [c cc]
    (let [new-cs (intersect (.constraints cc) (.constraints c))]
      (either (= cc c)
              (.constraints cc new-cs))))

  (=-contentsc [x y]
    (and (= (.constraints x) (.constraints y))
         (maybe x))))

(extend-type SumConstraint
  Constraint
  (intersect [sc c]
    (intersect-sum c sc))

  ConstraintOps
  (sum-satisfies [info c]
    (and (instance? SumConstraint c)
         (do
           ;; TODO: need to implement this
           (print-err 'sum-satisfies-sum)
           (abort)))

    (every (.alts info)
           (fn [part-c]
             (satisfied-by c part-c))))

  (intersect-sum [c1 c2]
    (let [new-alts (for [a1 (.alts c1)
                         a2 (.alts c2)
                         :let [new-alt (intersect a1 a2)]
                         :when-not (= bottom-type new-alt)]
                     new-alt)
          new-alts (reduce new-alts [] (fn [new-alts alt]
                                         (either (and (some new-alts (partial =* alt))
                                                      (maybe new-alts))
                                                 (conj new-alts alt))))]
      (either (and (empty? new-alts)
                   (maybe (NoValues [c1 c2])))
              (.alts c1 new-alts)))))

  ;; (intersect-typec [c tc]
  ;;   (assert (instance? TypeConstraint tc))
  ;;   (assert-result r (instance? Constraints r))

  ;;   (either (flat-map (extract-type-map c)
  ;;                     (fn [type-map]
  ;;                       (or (and (empty? (select-keys (.type-maps tc) (keys type-map)))
  ;;                                (maybe (NoValues [tc c])))
  ;;                           (maybe (MultiConstraint [tc (update-var c (.var tc))])))))
  ;;           (intersect (update-var c (.var tc)) tc)))

 ;; (=-multi [y x]
 ;;   (assert (instance? MultiConstraint x))
 ;;   (assert-result r (instance? Maybe r))

 ;;   nothing)

 ;; (intersect-result [c rc]
 ;;   (assert (instance? ResultConstraint rc))
 ;;   nothing)

 ;; (=-result-constraint [y x]
 ;;   (assert (instance? ResultConstraint x))
 ;;   nothing)

 ;; (=-contentsc [x y]
 ;;   nothing)

 ;; (intersect-coll-of [c cc]
 ;;   (assert (instance? CollectionOf cc))
 ;;   (assert-result r (instance? Constraints r))

 ;;   (intersect (update-var c (.var cc)) cc))

 ;; (=-static-str [y x]
 ;;   nothing)

 ;; (intersect-static-str [c slc]
 ;;   (assert (instance? StaticStrConstraint slc))
 ;;   (assert-result r (instance? Constraints r))

 ;;   (intersect (update-var c (.var slc)) slc))

 ;; (=-static-len [y x]
 ;;   nothing)

 ;; (intersect-static-len [c slc]
 ;;   (assert (instance? StaticLengthConstraint slc))
 ;;   (assert-result r (instance? Constraints r))

 ;;   (intersect (update-var c (.var slc)) slc))

 ;; (=-inferred-inner [y x]
 ;;   nothing)

 ;; (intersect-inner [c ic]
 ;;   (assert (instance? InferredInner ic))
 ;;   (assert-result r (instance? Constraints r))

 ;;   (intersect (update-var c (.var ic)) ic))

 ;; (=-max-value [y x]
 ;;   (assert (instance? MaxValue x))
 ;;   nothing)

 ;; (intersect-max-value [c mvc]
 ;;   (assert (instance? MaxValue mvc))
 ;;   (assert-result r (instance? Constraints r))

 ;;   (intersect (update-var c (.var mvc)) mvc))

 ;; (=-min-value [y x]
 ;;   (assert (instance? MinValue x))
 ;;   nothing)

 ;; (intersect-min-value [c mvc]
 ;;   (assert (instance? MinValue mvc))
 ;;   (assert-result r (instance? Constraints r))

 ;;   (intersect c mvc))

 ;; (=-static-int [y x]
 ;;   (assert (instance? StaticIntConstraint x))
 ;;   nothing)

 ;; (intersect-static-int [c slc]
 ;;   (assert (instance? StaticIntConstraint slc))
 ;;   (intersect (update-var c (.var slc)) slc))

 ;; (=-field-constraint [y x]
 ;;   (assert (instance? FieldConstraint x))
 ;;   nothing)

 ;; (fieldc-satisfied [info c]
 ;;   (assert (instance? FieldConstraint c))
 ;;   (flat-map (extract-type-map info)
 ;;             (fn [type-map]
 ;;               (first (seq (restrict-types c type-map))))))

 ;; (intersect-fieldc [c fc]
 ;;   (assert (instance? FieldConstraint fc))
 ;;   (assert-result r (instance? Constraints r))

 ;;   (intersect (update-var c (.var fc)) fc))

 ;; (=-items-constraint [y x]
 ;;   (assert (instance? ItemsConstraint x))
 ;;   nothing)

 ;; (intersect-itemsc [c ic]
 ;;   (assert (instance? ItemsConstraint ic))
 ;;   (assert-result r (instance? Constraints r))

 ;;   (intersect (update-var c (.var ic)) ic))

 ;; (intersect-multi [c mc]
 ;;   (assert (instance? MultiConstraint mc))
 ;;   (assert-result r (instance? Constraints r))

 ;;   (either (or (for [c-map (extract-type-map c)
 ;;                     mc-map (extract-type-map mc)
 ;;                     _ (empty? (select-keys c-map (keys mc-map)))]
 ;;                 (NoValues [mc c]))
 ;;               (= (reduce (.constraints mc) c
 ;;                          (fn [x y]
 ;;                            (either (= (intersect x y) bottom-type)
 ;;                                    x)))
 ;;                  bottom-type)
 ;;               (and (some (.constraints mc) (partial = c))
 ;;                    (maybe mc)))
 ;;           (do
 ;;             ;; TODO: this blindly adds 'c', which is fine but a little inefficient
 ;;             (MultiConstraint (conj (.constraints mc) c)))))

 ;;  (conj-multi [c mc]
 ;;   (assert (instance? MultiConstraint mc))

 ;;   (either (and (some (.constraints mc) (partial = c))
 ;;                (maybe c))
 ;;           (MultiConstraint (conj (.constraints mc) c))))

(defn conflicting-assertions [failing-constraint file-name line-number]
  (apply print-err (list* "Conflicting assertions"
                           (either (= "" file-name)
                                   (str "at " file-name ": " line-number))
                           "\n"
                           (format-path failing-constraint 0)))
  nothing)

(defn compose-constraints [file-name line-number x y]
  (assert (instance? Constraints x))
  (assert (instance? Constraints y))

  (let [z (intersect x y)]
    (either (and (= bottom-type z)
                 (let [z (either
                          (and (flat-map (get z .constraints)
                                         (fn [constraints]
                                           (< 1 (count constraints))))
                               (maybe z))
                          (NoValues [x y]))]
                   (maybe (conflicting-assertions z file-name line-number))))
            (maybe z))))

(def empty-items-constraint (ItemsConstraint [] coll-of-any empty-list nothing ""))
