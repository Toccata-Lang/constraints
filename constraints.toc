
;; TODO: really bad error if this is in there
;; (def int-max)

(add-ns se (git-dependency "https://github.com/Toccata-Lang/state-error.git"
                           "state-error.toc"
                           :sha "a1bad99"))

(def SymbolOrString (any-of Symbol
                            String))

(deftype Location [file line]
  (assert (instance? SymbolOrString file))
  (assert (instance? Integer line))

  Stringable
  (string-list [_]
    (list (either (and (= file 'core)
                       (maybe "core"))
                  (str file))
          ": " (str line)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def default-old-extract-items-constraints)

(def top-type)
(def bottom-type)

(def always-nothing -1)
(def never-nothing -2)

;; TODO: remove unused types
(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -2, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FunctionType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MaybeType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ListType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SymbolType};"))
(def BitmapIndexedType (inline C Integer "(Value *)&(Integer){IntegerType, -2, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ArrayNodeType};"))
(def HashCollisionNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -2, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, OpaqueType};"))
(def NoValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, NoValuesType};"))
(def AllValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AllValuesType};"))
(def ResultConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ResultConstraintType};"))
;; TODO: add ListConstraintType VectorConstraintType, etc.
(def InferredInnerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InferredInnerType};"))
(def ContentsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ContentsConstraintType};"))
(def HashSetType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashSetType};"))
(def ProtoDispatcherType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ProtoDispatcherType};"))
(def FloatType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FloatType};"))
(def SumConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SumConstraintType};"))
(def TypeOfConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeOfConstraintType};"))
(def InnerTypeOfConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InnerTypeOfConstraintType};"))
(def DebugConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, DebugConstraintType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeCount};"))

;; TODO: only temporary
(deftype NoSymbol []
  Stringable
  (string-list [_]
    (list "c/no-symbol")))
(def no-symbol (NoSymbol))
;; (def no-symbol
;;   (reify
;;     Type
;;     (type-name [_]
;;       (str "<reified at " _FILE_ ": " _LINE_ ">"))

;;     Stringable
;;     (string-list [_]
;;       (list "c/no-symbol"))

;;     Eq
;;     (=* [x y]
;;       (or (instance? Symbol y)
;;           (and (= (get-type x) (get-type y))
;;                (maybe x))))

;;     Hashable
;;     ;; TODO: remove these impls after HashMapConstraint is implented
;;     (sha1-update [x ctxt]
;;       (sha1-update-type x ctxt)
;;       (sha1-update "no-symbol" ctxt))

;;     (sha1 [x]
;;       (let [ctxt (sha1-init)]
;;         (sha1-update x ctxt)
;;         (sha1-finalize ctxt)))))

(def TypeSym (any-of NoSymbol
                     Symbol))

;; Public interface for Constraints
(defprotocol Constraint
  (show-full [c]
    (assert-result b (instance? (list-of String) b)))

  (assertion-path [x])

  (reify-c [c arity loc]
    (se/state-error (Right c)))

  ;; Ensure constraint is as small as possible
  (trim [c]
    c)

  (get-type-num [c]
    (assert-result r (instance? Integer r)))

  (get-type-sym [c]
    (assert-result r (instance? TypeSym r)))

  (remove-sym [c]
    (assert-result r (instance? Either r))

    (Right c))

  (reified-field [c indices]
    (assert (instance? (vector-of Integer) indices))
    (assert-result r (instance? Either r))

    (Left nothing))

  (filter-reified-field [c]
    c)

  ;; TODO: remove these two when old-reify-c is removed from toccata.toc
  (reified-fields [c]
    (Right top-type))

  (filter-reified-fields [c]
    c)

  (dynamic-params [c]
    (assert-result r (instance? Vector r))

    [])

  (set-arity [c new-arity]
    c)

  (set-path [c new-path]
    (assert (instance? (list-of Vector) new-path))
    (assert-result r (instance? Either r))

    (Right c))

  (add-to-path [constraint file-name line-number]
    constraint)

  (contents-constraint [_]
    (assert-result r (instance? Either r)))

  (collection-of [_]
    ;; extract CollectionOf constraint
    )

  (coll-constraint [_]
    ;; extract the CollectionOf or the InferredInner constraints
    ;; returns either an AllValues or CollectionOf constraint
    )

  (intersect [c1 c2])

  (format-path [x n]
    (assert-result r (instance? (list-of String) r)))

  (is-collection? [c]
    nothing)

  (get-tail-constraint [c x]
    bottom-type)

  (fixed-items-constraints [c x]
    (assert-result r (instance? Vector r))
    [])

  ;; TODO: still need to replace this
  (old-extract-items-constraints [c n]
    (assert (instance? Integer n))
    (assert-result r (instance? Vector r)))

  (extract-sym [tc]
    (assert-result r (instance? (maybe-of Symbol) r))

    nothing)

  (update-sym [tc new-sym]
    (assert (instance? Symbol new-sym)))

  (extract-var [c]
    (assert-result var (instance? String var)))

  (clear-var [c]
    c)

  (update-var [c new-var]
    (assert (instance? String new-var))
    c)

  (set-type-name [c new-name]
    c)

  (satisfied-by [c info]
    (assert-result r (instance? Maybe r))

    nothing))

;; (defn extract-collection-of [c]
;;   (let [x (old-extract-collection-of c)
;;         y (cata collection-of c)]
;;     (or (= x y)
;;         (maybe (print-err 'diff-coll-of c "\n\n" x "\n\n" y)))
;;     y))

(deftype Field [sym]
  (assert (instance? Symbol sym))

  Stringable
  (string-list [_]
    (list (str "(c/Field (symbol \"" sym "\"))")))

  Eq
  (=* [x y]
    (and (instance? Field y)
         (= sym (.sym y))
         (maybe x)))

  Container
  (map [x _]
    x)

  (map [x _ embed]
    (embed x))

  Constraint
  (show-full [c]
    (list "Field " (str sym)))

  (get-type-num [_]
    UnknownType))

(defn extract-tail-constraint [c]
  (para (comp trim get-tail-constraint)
        ;; TODO: remove this trim evenutally
        (trim c)))

(defn extract-items-constraints
  ([c]
   (para (comp trim fixed-items-constraints)
         ;; TODO: remove this trim evenutally
         (trim c)))
  ([c n]
   (-> (trim c)
       (old-extract-items-constraints n))))

(defn update-type-name [c new-name]
  (cata (fn [c]
          (set-type-name c new-name))
        c))

(defn extract-collection-of [c]
  (elgot collection-of trim c))

(defn extract-coll-constraint [c]
  (elgot coll-constraint trim c))

(defn extract-contents-constraint [c]
  (apo (fn [c]
         (-> c
             contents-constraint
             (map trim)))
       c))

(defn extract-reified-fields [c]
  (elgot reified-fields filter-reified-fields c))

(defn extract-reified-field [c indices]
  (elgot (fn [inner-c]
           (reified-field inner-c indices))
         filter-reified-field
         c))

(defn replace-path [c new-path]
  (apo (fn [c]
         (set-path c new-path))
       c))

(defn update-path
  ([c loc]
   (assert (instance? Location loc))
   (update-path c (.file loc) (.line loc)))

  ([c file-name line-number]
   (cata (fn [c]
           (add-to-path c file-name line-number))
         c)))

(defn clear-sym [c]
  (apo remove-sym c))

(defn extract-dynamic-params [c]
  (cata dynamic-params c))

;; TODO: constraints to add
;; number of args the target of a call takes
;; min count
;; keys required in a hash map

(defn format-path* [path desired-len]
  (assert (instance? List path))
  (assert (instance? Integer desired-len))

  (either (map (first path)
               (fn [[header]]
                 (let [path (-> (rest path)
                                (remove (fn [[file line]]
                                          (either (and (instance? Symbol file)
                                                       (maybe nothing))
                                                  (or (empty? file)
                                                      (= 0 line)))))
                                (map (fn [[file line]]
                                       (let [file (str file)]
                                         (str (either (-> file
                                                          str
                                                          (split-string (partial = "/"))
                                                          last
                                                          (map (fn [file]
                                                                 (either (and (flat-map (first file)
                                                                                        (partial = "/"))
                                                                              (maybe file))
                                                                         file))))
                                                      file)
                                              ": " line)))))
                       max-width (reduce path (count header)
                                         (fn [max s]
                                           (let [n (count s)]
                                             (either (> max n)
                                                     n))))
                       path (either (and (< (count path) desired-len)
                                         (maybe (comp path (repeat (- desired-len (count path))
                                                                   (spaces max-width)))))
                                    path)]
                   (map (cons header path)
                        (fn [x]
                          (str x (spaces (- max-width (count x)))))))))
          path))

(deftype AllValues [path var]
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "c/top-type"))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (maybe x)))

  Constraint
  (show-full [c]
    (format-path c 0))

  (format-path [x desired-len]
    (list "<Unknown Type>"))

  (get-type-num [c]
    UnknownType)

  (clear-var [c]
    (.var c ""))

  (satisfied-by [_ c] (maybe c))
  (update-sym [x _] x)
  (add-to-path [c file line]
    (cond (or (= file "")
              (some path (partial = [file line])))
          c
          (.path c (cons [file line] (.path c)))))
  (extract-var [_] var)
  (update-var [x v] (.var x v)))

(def top-type (AllValues empty-list ""))

(defn sym-str [s]
  (either (or (and (instance? Symbol s)
                   (maybe (str "'" s)))
              (map (= no-symbol s)
                   str)
              (map s (fn [s]
                       (str "(maybe '" s ")"))))
          "nothing"))

;; InferredInner is a weaker version of CollectionOf
(deftype InferredInner [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/InferredInner\n" (str contents) " (list "
          ;; (either (map (first path) (fn [[f l]]
          ;;                             (str "[\"" f "\" " l "]")))
          ;;         "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (show-full [c]
    (comp (format-path c 0)
          (map contents (partial str "  "))))

  (get-type-num [c]
    UnknownType)

  (is-collection? [c]
    (maybe c))

  (assertion-path [_] path)

  (format-path [x desired-len]
    (format-path* (cons ["Contents from" ""] path)
                  desired-len)))

;; CollectionOf is a stronger version of InferredInner
(deftype CollectionOf [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/CollectionOf\n" (str contents) " (list "
          ;; (either (map (first path) (fn [[f l]]
          ;;                             (str "[\"" f "\" " l "]")))
          ;;         "")
          ") " (sym-str sym) " \"" (str var) "\")"))

  Constraint
  (show-full [c]
    (comp (format-path c 0)
          (map contents (partial str "  "))))

  (get-type-num [c]
    UnknownType)

  (is-collection? [c]
    (maybe c))

  (update-var [c new-var]
    (.var c new-var))

  (assertion-path [_] path)

  (format-path [x desired-len]
    (format-path* (cons ["Contents from" ""] path)
                  desired-len)))

(def coll-of-any (CollectionOf top-type empty-list no-symbol ""))

;; TODO: change back to reified
(deftype NoInt []
  Stringable
  (string-list [_]
    (list "c/no-int"))

  Eq
  (=* [x y]
    (or (instance? Integer y)
        (and (= (get-type x) (get-type y))
             (maybe x))))

  Ord
  (<* [x y]
    (or (instance? Integer y)
        (and (= (get-type x) (get-type y))
             (maybe x)))))
(def no-int (NoInt))
;; (def no-int
;;   (reify
;;     Type
;;     (type-name [_]
;;       (str "<reified at " _FILE_ ": " _LINE_ ">"))

;;     Stringable
;;     (string-list [_]
;;       (list "c/no-int"))

;;     Hashable
;;     ;; TODO: remove these impls after HashMapConstraint is implented
;;     (sha1-update [x ctxt]
;;       (sha1-update-type x ctxt)
;;       (sha1-update "no-symbol" ctxt))

;;     (sha1 [x]
;;       (let [ctxt (sha1-init)]
;;         (sha1-update x ctxt)
;;         (sha1-finalize ctxt)))

;;     Eq
;;     (=* [x y]
;;       (or (instance? Integer y)
;;           (and (= (get-type x) (get-type y))
;;                (maybe x))))

;;     Ord
;;     (<* [x y]
;;       (or (instance? Integer y)
;;           (and (= (get-type x) (get-type y))
;;                (maybe x))))))

(deftype IntegerConstraint [static-value max min path sym var]
  (assert (instance? (any-of Integer
                             NoInt) static-value))
  (assert (instance? (any-of Integer
                             NoInt) max))
  (assert (instance? (any-of Integer
                             NoInt) min))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/IntegerConstraint " (str static-value) " " (str max) " " (str min) " "
          "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? IntegerConstraint y)
         (= static-value (.static-value y))
         (= max (.max y))
         (= min (.min y))
         (maybe x)))

  Constraint
  (get-type-num [_] IntegerType)
  (get-type-sym [_] 'Integer))

(deftype TypeOfConstraint [param-sym path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/TypeOfConstraint " (sym-str param-sym)
          "(list) "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? TypeOfConstraint y)
         (= param-sym (.param-sym y))
         (maybe x)))

  Constraint
  (assertion-path [_] path)

  (format-path [x desired-len]
    (format-path* (cons ["Type of value from" ""] path)
                  desired-len)))

(deftype DebugConstraint [constraint path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/DebugConstraint " (str constraint)
          "(list) "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Container
  (map [x f]
    (.constraint x (f constraint)))

  (map [x f embed]
    (map (f constraint)
         (fn [new-c]
           (.constraint x new-c))))

  Eq
  (=* [x y]
    (and (instance? DebugConstraint y)
         (= sym (.sym y))
         (maybe x)))

  Constraint
  (show-full [_]
    (show-full constraint))

  (get-type-num [c]
    (get-type-num constraint))

  (intersect [c1 c2]
    (.constraint c1 (intersect constraint c2)))

  (assertion-path [_] path)

  (format-path [x desired-len]
    (format-path* (cons [(str  "Type of " sym) ""] path)
                  desired-len))

  (remove-sym [c]
    (Right constraint))

  (reified-field [c indices]
    (Right constraint))

  (set-path [c new-path]
    (Left (.constraint c (set-path constraint new-path))))

  (add-to-path [c file-name line-number]
    (.constraint c (add-to-path constraint file-name line-number))))

(deftype InnerTypeOfConstraint [param-sym path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/InnerTypeOfConstraint " (str "'" param-sym) " "
          "(list) "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? InnerTypeOfConstraint y)
         (= param-sym (.param-sym y))
         (maybe x)))

  Constraint
  (assertion-path [_] path)

  (format-path [x desired-len]
    (format-path* (cons ["Type of value from" ""] path)
                  desired-len))

  (update-sym [tc new-sym]
    (.sym tc new-sym)))

(deftype SymbolConstraint [static-value path sym var]
  (assert (instance? TypeSym static-value))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/SymbolConstraint " (str static-value) " "
          "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? SymbolConstraint y)
         (= static-value (.static-value y))
         (maybe x)))

  Constraint
  (get-type-num [c]
    SymbolType)

  (get-type-sym [_] 'Symbol))

;; TODO: change back to reified
(deftype NoString []
  Stringable
  (string-list [_]
    (list "c/no-string"))

  Eq
  (=* [x y]
    (or (instance? String y)
        (and (= (get-type x) (get-type y))
             (maybe x)))))

(def no-string (NoString))
;; (def no-string
;;   (reify
;;     Stringable
;;     (string-list [_]
;;       (list "c/no-string"))

;;     Eq
;;     (=* [x y]
;;       (or (instance? String y)
;;           (and (= (get-type x) (get-type y))
;;                (maybe x))))

;;     Hashable
;;     ;; TODO: remove these impls after HashMapConstraint is implented
;;     (sha1-update [x ctxt]
;;       (sha1-update-type x ctxt)
;;       (sha1-update "no-symbol" ctxt))

;;     (sha1 [x]
;;       (let [ctxt (sha1-init)]
;;         (sha1-update x ctxt)
;;         (sha1-finalize ctxt)))))

(deftype StrBuffConstraint [static-value path sym var]
  (assert (instance? (any-of String
                             NoString) static-value))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/StrBuffConstraint " (either (map (= static-value no-string) str)
                                          (str "\"" static-value "\"")) " "
          "(list) "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? StrBuffConstraint y)
         (= static-value (.static-value y))
         (maybe x)))

  Constraint
  (get-type-num [c]
    StringBufferType)

  (get-type-sym [_] 'String))

(deftype SubStrConstraint [static-value path sym var]
  (assert (instance? (any-of String
                             NoString) static-value))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/SubStrConstraint " (either (map (= static-value no-string) str)
                                         (str "\"" static-value "\"")) " "
          "(list) "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? SubStrConstraint y)
         (= static-value (.static-value y))
         (maybe x)))

  Constraint
  (get-type-num [c]
    SubStringType)

  (get-type-sym [_] 'String))

(deftype HashMapConstraint [type-num kv-pairs keys-c vals-c path sym var]
  ;; (assert (instance? Constraint keys-c))
  ;; (assert (instance? Constraint vals-c))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/HashMapConstraint " (str type-num) " " (str kv-pairs) " "
          (str keys-c) " " (str vals-c) " "
          "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? HashMapConstraint y)
         (= kv-pairs (.kv-pairs y))
         (= keys-c (.keys-c y))
         (= vals-c (.vals-c y))
         (maybe x)))

  Constraint
  (show-full [c]
    (list "hash-map (finish this)"))

  (get-type-num [c]
    type-num)

  (get-type-sym [_] 'HashMap))

(deftype ListConstraint [items tail-c path sym var]
  (assert (instance? Vector items))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/ListConstraint " (str items) " " (str tail-c) " "
          "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? ListConstraint y)
         (= items (.items y))
         (= tail-c (.tail-c y))
         (maybe x)))

  Constraint
  (show-full [c]
    (comp (format-path c 0)
          ["--items--"]
          (-> (.items c)
              (interpose ["----"])
              (flat-map (fn [item-strs]
                          (map item-strs (partial str "  ")))))
          ["--tail--"]
          (map tail-c (partial str "  "))
          ["===="]))

  (get-type-num [c]
    ListType)

  (get-type-sym [_] 'List)

  (trim [vc]
    (either (map (instance? ListConstraint tail-c)
                 (fn [tail-c]
                   (-> vc
                       (.items (comp items (.items tail-c)))
                       (.tail-c (.tail-c tail-c)))))
            vc)))

;; TODO: defining a value here using 'bottom-type' causes a bad incRef error. Must be fixed.
;; (def empty-list-constraint (ListConstraint [] bottom-type empty-list nothing ""))
(def empty-list-constraint)

;; TODO: add tail-items to track conj additions
(deftype VectorConstraint [items tail-c path sym var]
  (assert (instance? Vector items))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/VectorConstraint " (str items) " " (str tail-c) " "
          ;; "(list) "
          (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? VectorConstraint y)
         (= items (.items y))
         (= tail-c (.tail-c y))
         (maybe x)))

  Constraint
  (show-full [c]
    (comp (format-path c 0)
          ["--items--"]
          (-> (.items c)
              (interpose ["----"])
              (flat-map (fn [item-strs]
                          (map item-strs (partial str "  ")))))
          ["--tail--"]
          (map tail-c (partial str "  "))
          ["===="]))

  (get-type-num [c]
    VectorType)

  (get-type-sym [_] 'Vector))

(deftype MaybeConstraint [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/MaybeConstraint " (str contents) " "
          "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? MaybeConstraint y)
         (= contents (.contents y))
         (maybe x)))

  Constraint
  (show-full [c]
    (comp (format-path c 0)
          (map contents (partial str "  "))))

  (get-type-num [c] MaybeType)
  (get-type-sym [_] 'Maybe))

(deftype AgentConstraint [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/AgentConstraint " (str contents) " "
          "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? AgentConstraint y)
         (= contents (.contents y))
         (maybe x)))

  Constraint
  (get-type-num [c]
    AgentType)

  (get-type-sym [_] 'Agent))

(deftype FutureConstraint [path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/FutureConstraint " "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? FutureConstraint y)
         (maybe x)))

  Constraint
  (get-type-num [c]
    FutureType)

  (get-type-sym [_] 'Future))

(deftype OpaqueConstraint [path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/OpaqueConstraint " "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? OpaqueConstraint y)
         (maybe x)))

  Constraint
  (get-type-num [c]
    OpaqueType)

  (get-type-sym [_] 'Opaque))

(deftype PromiseConstraint [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/PromiseConstraint " (str contents) " "
          "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? PromiseConstraint y)
         (= contents (.contents y))
         (maybe x)))

  Constraint
  (get-type-num [c]
    PromiseType)

  (get-type-sym [_] 'Promise))

(deftype Variadic []
  Stringable
  (string-list [_] (list "c/variadic")))

(def variadic (Variadic))

(def ArityRank (any-of Integer
                       Variadic))

(deftype fn-arity [arity-id param-consts result-const]
  (assert (instance? Symbol arity-id))
  (assert (instance? ListConstraint param-consts))
  ;; TODO: need recursive types
  ;; (assert (instance? ValueConstraint result-const))

  Stringable
  (string-list [_]
    (list "(c/fn-arity " (str "'" arity-id) "\n" (str param-consts) "\n" (str result-const) ")")))

(deftype FnConstraint [arities path sym var]
  (assert (instance? (map-of ArityRank fn-arity) arities))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/FnConstraint " (str arities) " "
          "(list) "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? FnConstraint y)
         (=* arities (.arities y))
         (maybe x)))

  Constraint
  (show-full [c]
    (format-path c 0))

  (get-type-num [c]
    FunctionType)

  (get-type-sym [_] 'Fn))

;; TODO: add type field constraints
(deftype ReifiedConstraint [type-num fields type-sym invoke-arities path sym var]
  (assert (instance? Integer type-num))
  (assert (instance? HashMap fields))
  (assert (instance? (map-of ArityRank fn-arity) invoke-arities))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/ReifiedConstraint " (str type-num) " " (str fields)
          "\n"
          (str " (symbol \"" type-sym "\")")
          "\n" (str invoke-arities)
          ;; (str (interpose (cons 'list path) " "))
          " (list) "
          " " (sym-str sym) " \"" (str var) "\")" ))

  Eq
  ;; TODO: equality must check the field maps as well
  ;; verify this
  (=* [x y]
    (for [_ (instance? ReifiedConstraint y)
          _ (= fields (.fields y))]
      x))

  Constraint
  (show-full [c]
    (list "Type " (str type-sym)))

  (get-type-sym [c]
    type-sym)

  (get-type-num [c]
    type-num)

  (set-type-name [c new-name]
    (.type-sym c new-name))

  (assertion-path [_] path)

  (format-path [x desired-len]
    (format-path* (cons [(str type-sym "' from") ""]
                        path)
                  desired-len)))

(def not-container (ReifiedConstraint UnknownType {}
                                      (symbol "Can not contain other values")
                                      {} empty-list no-symbol ""))

(defn required-field [fld]
  (ReifiedConstraint UnknownType {fld top-type} no-symbol
                     {} empty-list (symbol (str "field '" (.sym fld) "' required")) ""))

(deftype NoFields []
  Stringable
  (string-list [_]
    (list "<NoFields>")))

(def no-fields (NoFields))

;; TODO: maybe make StrConstraint like HashMapConstraint
(def StrConstraint (any-of StrBuffConstraint
                           SubStrConstraint))

(def SeqConstraint (any-of VectorConstraint
                           ListConstraint))

(def CoreValConstraint (any-of IntegerConstraint
                               SymbolConstraint
                               VectorConstraint
                               ListConstraint
                               StrConstraint
                               HashMapConstraint
                               MaybeConstraint
                               AgentConstraint
                               FutureConstraint
                               OpaqueConstraint
                               PromiseConstraint
                               FnConstraint))

;; TODO: add 'typ-sym' and make it a be optional for all constraints
(deftype SumConstraint [alts path sym var]
  (assert (instance? Vector alts))
  (assert (instance? (min-count 1) alts))
  (assert (instance? TypeSym sym))
  (assert (instance? (list-of Vector) path))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list (str "(c/SumConstraint\n" (str alts) " (list"
               ;; (either (map (first path) (fn [[f l]]
               ;;                             (str "[\"" f "\" " l "]")))
               ;;         "")
               ") " (sym-str sym) " "
               (str "\"" var "\"") ")")))

  Eq
  (=* [x y]
    (and (instance? SumConstraint y)
         (= (count alts) (count (.alts y)))
         (every (.alts y) (fn [c]
                            (some alts (partial =* c))))
         (maybe x)))

  Constraint
  (show-full [c]
    (comp (format-path c 0)
          (-> (.alts c)
              (interpose ["----"])
              (flat-map (fn [alt-strs]
                          (map alt-strs (partial str "  ")))))))

  (assertion-path [x] path)

  (format-path [c n]
    (let [sum-sym (either (and (every (.alts c) (partial instance? CoreValConstraint))
                               (apply = (map (.alts c) get-type-sym)))
                          "Sum Type")]
      (format-path* (cons [(str sum-sym " from") ""] path)
                    n)))

  (get-type-num [c]
    (let [type-nums (map (.alts c) get-type-num)]
      (either (and (first type-nums)
                   (apply = type-nums))
              UnknownType)))

  (remove-sym [tc]
    (Right (.sym tc no-symbol)))

  (extract-var [c]
    var)

  (update-var [c new-var]
    (-> c
        (.alts (map (.alts c) (fn [c]
                                (update-var c new-var))))
        (.var new-var)))

  (satisfied-by [c info]
    (or (and (instance? SumConstraint info)
             (every (.alts info)
                    (fn [info-c]
                      (some (.alts c)
                            (fn [c-c]
                              (satisfied-by c-c info-c))))))
        (some alts (fn [c]
                     (satisfied-by c info))))))

(def fn-constraint (FnConstraint {} empty-list no-symbol ""))
(def type-of-constraint (TypeOfConstraint no-symbol empty-list no-symbol ""))
(def inner-type-of-constraint (InnerTypeOfConstraint 'no-sym empty-list no-symbol ""))
(def sym-constraint (SymbolConstraint no-symbol empty-list no-symbol ""))
(def vect-constraint (VectorConstraint [] coll-of-any empty-list no-symbol ""))
(def list-constraint (ListConstraint [] coll-of-any empty-list no-symbol ""))
(def seq-constraint (SumConstraint [vect-constraint list-constraint]
                                   empty-list no-symbol ""))
(def substr-constraint (SubStrConstraint no-string empty-list no-symbol ""))
(def strbuff-constraint (StrBuffConstraint no-string empty-list no-symbol ""))
(def string-constraint (SumConstraint [strbuff-constraint substr-constraint]
                                      empty-list no-symbol ""))
(def hash-coll-constraint (HashMapConstraint HashCollisionNodeType {} top-type top-type empty-list no-symbol ""))
(def array-constraint (HashMapConstraint ArrayNodeType {} top-type top-type empty-list no-symbol ""))
(def bitmap-constraint (HashMapConstraint BitmapIndexedType {} top-type top-type empty-list no-symbol ""))
(def hashmap-constraint (SumConstraint [bitmap-constraint array-constraint hash-coll-constraint]
                                       empty-list no-symbol ""))
(def int-constraint (IntegerConstraint no-int int-max int-min empty-list no-symbol ""))
(def maybe-constraint  (MaybeConstraint top-type empty-list no-symbol ""))
(def set-constraint (ReifiedConstraint HashSetType {(SymbolConstraint 'set-map empty-list no-symbol "")
                                                    hashmap-constraint}
                                       'HashSet {} empty-list no-symbol ""))
(def agent-constraint (AgentConstraint top-type empty-list no-symbol ""))
(def promise-constraint (PromiseConstraint top-type empty-list no-symbol ""))
(def future-constraint (FutureConstraint empty-list no-symbol ""))
(def opaque-constraint (OpaqueConstraint empty-list no-symbol ""))
(def arity-constraint (ReifiedConstraint FnArityType {} 'FnArity {} empty-list no-symbol ""))

(def core-type-constraints {'Integer int-constraint
                            'StringBuffer strbuff-constraint
                            'SubString substr-constraint
                            'FnArity arity-constraint
                            'BitmapIndexedNode bitmap-constraint
                            'ArrayNode array-constraint
                            'HashCollisionNode hash-coll-constraint
                            'Fn fn-constraint
                            'List list-constraint
                            'Maybe maybe-constraint
                            'Vector vect-constraint
                            'Symbol sym-constraint
                            'HashMap hashmap-constraint
                            'Promise promise-constraint
                            'Future future-constraint
                            'Agent agent-constraint
                            'Opaque opaque-constraint})

(deftype DynamicFields [type-c fields path sym var]
  (assert (instance? TypeSym sym))
  (assert (instance? ReifiedConstraint type-c))
  (assert (instance? (vector-of Field) fields))

  Stringable
  (string-list [_]
    (list "(c/DynamicFields "
          (str type-c) "\n"
          (str fields) "\n"
          (str " " "(list)" ;; (cons 'list path)
               )
          " " (sym-str sym)
          " " (str "\"" var "\"")
          ")"))

  Eq
  (=* [x y]
    (and (instance? DynamicFields y)
         (maybe x))))

(deftype ParamConstraint [arity param-index item-indices mods path sym var]
  (assert (instance? TypeSym sym))
  (assert (instance? Vector item-indices))

  Stringable
  (string-list [_]
    (list "(c/ParamConstraint " (str "'" arity) " " (str param-index) " " (str item-indices)
          "\n[" (to-str (interpose mods "\n "))
          "]\n"
          ;;  "(list)"
          (str " " (cons 'list path))
          " " (sym-str sym)
          " " (str "\"" var "\"")
          ")"))

  Constraint
  (show-full [c]
    (comp (format-path c 0)
          (-> (.mods c) 
              ;; (interpose "---\n")
              (flat-map (fn [mod-strs]
                          (map mod-strs (partial str "  ")))))))

  (format-path [x desired-len]
    (format-path* (cons [(str "Parameter " param-index " from") ""] path)
                  desired-len))

  (dynamic-params [c]
    [c])

  (set-arity [c new-arity]
    (.arity c new-arity))

  Eq
  (=* [x y]
    (and (instance? ParamConstraint y)
         (= param-index (.param-index y))
         (= mods (.mods y))
         (maybe x))))

(defn mod-param [c mod]
  (assert (instance? ParamConstraint c))

  (cond (flat-map (last (.mods c)) (partial = mod))
        c

        (.mods c (conj (.mods c) mod))))

(deftype ReifiedFields [field-cs path sym var]
  (assert (instance? TypeSym sym))
  (assert (instance? Vector field-cs))

  Stringable
  (string-list [_]
    (list "(c/ReifiedFields\n" (str "[" (to-str (interpose field-cs "\n")) "]")
          " (list)" ;; (str " " (cons 'list path))
          " " (sym-str sym)
          " " (str "\"" var "\"")
          ")"))

  Eq
  (=* [x y]
    (and (instance? ReifiedFields y)
         (= field-cs (.field-cs y))
         (maybe x))))

(def DynamicConstraint (any-of DynamicFields
                               ReifiedFields
                               ParamConstraint))

(def SymbolConstraints (any-of CoreValConstraint
                               InferredInner
                               CollectionOf
                               SumConstraint
                               ReifiedConstraint
                               InferredInner
                               CollectionOf
                               InnerTypeOfConstraint
                               TypeOfConstraint
                               DebugConstraint
                               DynamicConstraint))

(deftype NoValues [constraints]
  Stringable
  (string-list [_]
    (list "(c/NoValues\n[" (to-str (interpose constraints "\n")) "])"))

  Constraint
  (intersect [nv c]
    (cond (instance? DebugConstraint c)
          (intersect c nv)

          nv))

  (update-sym [x _] x)
  (update-var [x _] x)

  (show-full [c]
    (comp (list "Conflicting types")
          (map constraints (partial str "  "))))

  (trim [c]
    (.constraints c (comp (remove constraints (partial instance? NoValues))
                          (-> constraints
                              (filter (partial instance? NoValues))
                              (flat-map .constraints)))))

  (format-path [c n]
    (let [max-len (-> (trim c)
                      .constraints
                      (map (fn [c] (count (assertion-path c))))
                      (reduce n (fn [max-len path-len]
                                  (either (> max-len path-len)
                                          path-len)))
                      inc)]
      (-> constraints
          (map (fn [c]
                 (format-path c max-len)))
          (list-zipper empty-list)
          (map (fn [strs]
                 (str (to-str (interpose strs "    "))
                      "\n"))))))

  Eq
  (=* [x y]
    (and (=* (get-type x) (get-type y))
         (or (and (empty? constraints)
                  (maybe y))
             (maybe x)))))

(def bottom-type (NoValues []))
(def empty-list-constraint (ListConstraint [] bottom-type empty-list no-symbol ""))
(def empty-vector-constraint (VectorConstraint [] bottom-type empty-list no-symbol ""))

(def ValueConstraint (any-of SymbolConstraints
                             AllValues))

(deftype ResultConstraint [assertion]
  Stringable
  (string-list [_] (list "(c/ResultConstraint " (str assertion) ")"))

  Constraint
  ;; TODO: these impls seem sketchy
  (update-var [_ new-var]
    (ResultConstraint (update-var assertion new-var)))

  (update-sym [_ new-sym]
    (ResultConstraint (update-sym assertion new-sym))))

(def Constraints (any-of ValueConstraint
                         NoValues
                         ResultConstraint))

(defn reify-type-constraint [c arity param-cs loc]
  (assert (instance? Constraints c))

  ;; (or (= (.file loc) 'core)
  ;;     (= (.line loc) 0)
  ;;     (do
  ;;       (print-err 'reifying loc arity "\n"
  ;;                  c "\n\n"
  ;;                  'params param-cs)
  ;;       nothing))
  (let [r (either (first ((se/try
                            (comp (map (apo (fn [c]
                                              (reify-c c arity loc))
                                            c
                                            se/state-error)
                                       (partial cata trim))
                                  (se/state-error top-type))
                            (fn [_]
                              (se/state-error top-type)))
                          param-cs))
                  c)]
    ;; (or (= (.file loc) 'core)
    ;;     (= (.line loc) 0)
    ;;     (do
    ;;       (print-err 'reified loc arity "\n"
    ;;                  r)
    ;;       nothing))
    r))

;; private operations on Constraints
(defprotocol ConstraintOps
  (is-bottom [c]
    )

  (intersect-fn [c fn-c]
    (assert (instance? FnConstraint fn-c))

    (NoValues [c fn-c]))

  (intersect-int [c int-c]
    (assert (instance? IntegerConstraint int-c))

    (NoValues [c int-c]))

  (intersect-sym [c sym-c]
    (assert (instance? SymbolConstraint sym-c))

    (NoValues [c sym-c]))

  (intersect-promise [c promise-c]
    (assert (instance? PromiseConstraint promise-c))

    (NoValues [c promise-c]))

  (intersect-agent [c agent-c]
    (assert (instance? AgentConstraint agent-c))

    (NoValues [c agent-c]))

  (intersect-str [c str-c]
    (assert (instance? StrConstraint str-c))

    (NoValues [c str-c]))

  (intersect-maybe [c maybe-c]
    (assert (instance? MaybeConstraint maybe-c))

    (NoValues [c maybe-c]))

  (intersect-hash-map [c map-c]
    (assert (instance? HashMapConstraint map-c))

    (NoValues [c map-c]))

  (intersect-vector [c vect-c]
    (assert (instance? VectorConstraint vect-c))

    (NoValues [c vect-c]))

  (intersect-list [c vect-c]
    (assert (instance? ListConstraint vect-c))

    (NoValues [c vect-c]))

  (intersect-param [c dyn-c]
    (assert (instance? ParamConstraint dyn-c))

    (mod-param dyn-c c))

  (intersect-result [c rc]
    (assert (instance? ResultConstraint rc))
    nothing)

  (extract-field [c fld]
    (assert (instance? Field fld))

    (NoValues [c (required-field fld)]))

  (sum-c-satisfies [info c]
    (assert (instance? ValueConstraint c))
    (assert-result r (instance? (maybe-of (maybe-of ValueConstraint)) r))

    nothing)

  (=-result-constraint [y x]
    (assert (instance? ResultConstraint x))
    nothing)

  (=-contentsc [x y]
    nothing)

  (=-static-str [y x]
    nothing)

  (=-inferred-inner [y x]
    nothing)

  (intersect-reified-val [c reified]
    (assert (instance? ReifiedConstraint reified))
    (assert-result r (instance? Constraints r))

    (NoValues [c reified]))

  (intersect-coll-of [c cc]
    (assert (instance? CollectionOf cc))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var cc)) cc))

  (intersect-reified [c reified]
    (assert (instance? ReifiedFields reified))

    reified)

  (intersect-sum [c cs]
    (assert (instance? SumConstraint cs))

    (let [inters (map (.alts cs) (partial intersect (update-var c (extract-var cs))))
          goods (-> inters
                    (remove (partial instance? NoValues))
                    (reduce [] (fn [goods c]
                                 (either (and (some goods (partial = c))
                                              (maybe goods))
                                         (conj goods c)))))]
      (either (or (and (empty? goods)
                       (or (apply = inters)
                           (maybe (NoValues [c cs]))))
                  (and (= (count goods) 1)
                       (first goods)))
              (.alts cs goods))))

  (intersect-inner [c ic]
    (assert (instance? InferredInner ic))
    (assert-result r (instance? Constraints r))

    (intersect (update-var c (extract-var ic)) ic)))

(defn conflicting-assertions
  ([failing-constraint loc]
   (conflicting-assertions failing-constraint (.file loc) (.line loc)))

  ([failing-constraint file-name line-number]
   ;; (print-err 'failed failing-constraint)
   (apply print-err (list* "Conflicting assertions"
                           (either (= "" file-name)
                                   (str "at " file-name ": " line-number))
                           "\n"
                           (-> failing-constraint
                               ;; TODO: add file-name/line-number to empty paths
                               (format-path 0))))
   nothing))

(extend-type Vector
  Constraint
  (trim [v]
    (map v trim)))

(extend-type Constraints
  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Constraint
  (coll-constraint [x]
    (collection-of x))

  (old-extract-items-constraints [c n]
    (-> (extract-items-constraints c)
        (comp (repeat n top-type))
        (take n)))

  (contents-constraint [_]
    (Left top-type)))

(extend-type NoValues
  ;; TODO: this is wrong and in the wrong place
  ;; Container
  ;; (map [x f]
  ;;   (.constraints x (f (.constraints x))))

  ;; (map [x f embed]
  ;;   (-> (.constraints x)
  ;;       f
  ;;       (map (partial .constraints x))))

  Constraint
  (collection-of [x]
    (Left x))

  (contents-constraint [c]
    (Left c))

  ConstraintOps
  (intersect-str [c _] c)
  (intersect-int [c _] c)
  (intersect-sym [c _] c)
  (intersect-maybe [c _] c)
  (intersect-hash-map [c _] c)
  (intersect-vector [c _] c)
  (intersect-list [c _] c)
  (intersect-agent [c _] c)
  (intersect-promise [c _] c)
  (intersect-fn [c _] c)
  (is-bottom [c] c)
  (intersect-param [c _] c)
  (intersect-reified [c _] c)
  (intersect-reified-val [c _] c))

(extend-type AllValues
  Constraint
  (collection-of [x]
    (Left x))

  ConstraintOps
  (intersect-str [_ c] c)
  (intersect-int [_ c] c)
  (intersect-sym [_ c] c)
  (intersect-maybe [_ c] c)
  (intersect-hash-map [_ c] c)
  (intersect-vector [_ c] c)
  (intersect-list [_ c] c)
  (intersect-agent [_ c] c)
  (intersect-promise [_ c] c)
  (intersect-fn [_ c] c)
  (is-bottom [c] c)
  (extract-field [x _] x)
  (intersect-param [c dyn-c] dyn-c)
  (intersect-sum [c sc] sc)
  (intersect-result [c rc] rc)
  (intersect-reified-val [c tc] tc)
  (intersect-coll-of [c cc] cc)
  (intersect-inner [c ic] ic))

(extend-type SymbolConstraints
  Constraint
  (clear-var [c]
    (.var c ""))

  (set-path [c new-path]
    (Left (.path c new-path)))

  (add-to-path [c file line]
    (cond (or (= file "")
              (some (.path c) (partial = [file line])))
          c
          (.path c (cons [file line] (.path c)))))

  (extract-sym [c]
    (instance? Symbol (.sym c)))

  (remove-sym [tc]
    (Left (.sym tc no-symbol)))

  (update-sym [tc new-sym]
    (.sym tc new-sym))

  (collection-of [x]
    (Right top-type))

  (extract-var [c]
    (.var c))

  (update-var [tc new-var]
    (.var tc new-var))

  ConstraintOps
  (is-bottom [c] c))

(defn clear-vars [c]
  (cata clear-var c))

(defn sum-type [const-cs]
  (assert (instance? Vector const-cs))

  (either (or (flat-map (every const-cs (partial = bottom-type))
                        (fn [_]
                          (first const-cs)))
              (let [const-cs (remove const-cs (partial = bottom-type))]
                (or (and (= 1 (count const-cs))
                         (first const-cs))
                    (and (empty? const-cs)
                         (maybe top-type))
                    (some const-cs (partial = top-type))
                    (apply = const-cs)
                    (and (every const-cs (partial instance? CollectionOf))
                         (-> const-cs
                             (map .contents)
                             sum-type
                             (CollectionOf empty-list no-symbol "")
                             maybe))
                    (and (< 1 (count const-cs))
                         (maybe (SumConstraint const-cs empty-list no-symbol ""))))))
          top-type))

(extend-type CoreValConstraint
  Constraint
  (assertion-path [x] (.path x))

  (format-path [x desired-len]
    (format-path* (cons [(str (get-type-sym x)) " from:" ""] (.path x))
                  desired-len))

  ConstraintOps
  (intersect-reified [c reified]
    (NoValues [c reified]))

  (intersect-coll-of [c cc]
    (NoValues [c cc]))

  (intersect-vector [c vect-c]
    (NoValues [c vect-c]))

  (intersect-list [c vect-c]
    (NoValues [c vect-c]))

  (intersect-inner [c ic]
    (NoValues [c ic])))

(extend-type IntegerConstraint
  Constraint
  (intersect [x y]
    (intersect-int y x))

  (show-full [c]
    (format-path c 0))

  (format-path [c desired-len]
    (format-path* (cons [(str "Integer " (.static-value c) " from:") ""] (.path c))
                  desired-len))

  (contents-constraint [c]
    (Left (NoValues [c not-container])))

  ConstraintOps
  (intersect-int [y x]
    (let [new-min (either (> (.min x) (.min y))
                          (.min y))
          new-max (either (< (.max x) (.max y))
                          (.max y))
          new-static (or (= no-int (.static-value x) (.static-value y))
                         (flat-map (or (= (.static-value x) (.static-value y))
                                       (= (.static-value y) (.static-value x)))
                                   (fn [new-static]
                                     (and (<= new-min new-static new-max)
                                          (maybe new-static)))))]
      (either (map new-static (fn [new-static]
                                ;; TODO: use the path from the most restrictive constraint
                                ;; determined by satisfied-by
                                (-> x
                                    (.static-value new-static)
                                    (.min new-min)
                                    (.max new-max))))
              (NoValues [x y]))))

  (is-bottom [c] c))

(extend-type SymbolConstraint
  Constraint
  (show-full [c]
    (format-path c 0))

  (format-path [x desired-len]
    (format-path* (cons [(str "Symbol " (either (= no-symbol (.static-value x))
                                                (str "'" (.static-value x)))
                              " from:") ""]
                        (.path x))
                  desired-len))

  (intersect [x y]
    (intersect-sym y x))

  (contents-constraint [c]
    (Left (NoValues [c not-container])))

  ConstraintOps
  (intersect-sym [x y]
    (either (map (or (= (.static-value x) (.static-value y))
                     (= (.static-value y) (.static-value x)))
                 ;; TODO: use the path from the most restrictive constraint
                 ;; determined by satisfied-by
                 (partial .static-value x))
            (NoValues [x y])))

  (is-bottom [c] c))

(extend-type StrConstraint
  Constraint
  (show-full [c]
    (format-path c 0))

  (format-path [x desired-len]
    (format-path* (cons [(str "String " (either (= no-string (.static-value x))
                                                (str "\"" (.static-value x) "\""))
                              " from:") ""]
                        (.path x))
                  desired-len))

  (intersect [x y]
    (intersect-str y x))

  ConstraintOps
  (intersect-coll-of [str-c c]
    (intersect-str (.contents c) strbuff-constraint))

  (intersect-inner [str-c c]
    (intersect-str (.contents c) strbuff-constraint))

  (intersect-str [y x]
    (either (map (or (= (.static-value x) (.static-value y))
                     (= (.static-value y) (.static-value x)))
                 ;; TODO: use the path from the most restrictive constraint
                 ;; determined by satisfied-by
                 (fn [stat-val]
                   (cond (instance? StrBuffConstraint y)
                         (.static-value y stat-val)

                         (.static-value x stat-val))))
            (NoValues [x y])))

  (is-bottom [c] c))

(extend-type HashMapConstraint
  Container
  (map [c f]
    (-> c
        (.keys-c (f (.keys-c c)))
        (.vals-c (f (.vals-c c)))
        (.kv-pairs (-> (.kv-pairs c)
                       vec
                       (reduce {} (fn [m [k v]]
                                    (assoc m
                                      (f k) (f v))))))))

  (map [c f embed]
    (for [new-keys (f (.keys-c c))
          new-vals (f (.vals-c c))
          new-kv (-> (.kv-pairs c)
                     vec
                     (map (fn [[key-c val-c]]
                            (for [new-key (f key-c)
                                  new-val (f val-c)]
                              [new-key new-val]))
                          embed))]
      (-> c
          (.keys-c new-keys)
          (.vals-c new-vals)
          (.kv-pairs (reduce new-kv {} (fn [m [k v]]
                                         (assoc m k v)))))))


  Constraint
  (intersect [x y]
    (intersect-hash-map y x))

  ConstraintOps
  (extract-field [c fld]
    (NoValues [c (ReifiedConstraint UnknownType {fld top-type}
                                    (symbol (str "field '" (.sym fld) "' required"))
                                    {} empty-list no-symbol "")]))

  (intersect-hash-map [y x]
    (let [new-keys (intersect (.keys-c x) (.keys-c y))
          new-vals (intersect (.vals-c x) (.vals-c y))
          new-kv (-> (merge-with intersect (.kv-pairs x) (.kv-pairs y))
                     vec
                     (reduce {} (fn [m [k v]]
                                  (assoc m
                                    (intersect new-keys k) (intersect new-vals v)))))]
      (cond (= (.type-num x) (.type-num y))
            (-> x
                (.keys-c new-keys)
                (.vals-c new-vals)
                (.kv-pairs new-kv)
                is-bottom)

            (SumConstraint [(-> x
                                (.keys-c new-keys)
                                (.vals-c new-vals)
                                (.kv-pairs new-kv)
                                is-bottom)
                            (-> y
                                (.keys-c new-keys)
                                (.vals-c new-vals)
                                (.kv-pairs new-kv)
                                is-bottom)]
                           empty-list no-symbol ""))))

  (intersect-reified-val [hmc rc]
    (intersect-hash-map rc hmc))

  (is-bottom [c]
    (either (or (= bottom-type (.keys-c c))
                (= bottom-type (.vals-c c))
                (-> (.kv-pairs c)
                    vec
                    (some (fn [[k v]]
                            (or (= bottom-type k)
                                (= bottom-type v))))))
            c)))

(extend-type ListConstraint
  Container
  (map [c f]
    (-> c
        (.tail-c (f (.tail-c c)))
        (.items (map (.items c) f))))

  (map [c f embed]
    (for [new-tail-c (f (.tail-c c))
          new-items (map (.items c) f embed)]
      (-> c
          (.tail-c new-tail-c)
          (.items new-items))))


  Constraint
  (intersect [x y]
    (intersect-list y x))

  (get-tail-constraint [c old-c]
    (.tail-c old-c))

  (fixed-items-constraints [c old-ic]
    (comp (.items old-ic)
          (.tail-c c)))

  (old-extract-items-constraints [c n]
    (either (and (<= n 0)
                 (maybe []))
            (let [needed-tail-items (- n (count (.items c)))
                  tail-items (cond (= (.tail-c c) bottom-type)
                                   (repeat needed-tail-items (.tail-c c))

                                   (-> (.tail-c c)
                                       (old-extract-items-constraints needed-tail-items)))]
              (-> (.items c)
                  (comp tail-items)
                  (take n)))))

  (contents-constraint [c]
    (Left (-> (.items c)
              (conj (either (= bottom-type (.tail-c c))
                            (extract-contents-constraint (.tail-c c))))
              sum-type)))

  ConstraintOps
  ;; TODO: will probably need this
  ;; (items-satisfied [info c]
  ;;   (let [c-items (.items-constraints c)
  ;;         info-items (extract-items-constraints info (count c-items))]
  ;;     (and (<= (count c-items) (count (.items-constraints info)))
  ;;          (every (zip-lists c-items info-items)
  ;;                 (fn [[c info]]
  ;;                   (satisfied-by c info)))
  ;;          (satisfied-by (.tail-constraint c) (.tail-constraint info))
  ;;          (maybe info))))

  (intersect-coll-of [c cc]
    (let [new-items (map (.items c)
                         (fn [c]
                           (let [new-c (-> (.contents cc)
                                           (intersect c))]
                             (either (instance? NoValues new-c)
                                     (update-var new-c (extract-var c))))))
          new-tail (either (= (.tail-c c) bottom-type)
                           (intersect cc (.tail-c c)))]
      (cond (= (.contents cc) bottom-type)
            (.tail-c list-constraint bottom-type)

            (either (or (some new-items (partial = bottom-type))
                        (cond (= (.tail-c c) bottom-type)
                              nothing
                              (= new-tail bottom-type)))
                    (-> c
                        (.items new-items)
                        (.tail-c new-tail))))))

  (intersect-sum [c cs]
    (assert (instance? SumConstraint cs))

    (let [list-alts (filter (.alts cs) (partial instance? ListConstraint))
          inters (map (.alts cs) (partial intersect (update-var c (extract-var cs))))
          goods (-> inters
                    (remove (partial instance? NoValues))
                    (reduce [] (fn [goods c]
                                 (either (and (some goods (partial = c))
                                              (maybe goods))
                                         (conj goods c)))))]
      (either (or (and (empty? goods)
                       (or (and (first list-alts)
                                (apply = (map list-alts (partial intersect (update-var c (extract-var cs))))))
                           (maybe (NoValues [c cs]))))
                  (and (= (count goods) 1)
                       (first goods)))
              (.alts cs goods))))

  (intersect-inner [c ic]
    (let [new-items (map (.items c)
                         (fn [c]
                           (-> (.contents ic)
                               (intersect c)
                               (update-var (extract-var c)))))
          new-tail (either (= (.tail-c c) bottom-type)
                           (intersect ic (.tail-c c)))]
      (cond (= (.contents ic) bottom-type)
            (.tail-c list-constraint bottom-type)

            (either (or (some new-items (partial = bottom-type))
                        (cond (= (.tail-c c) bottom-type)
                              nothing
                              (= new-tail bottom-type)))
                    (-> c
                        (.items new-items)
                        (.tail-c new-tail))))))

  (intersect-list [c lc]
    (assert (instance? ListConstraint lc))

    (let [c (cata trim c)
          c-tail (either (flat-map (get-in c [.tail-c .contents])
                                   (partial = bottom-type))
                         (.tail-c c))
          lc (cata trim lc)
          lc-tail (either (flat-map (get-in lc [.tail-c .contents])
                                    (partial = bottom-type))
                          (.tail-c lc))
          cnt-ic (count (.items lc))
          cnt-c (count (.items c))
          max-cnt (either (> cnt-ic cnt-c)
                          cnt-c)
          items (map (zip-lists (extract-items-constraints lc max-cnt)
                                (extract-items-constraints c max-cnt))
                     (fn [[c1 c2]]
                       (intersect c1 c2)))
          new-tail (intersect lc-tail c-tail)
          new-ic (-> lc
                     (.tail-c new-tail)
                     (.items (vec items)))]
      (either (map (some items (partial = bottom-type))
                   (fn [failure]
                     (cond (empty? (.constraints failure))
                           (NoValues [c lc])

                           failure)))
              (cond (< (count items) max-cnt)
                    (NoValues [c lc])

                    (or (= bottom-type lc-tail)
                        (= bottom-type c-tail))
                    new-ic

                    (either (= bottom-type new-tail)
                            new-ic)))))

  ;; TODO: might bring something like this back in because of 'get' called on a vector
  ;; (intersect-typec [c tc]
  ;;   (either (map (get-in tc [.type-maps UnknownType])
  ;;                (fn [field-map]
  ;;                  (-> c
  ;;                      (.kv-pairs (reduce (vec field-map) (.kv-pairs c)
  ;;                                         (fn [m [k v]]
  ;;                                           (let [new-k (intersect (.keys-c c) k)
  ;;                                                 new-v (intersect (.vals-c c) v)]
  ;;                                             (either (for [static-key (get new-k .static-value)
  ;;                                                           :when (or (= static-key no-symbol)
  ;;                                                                     (= static-key no-string)
  ;;                                                                     (= static-key no-int))
  ;;                                                           curr-v (get m new-k)]
  ;;                                                       (assoc m new-k (trim (sum-type [curr-v new-v]))))
  ;;                                                     (assoc m new-k new-v))))))
  ;;                      is-bottom)))
  ;;           (NoValues [c tc])))

  (is-bottom [c]
    (either (some (.items c) (partial = bottom-type))
            c)))

(extend-type VectorConstraint
  Container
  (map [c f]
    (-> c
        (.tail-c (f (.tail-c c)))
        (.items (map (.items c) f))))

  (map [c f embed]
    (for [new-tail-c (f (.tail-c c))
          new-items (map (.items c) f embed)]
      (-> c
          (.tail-c new-tail-c)
          (.items new-items))))


  Constraint
  (trim [vc]
    (either (map (instance? SeqConstraint (.tail-c vc))
                 (fn [tail-c]
                   (-> vc
                       (.items (comp (.items vc) (.items tail-c)))
                       (.tail-c (.tail-c tail-c)))))
            vc))

  (intersect [x y]
    (intersect-vector y x))

  (get-tail-constraint [c old-c]
    (.tail-c old-c))

  (fixed-items-constraints [c old-ic]
    (comp (.items old-ic)
          (.tail-c c)))

  (old-extract-items-constraints [c n]
    (either (and (<= n 0)
                 (maybe []))
            (let [needed-tail-items (- n (count (.items c)))
                  tail-items (cond (= (.tail-c c) bottom-type)
                                   (repeat needed-tail-items (.tail-c c))

                                   (-> (.tail-c c)
                                       (old-extract-items-constraints needed-tail-items)))]
              (-> (.items c)
                  (comp tail-items)
                  (take n)))))

  (contents-constraint [c]
    (Left (-> (.items c)
              (conj (either (= bottom-type (.tail-c c))
                            (extract-contents-constraint (.tail-c c))))
              sum-type)))

  ConstraintOps
  ;; TODO: will probably need this
  ;; (items-satisfied [info c]
  ;;   (let [c-items (.items-constraints c)
  ;;         info-items (extract-items-constraints info (count c-items))]
  ;;     (and (<= (count c-items) (count (.items-constraints info)))
  ;;          (every (zip-lists c-items info-items)
  ;;                 (fn [[c info]]
  ;;                   (satisfied-by c info)))
  ;;          (satisfied-by (.tail-constraint c) (.tail-constraint info))
  ;;          (maybe info))))

  (intersect-sum [c cs]
    (assert (instance? SumConstraint cs))

    (let [vect-alts (filter (.alts cs) (partial instance? VectorConstraint))
          inters (map (.alts cs) (partial intersect (update-var c (extract-var cs))))
          goods (-> inters
                    (remove (partial instance? NoValues))
                    (reduce [] (fn [goods c]
                                 (either (and (some goods (partial = c))
                                              (maybe goods))
                                         (conj goods c)))))]
      (either (or (and (empty? goods)
                       (or (and (first vect-alts)
                                (apply = (map vect-alts (partial intersect (update-var c (extract-var cs))))))
                           (maybe (NoValues [c cs]))))
                  (and (= (count goods) 1)
                       (first goods)))
              (.alts cs goods))))

  (intersect-coll-of [c cc]
    (let [new-items (map (.items c)
                         (fn [c]
                           (let [new-c (-> (.contents cc)
                                           (intersect c))]
                             (either (instance? NoValues new-c)
                                     (update-var new-c (extract-var c))))))
          new-tail (either (= (.tail-c c) bottom-type)
                           (intersect cc (.tail-c c)))]
      (cond (= (.contents cc) bottom-type)
            (.tail-c vect-constraint bottom-type)

            (either (or (some new-items (partial = bottom-type))
                        (cond (= (.tail-c c) bottom-type)
                              nothing
                              (= new-tail bottom-type)))
                    (-> c
                        (.items new-items)
                        (.tail-c new-tail))))))

  (intersect-inner [c ic]
    (let [new-items (map (.items c)
                         (fn [c]
                           (-> (.contents ic)
                               (intersect c)
                               (update-var (extract-var c)))))
          new-tail (either (= (.tail-c c) bottom-type)
                           (intersect ic (.tail-c c)))]
      (cond (= (.contents ic) bottom-type)
            (.tail-c vect-constraint bottom-type)

            (either (or (some new-items (partial = bottom-type))
                        (cond (= (.tail-c c) bottom-type)
                              nothing
                              (= new-tail bottom-type)))
                    (-> c
                        (.items new-items)
                        (.tail-c new-tail))))))

  (intersect-vector [c vc]
    (assert (instance? VectorConstraint vc))

    (let [c (cata trim c)
          c-tail (either (flat-map (get-in c [.tail-c .contents])
                                   (partial = bottom-type))
                         (.tail-c c))
          vc (cata trim vc)
          vc-tail (either (flat-map (get-in vc [.tail-c .contents])
                                    (partial = bottom-type))
                          (.tail-c vc))
          cnt-ic (count (.items vc))
          cnt-c (count (.items c))
          max-cnt (either (> cnt-ic cnt-c)
                          cnt-c)
          items (map (zip-lists (extract-items-constraints vc max-cnt)
                                (extract-items-constraints c max-cnt))
                     (fn [[c1 c2]]
                       (intersect c1 c2)))
          new-tail (intersect vc-tail c-tail)
          new-ic (-> vc
                     (.tail-c new-tail)
                     (.items (vec items)))]
      (either (map (some items (partial = bottom-type))
                   (fn [failure]
                     (cond (empty? (.constraints failure))
                           (NoValues [c vc])

                           failure)))
              (cond (< (count items) max-cnt)
                    (NoValues [c vc])

                    (or (= bottom-type vc-tail)
                        (= bottom-type c-tail))
                    new-ic

                    (either (= bottom-type new-tail)
                            new-ic)))))

  ;; TODO: might bring something like this back in because of 'get' called on a vector
  ;; (intersect-typec [c tc]
  ;;   (either (map (get-in tc [.type-maps UnknownType])
  ;;                (fn [field-map]
  ;;                  (-> c
  ;;                      (.kv-pairs (reduce (vec field-map) (.kv-pairs c)
  ;;                                         (fn [m [k v]]
  ;;                                           (let [new-k (intersect (.keys-c c) k)
  ;;                                                 new-v (intersect (.vals-c c) v)]
  ;;                                             (either (for [static-key (get new-k .static-value)
  ;;                                                           :when (or (= static-key no-symbol)
  ;;                                                                     (= static-key no-string)
  ;;                                                                     (= static-key no-int))
  ;;                                                           curr-v (get m new-k)]
  ;;                                                       (assoc m new-k (trim (sum-type [curr-v new-v]))))
  ;;                                                     (assoc m new-k new-v))))))
  ;;                      is-bottom)))
  ;;           (NoValues [c tc])))

  (is-bottom [c]
    (either (or (some (.items c) (partial = bottom-type))
                (flat-map (= bottom-type (.tail-c c))
                          (fn [c]
                            (first (.constraints c)))))
            c)))

(extend-type MaybeConstraint
  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (map (f (.contents x))
         (partial .contents x)))

  Constraint
  (intersect [x y]
    (intersect-maybe y x))

  (contents-constraint [c]
    (Left (.contents c)))

  ConstraintOps
  (intersect-coll-of [x y]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (intersect-inner [x y]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (intersect-maybe [y x]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (is-bottom [c]
    (either (= bottom-type (.contents c))
              c)))

(extend-type PromiseConstraint
  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (map (f (.contents x))
         (partial .contents x)))

  Constraint
  (intersect [x y]
    (intersect-promise y x))

  (contents-constraint [c]
    (Left (.contents c)))

  ConstraintOps
  (intersect-coll-of [x y]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (intersect-inner [x y]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (intersect-promise [y x]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (is-bottom [c]
    (either (= bottom-type (.contents c))
              c)))

(extend-type AgentConstraint
  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (map (f (.contents x))
         (partial .contents x)))

  Constraint
  (intersect [x y]
    (intersect-agent y x))

  (contents-constraint [c]
    (Left (.contents c)))

  ConstraintOps
  (intersect-coll-of [x y]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (intersect-inner [x y]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (intersect-agent [y x]
    (let [contents (intersect (.contents x) (.contents y))]
      (either (= bottom-type contents)
              (.contents x contents))))

  (is-bottom [c]
    (either (= bottom-type (.contents c))
              c)))

(extend-type FutureConstraint
  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Constraint
  (intersect [x y]
    (cond (=* x y)
          x

          (instance? DebugConstraint y)
          (intersect y x)

          (instance? ParamConstraint y)
          (mod-param y x)

          (and (or (= y top-type)
                   (instance? CollectionOf y)
                   (instance? InferredInner y)))
          x

          (= y bottom-type)
          y

          (NoValues [x y])))

  (contents-constraint [c]
    (Left (NoValues [c not-container])))

  ConstraintOps
  (intersect-inner [fc _]
    fc)

  (intersect-coll-of [fc _]
    fc)

  (is-bottom [c]
    nothing))

(extend-type OpaqueConstraint
  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Constraint
  (intersect [x y]
    (cond (or (=* x y)
              (= y top-type))
          x

          (instance? DebugConstraint y)
          (intersect y x)

          (instance? ParamConstraint y)
          (mod-param y x)

          (= y bottom-type)
          y

          (NoValues [x y])))

  (contents-constraint [c]
    (Left (NoValues [c not-container])))

  ConstraintOps
  (is-bottom [c]
    nothing))

(extend-type ResultConstraint
  Container
  (map [x f]
    (.assertion x (f (.assertion x))))

  (map [x f embed]
    (-> (.assertion x)
        f
        (map (partial .assertion x))))

  Eq
  (=* [x y]
    (and (or (=-result-constraint y x)
             (=* (.assertion x) y))
         (maybe x)))

  Constraint
  (intersect [rc c]
    (let [intersected (either (intersect-result c rc)
                              (intersect (.assertion rc) c))]
      (either (= intersected bottom-type)
              (ResultConstraint intersected))))

  ConstraintOps
  (is-bottom [c]
    (either (= (.assertion c) bottom-type)
            c))

  (=-result-constraint [y x]
    (=* (.assertion x) (.assertion y)))

  (intersect-result [c rc]
    (maybe (intersect (.assertion rc) (.assertion c)))))

(extend-type ReifiedConstraint
  Container
  (map [tc f]
    (.fields tc (-> (.fields tc)
                    vec
                    (map (fn [[fld fld-c]]
                           [(f fld) (f fld-c)]))
                    (reduce {} (fn [m [k v]]
                                 (assoc m k v))))))

  (map [tc f embed]
    (map (-> (.fields tc)
             vec
             (map (fn [[fld fld-c]]
                    (for [new-fld (f fld)
                          new-c (f fld-c)]
                      [new-fld new-c]))
                  embed)
             (map (fn [new-flds]
                    (reduce new-flds {} (fn [m [k v]]
                                          (assoc m k v))))))
         (partial .fields tc)))

  Constraint
  (add-to-path [constraint file-name line-number]
    (let [new-path (cond (some (.path constraint) (partial = [file-name line-number]))
                         (.path constraint)
                         (cons [file-name line-number] (.path constraint)))
          fields (map-vals (.fields constraint)
                           (fn [field-c]
                             (add-to-path field-c file-name line-number)))]
      (either (and (= "" file-name)
                   (maybe constraint))
              (-> constraint
                  (.fields fields)
                  (.path new-path)))))

  (intersect [rc c]
    (cond (= top-type c)
          rc

          (and (empty? (.fields rc))
               (= UnknownType (.type-num rc)))
          c

          (intersect-reified-val c rc)))

  ;; (satisfied-by [c info]
  ;;   (either (sum-c-satisfies info c)
  ;;           (flat-map (extract-type-map info)
  ;;                     (fn [value-type-map]
  ;;                       (and (< 0 (count value-type-map))
  ;;                            (every (keys value-type-map)
  ;;                                   (partial get (.type-maps c)))
  ;;                            (maybe info))))))

  (contents-constraint [c]
    (Left (NoValues [c not-container])))

  ConstraintOps
  (intersect-str [rc str-c]
    (cond (and (empty? (.fields rc))
               (= UnknownType (.type-num rc)))
          str-c

          (NoValues [rc str-c])))

  (intersect-hash-map [c map-c]
    (cond (= UnknownType (.type-num c))
          (-> map-c
              (.kv-pairs (-> (.fields c)
                             vec
                             (reduce (.kv-pairs map-c)
                                     (fn [m [k v]]
                                       (let [new-k (intersect (.keys-c map-c) k)
                                             new-v (intersect (.vals-c map-c) v)]
                                         (either (for [static-key (get new-k .static-value)
                                                       :when (or (= static-key no-symbol)
                                                                 (= static-key no-string)
                                                                 (= static-key no-int))
                                                       curr-v (get m new-k)]
                                                   (assoc m new-k (trim (sum-type [curr-v new-v]))))
                                                 (assoc m new-k new-v)))))))
              is-bottom)

          (NoValues [c map-c])))

  (intersect-reified-val [c reified]
    (cond (= UnknownType (.type-num c) (.type-num reified))
          (-> reified
              (.fields (merge-with intersect (.fields reified) (.fields c)))
              is-bottom)

          (or (= (.type-num c) (.type-num reified))
              (and (= UnknownType (.type-num c))
                   (every (keys (.fields c))
                          (partial get (.fields reified)))))
          (-> reified
              (.fields (merge-with intersect (.fields reified) (.fields c)))
              is-bottom)

          (and (= UnknownType (.type-num reified))
               (every (keys (.fields reified))
                      (partial get (.fields c))))
          (-> c
              (.fields (merge-with intersect (.fields reified) (.fields c)))
              is-bottom)

          (NoValues [reified c])))

  (is-bottom [c]
    ;; TODO: always choose bottom-type with non-empty constraints if possible
    (either (some (vals (.fields c))
                  (partial = bottom-type))
            c))

  (extract-field [c fld]
    (either (get (.fields c) fld)
            (NoValues [c (required-field fld)])))

  (intersect-coll-of [c _]
    c)

  (intersect-inner [c _]
    c))

(defn core-containers [c]
  (cata (fn [inner-c]
          (let [inner-c (-> inner-c
                            (replace-path (.path c))
                            (.var (extract-var c)))]
            (cond (instance? SumConstraint inner-c)
                  (.sym inner-c (.sym c))

                  (either (map (.sym c) (partial .sym inner-c))
                          (.sym inner-c no-symbol)))))
        (SumConstraint [list-constraint
                        vect-constraint
                        bitmap-constraint
                        array-constraint
                        hash-coll-constraint
                        agent-constraint
                        promise-constraint
                        maybe-constraint]
                       empty-list no-symbol "")))

(extend-type InferredInner
  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (-> (.contents x)
        f
        (map (partial .contents x))))

  Eq
  (=* [x y]
    (=-inferred-inner y x))

  Constraint
  (old-extract-items-constraints [c n]
    (vec (repeat n (.contents c))))

  (satisfied-by [c coll-info]
    (assert-result r (instance? (maybe-of ValueConstraint) r))

    (and (or (and (= (.contents c) top-type)
                  (satisfied-by (core-containers c) coll-info))
             (satisfied-by (.contents c) (extract-contents-constraint coll-info)))
         (maybe coll-info)))

  (coll-constraint [c]
    (Left (CollectionOf (.contents c) (.path c) (.sym c) (extract-var c))))

  (contents-constraint [c]
    (Left (.contents c)))

  (intersect [ic c]
    (intersect-inner c ic))

  ConstraintOps
  (is-bottom [c]
    (either (= (.contents c) bottom-type)
            c))

  (intersect-reified-val [c rc]
    ;; TODO: insufficient for type checking calls to 'map' etc.
    rc)

  (intersect-vector [c vect-c]
    (intersect-inner vect-c c))

  (intersect-list [c vect-c]
    (intersect-inner vect-c c))

  (intersect-str [c str-c]
    (intersect-inner str-c c))

  (intersect-promise [c promise-c]
    (intersect-inner promise-c c))

  (intersect-agent [c agent-c]
    (intersect-inner agent-c c))

  (intersect-maybe [c maybe-c]
    (intersect-inner maybe-c c))

  (intersect-coll-of [c cc]
    (let [new-inner (intersect (.contents cc) (.contents c))]
      (either (= new-inner bottom-type)
              (.contents cc new-inner))))

  (=-inferred-inner [y x]
    (and (= (.contents x) (.contents y))
         (maybe x)))

  (intersect-inner [c ic]
    (let [new-c (intersect (.contents ic) (.contents c))]
      (either (= new-c bottom-type)
              (.contents ic new-c)))))

(extend-type CollectionOf
  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (-> (.contents x)
        f
        (map (partial .contents x))))

  Eq
  (=* [x y]
    (=-contentsc y x))

  Constraint
  (coll-constraint [c]
    (Left c))

  (satisfied-by [c coll-info]
    (assert-result r (instance? (maybe-of ValueConstraint) r))

    (and (or (and (= (.contents c) top-type)
                  (satisfied-by (core-containers c) coll-info))
             (satisfied-by (.contents c) (extract-contents-constraint coll-info)))
         (maybe coll-info)))

  (contents-constraint [c]
    (Left (.contents c)))

  (collection-of [x]
    (Left x))

  (old-extract-items-constraints [c n]
    (vec (repeat n (.contents c))))

  (intersect [cc c]
    (intersect-coll-of c cc))

  ConstraintOps
  (intersect-reified-val [c rc]
    ;; TODO: insufficient for type checking calls to 'map' etc.
    rc)

  (intersect-vector [c vect-c]
    (intersect-coll-of vect-c c))

  (intersect-list [c vect-c]
    (intersect-coll-of vect-c c))

  (intersect-str [c str-c]
    (intersect-coll-of str-c c))

  (intersect-maybe [c maybe-c]
    (intersect-coll-of maybe-c c))

  (intersect-promise [c promise-c]
    (intersect-coll-of promise-c c))

  (intersect-agent [c agent-c]
    (intersect-coll-of agent-c c))

  (is-bottom [c]
    (either (= (.contents c) bottom-type)
            c))

  (intersect-inner [c ic]
    (let [new-c (intersect (.contents c) (.contents ic))]
      (either (= new-c bottom-type)
              (.contents c new-c))))

  (intersect-coll-of [c cc]
    (let [new-cs (intersect (.contents cc) (.contents c))]
      (either (or (= new-cs bottom-type)
                  (= cc c))
              (.contents cc new-cs))))

  (=-contentsc [x y]
    (and (= (.contents x) (.contents y))
         (maybe x))))

(extend-type SumConstraint
  Container
  (map [x f]
    (.alts x (map (.alts x) f)))

  (map [x f embed]
    (-> (.alts x)
        (map f embed)
        (map (partial .alts x))))

  Constraint
  (trim [c]
    (let [all-alts (flat-map (.alts c) (fn [c]
                                         (trim (either (map (instance? SumConstraint c) .alts)
                                                       [c]))))
          trimmed (-> (sum-type all-alts)
                      (update-var (.var c))
                      ((fn [new-c]
                         (either (map (extract-sym c)
                                      (partial update-sym new-c))
                                 new-c))))]
      (either (map (instance? SumConstraint trimmed)
                   (fn [_]
                     (replace-path trimmed (.path c))))
              trimmed)))

  (dynamic-params [c]
    (comp* [] (seq (.alts c))))

  (intersect [sc c]
    (intersect-sum c sc))

  (fixed-items-constraints [c old-sumc]
    (-> old-sumc
        (extract-items-constraints (-> (.alts c)
                                       (reduce 0 (fn [max cs]
                                                   (let [n (count cs)]
                                                     (either (> max n)
                                                             n))))))
        (map (fn [c]
               (update-var c "")))))

  (old-extract-items-constraints [c n]
    (-> (apply zip-lists (map (.alts c) (fn [alt]
                                          (old-extract-items-constraints alt n))))
        (map (fn [new-alts]
               (either (or (some new-alts (partial = top-type))
                           (apply = new-alts))
                       (.alts c (vec new-alts)))))
        vec
        (map (fn [c]
               (update-var c "")))))

  (contents-constraint [c]
    (Right c))

  (get-tail-constraint [c old-c]
    (sum-type (.alts c)))

  ConstraintOps
  (is-bottom [c]
    ;; TODO: always choose bottom-type with non-empty constraints if possible
    (either (some (.alts c) (partial = bottom-type))
            c))

  (intersect-reified [sum-c reified]
    (intersect-sum reified sum-c))

  (intersect-int [sum-c c]
    (intersect-sum c sum-c))

  (intersect-fn [sum-c c]
    (intersect-sum c sum-c))

  (intersect-sym [sum-c c]
    (intersect-sum c sum-c))

  (intersect-str [sum-c c]
    (intersect-sum c sum-c))

  (intersect-maybe [sum-c c]
    (intersect-sum c sum-c))

  (intersect-hash-map [sum-c c]
    (intersect-sum c sum-c))

  (intersect-vector [sum-c c]
    (intersect-sum c sum-c))

  (intersect-list [sum-c c]
    (intersect-sum c sum-c))

  (intersect-promise [sum-c c]
    (intersect-sum c sum-c))

  (intersect-agent [sum-c c]
    (intersect-sum c sum-c))

  (intersect-reified-val [sum-c rc]
    (intersect-sum rc sum-c))

  (extract-field [c fld]
    (let [alt-fields (-> (.alts c)
                         (map (fn [alt]
                                (extract-field alt fld)))
                         (remove (partial = bottom-type)))]
      (cond (empty? alt-fields)
            (NoValues [c (required-field fld)])
            (sum-type alt-fields))))

  (sum-c-satisfies [info c]
    (maybe (and (every (.alts info) (partial satisfied-by c))
                (maybe c))))

  (intersect-sum [c1 c2]
    (let [new-alts (for [a1 (.alts c1)
                         a2 (.alts c2)
                         :let [new-alt (intersect a1 a2)]
                         :when-not (= bottom-type new-alt)]
                     new-alt)
          new-alts (reduce new-alts [] (fn [new-alts alt]
                                         (either (and (some new-alts (partial =* alt))
                                                      (maybe new-alts))
                                                 (conj new-alts alt))))]
      (either (or (and (empty? new-alts)
                       (maybe (NoValues [c1 c2])))
                  (and (= 1 (count new-alts))
                       (first new-alts)))
              (-> c1
                  (update-var (extract-var c2))
                  (.alts new-alts))))))

(extend-type ParamConstraint
  Container
  (map [x f]
    (.mods x (map (.mods x) f)))

  (map [x f embed]
    (map (map (.mods x) f embed)
         (fn [new-mods]
           (.mods x new-mods))))

  Constraint
  (reify-c [c arity loc]
    (cond (= (.arity c) arity)
          (comp (for [new-mods (se/traverse (.mods c)
                                            (fn [mod]
                                              (apo (fn [c]
                                                     (reify-c c arity loc))
                                                   mod
                                                   se/state-error)))
                      param-c (se/get-val (.param-index c))]
                  (Left (reduce new-mods param-c (fn [c mod]
                                                   ;; (and (instance? ParamConstraint mod)
                                                   ;;      (do
                                                   ;;        (print-err 'boomerity _FILE_ _LINE_)
                                                   ;;        (print-err 'loc loc)
                                                   ;;        (print-err 'c c)
                                                   ;;        (print-err 'mod mod)
                                                   ;;        (abort)))
                                                   (intersect mod c)))))
                (map (se/update-state identity)
                     (fn [params]
                       (print-err "Missing impl" _FILE_ _LINE_
                                  "\nat: " loc 'arity-id arity
                                  "\n\n" 'param-c c
                                  "\n\n" 'params params)
                       (Left top-type))))

          (se/state-error (Right c))))

  (reified-field [c indices]
    (-> c
        (.item-indices (comp (.item-indices c)
                             indices))
        maybe
        Left))

  (set-arity [c new-arity]
    (.arity c new-arity))

  (intersect [c1 c2]
    (intersect-param c2 c1))

  ConstraintOps
  (is-bottom [c]
    ;; TODO: need this?
    ;; (either (some (.mods c) (partial = bottom-type)))
    c)

  (intersect-int [pc int-c]
    (mod-param pc int-c))

  (intersect-fn [pc fn-c]
    (mod-param pc fn-c))

  (intersect-sym [pc sym-c]
    (mod-param pc sym-c))

  (intersect-str [pc str-c]
    (mod-param pc str-c))

  (intersect-maybe [pc maybe-c]
    (mod-param pc maybe-c))

  (intersect-hash-map [pc hash-map-c]
    (mod-param pc hash-map-c))

  (intersect-vector [pc vect-c]
    (mod-param pc vect-c))

  (intersect-list [pc vect-c]
    (mod-param pc vect-c))

  (intersect-promise [pc promise-c]
    (mod-param pc promise-c))

  (intersect-agent [pc agent-c]
    (mod-param pc agent-c))

  (intersect-param [c dyn-c]
    (cond (= c dyn-c)
          c

          (or (= (.sym c) no-symbol)
              (= (.sym dyn-c) no-symbol))
          (do
            (print-err 'kablooie _FILE_ _LINE_)
            (print-err 'c c)
            (print-err 'dyn-c dyn-c)
            ;; (abort)
            )

          (= (.sym c) (.sym dyn-c))
          (cond (every (zip-lists (.mods c) (.mods dyn-c))
                       (fn [[c1 c2]]
                         (= c1 c2)))
                (cond (< (count (.mods c)) (count (.mods dyn-c)))
                      dyn-c

                      c)

                (.mods dyn-c (conj (.mods dyn-c) c)))

          (.mods dyn-c (conj (.mods dyn-c) c))))

  (intersect-sum [c cs]
    (mod-param c cs))

  (intersect-reified-val [c rc]
    (mod-param c rc)))

(extend-type DynamicFields
  Constraint
  (reify-c [c arity loc]
    (for [param-cs (se/update-state identity)]
      (let [fields (-> (zip-lists (.fields c) (rest param-cs))
                       (reduce {} (fn [m [k v]]
                                    (assoc m k v))))]
        (-> (.type-c c)
            (.fields fields)
            (.path (.path c))
            (.sym (.sym c))
            (.var (.var c))
            (update-path loc)
            Left))))

  (intersect [c1 c2]
    (cond (= top-type c2)
          c1

          (= bottom-type c2)
          c2

          (= c1 c2)
          c1

          (instance? ReifiedConstraint c2)
          (intersect-reified-val c1 c2)

          (instance? DebugConstraint c2)
          (intersect c2 c1)

          (do
              (print-err 'kablooie _FILE_ _LINE_)
              (print-err 'c1 c1)
              (print-err 'c2 c2)
              ;; (abort)
              (NoValues [c1 c2]))))


  ConstraintOps
  (intersect-reified-val [c tc]
    (let [new-type (intersect-reified-val (.type-c c) tc)]
      (either (= bottom-type new-type)
              (.type-c c new-type)))))

(extend-type ReifiedFields
  Container
  (map [x f]
    (.field-cs x (map (.field-cs x) f)))

  (map [x f embed]
    (-> (.field-cs x)
        (map f embed)
        (map (partial .field-cs x))))

  Constraint
  (reified-field [c indices]
    (either (for [index (first indices)
                  field (get-in c [.field-cs index])]
              (cond (= 1 (count indices))
                    (Left (maybe field))
                    (Left (extract-reified-field field (rest indices)))))
            (Left (maybe c))))

  (reified-fields [c]
    (Left c))


  Constraint
  (intersect [reified c]
    (cond (instance? ReifiedFields c)
          top-type

          (instance? CoreValConstraint c)
          (NoValues [reified c])

          (intersect-reified c reified)))

  ConstraintOps
  (is-bottom [c] c))

(deftype SetField [fld fld-c]
  Eq
  (=* [x y]
    (and (instance? SetField y)
         (= fld (.fld y))
         (= fld-c (.fld-c y))
         (maybe x)))

  Stringable
  (string-list [_]
    (list "(c/SetField " (str fld) " " (str fld-c) ")"))

  Container
  (map [x f]
    (let [new-fld (f (.fld x))]
      (SetField (cond (= top-type new-fld)
                      (.fld x)
                      new-fld)
                (f (.fld-c x)))))

  (map [x f embed]
    (for [new-fld (f (.fld x))
          new-c (f (.fld-c x))]
      (SetField (cond (= top-type new-fld)
                      (.fld x)
                      new-fld)
                new-c)))

  Constraint
  (contents-constraint [c]
    (Left (NoValues [c not-container])))

  ConstraintOps
  (is-bottom [c]
    ;; TODO: always choose bottom-type with non-empty constraints if possible
    (either (or (= (.fld c) bottom-type)
                (= (.fld-c c) bottom-type))
            c))

  (intersect-hash-map [sf c]
    (let [new-k (intersect (.keys-c c) fld)
          new-v (intersect (.vals-c c) fld-c)
          new-v (either (for [static-key (get new-k .static-value)
                              :when (or (= static-key no-symbol)
                                        (= static-key no-string)
                                        (= static-key no-int))
                              curr-v (get (.kv-pairs c) new-k)]
                          (trim (sum-type [curr-v new-v])))
                        new-v)]
      (-> c
          (.kv-pairs (assoc (.kv-pairs c) new-k new-v))
          is-bottom)))

  (intersect-reified-val [c reified]
    ;; TODO: verify that new value satisfies the type field constraint
    (cond (instance? Field fld)
          (either (for [_ (get-in reified [.fields fld])]
                    (assoc-in reified [.fields fld] fld-c))
                  (NoValues [(required-field fld) reified]))

          reified)))

(defn set-field [fld c]
  (SetField fld c))

(deftype GetField [fld]
  Stringable
  (string-list [_]
    (list "(c/GetField " (str fld) ")"))

  Eq
  (=* [x y]
    (and (instance? GetField y)
         (= fld (.fld y))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Constraint
  (intersect [c1 c2]
    ;; TODO handle case where 'fld' is a Constraint
    (extract-field c2 fld))

  (contents-constraint [c]
    (Left (NoValues [c not-container])))

  ConstraintOps
  (extract-field [c other-fld]
    top-type)

  (is-bottom [c]
    (either (= (.fld c) bottom-type)
            c))

  (intersect-param [c dyn-c]
    ;; TODO handle case where 'fld' is a Constraint
    (cond (instance? Field fld)
          (mod-param dyn-c c)
          dyn-c)))

(defn get-field [fld]
  (GetField fld))

(deftype GetInnerType [path]
  Stringable
  (string-list [_]
    (list "(c/GetInnerType)"))

  Eq
  (=* [x y]
    (and (instance? GetInnerType y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Constraint
  (assertion-path [_] path)

  (format-path [x desired-len]
    (format-path* (cons ["Inner type required from" ""] path)
                  desired-len))

  (show-full [c]
    (list "GetInnerType"))

  (update-sym [c _]
    c)

  (contents-constraint [_]
    (Left top-type))

  (intersect [c1 c2]
    (let [inner-c (extract-contents-constraint c2)]
      (cond (= bottom-type inner-c)
            (NoValues [c1 c2])

            inner-c))))

(deftype CallValue [args path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/CallValue " "\n[" (to-str (interpose args "\n")) "]"
          " (list)"
          ;; (str " " (cons 'list path))
          " " (sym-str sym)
          " " (str "\"" var "\"")
          ")"))

  Eq
  (=* [x y]
    (and (instance? CallValue y)
         (= args (.args y))
         (maybe x)))

  Container
  (map [x f]
    (.args x (map args f)))

  (map [x f embed]
    (map (map args f embed)
         (partial .args x)))

  Constraint
  (show-full [c]
    (comp (format-path* (cons ["Called with args at" ""] path)
                        0)
          ["--args--"]
          (flat-map (.args c) (fn [arg-strs]
                                (map arg-strs (partial str "  "))))
          ["===="]))

  (set-path [c new-path]
    (Left (.path c new-path)))

  (add-to-path [c file line]
    (cond (or (= file "")
              (some path (partial = [file line])))
          c
          (.path c (cons [file line] (.path c)))))

  (contents-constraint [_]
    (Left top-type))

  (intersect [c1 c2]
    (cond (instance? ParamConstraint c2)
          (intersect c2 c1)

          (= bottom-type c2)
          c2

          (instance? ReifiedConstraint c2)
          (do
            ;; (print-err "Intersecting CallValue")
            ;; (print-err 'c1 c1)
            ;; (print-err 'c2 c2)
            (either (for [arity-info (get-in c2 [.invoke-arities (inc (count args))])]
                      (let [params-failed (-> (.param-consts arity-info)
                                              (extract-items-constraints (count args))
                                              (zip-lists args)
                                              (some (fn [[param arg]]
                                                      (= bottom-type (intersect param arg)))))]
                        (either params-failed
                                (reify-type-constraint (.result-const arity-info) (.arity-id arity-info)
                                                       (comp [c2] args)
                                                       (Location "WTF" 21305)))))
                    (NoValues [c1 c2])))

          ;; TODO: the need for this nested cond *must* be fixed ASAP
          (instance? CoreValConstraint c2)
          (cond (instance? FnConstraint c2)
                (do
                  ;; (print-err "Intersecting CallValue")
                  ;; (print-err 'c1 c1)
                  ;; (print-err 'c2 c2)
                  (either (for [arity-info (or (get-in c2 [.arities (count args)])
                                               (get-in c2 [.arities variadic]))]
                            (let [params-failed (-> (.param-consts arity-info)
                                                    (extract-items-constraints (count args))
                                                    (zip-lists args)
                                                    (some (fn [[param arg]]
                                                            (= bottom-type (intersect param arg)))))]
                              (either params-failed
                                      (reify-type-constraint (.result-const arity-info) (.arity-id arity-info)
                                                             args (Location "WTF" 21304)))))
                          (NoValues [c1 c2])))

                (NoValues [c1 c2]))

          (or (instance? GetField c2)
              (instance? SetField c2))
          (NoValues [c1 c2])

          (or (instance? DebugConstraint c2)
              (instance? SumConstraint c2))
          (intersect c2 c1)

          top-type))

  ;; TODO: these two impls are totally bogus
  (assertion-path [_]
    (either (map (first args) assertion-path)
            empty-list))

  (format-path [_ desired-len]
    (format-path* (cons ["Called at " ""] path)
                  desired-len))

  ConstraintOps
  (is-bottom [c]
    ;; TODO: always choose bottom-type with non-empty constraints if possible
    (either (some args (partial = bottom-type))
            c))

  (intersect-fn [y x]
    (intersect y x))

  (intersect-reified-val [c tc]
    (print-err 'calling-reified-val _FILE_ _LINE_ c "\n\n" 'tc tc)
    top-type))

(extend-type SetField
  Constraint
  (intersect [c1 c2]
    (cond (or (instance? SumConstraint c2)
              (instance? ParamConstraint c2)
              (instance? HashMapConstraint c2))
          (intersect c2 c1)

          (= bottom-type c2)
          c2

          (and (instance? ReifiedConstraint c2)
               (instance? Field (.fld c1)))
          (intersect-reified-val c1 c2)

          (or (instance? CoreValConstraint c2)
              (instance? GetField c2)
              (instance? GetInnerType c2)
              (instance? CallValue c2))
          (NoValues [c1 c2])

          c2)))

(extend-type FnConstraint
  Constraint
  (format-path [x desired-len]
    (format-path* (cons ["Function defined at" ""] (.path x))
                  desired-len))

  (intersect [x y]
    (intersect-fn y x))

  (contents-constraint [c]
    (Left (NoValues [c not-container])))

  ConstraintOps
  (intersect-fn [y x]
    (either (or (=* x y)
                (and (empty? (.arities x))
                     (maybe y))
                (and (empty? (.arities y))
                     (maybe x)))
            (NoValues [x y])))

  (is-bottom [c] c))

(extend-type GetInnerType
  ConstraintOps
  (is-bottom [c]
    c)

  (intersect-sum [c sum-c]
    (extract-contents-constraint sum-c))

  (intersect-maybe [c maybe-c]
    (extract-contents-constraint maybe-c))

  (intersect-hash-map [c hm-c]
    (extract-contents-constraint hm-c))

  (intersect-agent [c agent-c]
    (extract-contents-constraint agent-c))

  (intersect-promise [c promise-c]
    (extract-contents-constraint promise-c))

  (intersect-str [c str-c]
    (extract-contents-constraint str-c))

  (intersect-vector [c vect-c]
    (extract-contents-constraint vect-c))

  (intersect-list [c list-c]
    (extract-contents-constraint list-c)))

(extend-type AllValues
  Constraint
  (intersect [c1 c2]
    (cond (or (instance? SetField c2)
              (instance? GetField c2)
              (instance? GetInnerType c2)
              (instance? CallValue c2))
          c1

          c2)))

(defn full-param-constraint [outer-c]
  (trim (cata (fn [c]
                (either (map (instance? ParamConstraint c)
                             (fn [dyn-c]
                               (-> (.mods dyn-c)
                                   reverse
                                   (reduce top-type (fn [c mod]
                                                      (cond (instance? ParamConstraint mod)
                                                            (do
                                                              (print-err 'boomity _FILE_ _LINE_)
                                                              (full-param-constraint mod))

                                                            (instance? SetField mod)
                                                            (ReifiedConstraint
                                                             UnknownType {(.fld mod) top-type}
                                                             (symbol (str (.fld mod)))
                                                             {} empty-list no-symbol "")

                                                            (instance? GetField mod)
                                                            (ReifiedConstraint
                                                             UnknownType {(.fld mod) c}
                                                             (symbol (str (.fld mod)))
                                                             {} empty-list no-symbol "")

                                                            (instance? CallValue mod)
                                                            ;; TODO: there might be an opportunity to capture
                                                            ;; the needed return value ('c') and propogate that info
                                                            top-type

                                                            (intersect mod c)))))))
                        c))
              outer-c)))

(extend-type ParamConstraint
  Constraint
  ;; TODO: suspicious about this proto impl
  (get-type-num [outer-c]
    (-> (cata (fn [c]
                (either (map (instance? ParamConstraint c)
                             (fn [dyn-c]
                               (-> (.mods dyn-c)
                                   (reduce top-type (fn [c mod]
                                                      (cond (instance? ParamConstraint mod)
                                                            (do
                                                              (print-err 'boomity _FILE_ _LINE_)
                                                              ;; TODO: wrong. recurse into the mod
                                                              top-type)

                                                            (instance? SetField mod)
                                                            c

                                                            (instance? GetField mod)
                                                            top-type

                                                            (instance? CallValue mod)
                                                            top-type

                                                            (intersect mod c)))))))
                        c))
              outer-c)
        trim
        get-type-num))

  (contents-constraint [c]
    (Left (mod-param c (GetInnerType empty-list))))

  ConstraintOps
  (extract-field [dyn-c fld]
    (mod-param dyn-c (GetField fld))))

(extend-type Field
  ConstraintOps
  (is-bottom [x] x))

(extend-type TypeOfConstraint
  Constraint
  (intersect [c1 c2]
    (cond (or (=* c1 c2)
              (instance? AllValues c2))
          c1

          (or (instance? DebugConstraint c2)
              (instance? SumConstraint c2))
          (intersect c2 c1)

          (NoValues [c1 c2]))))

(extend-type InnerTypeOfConstraint
  Constraint
  (intersect [c1 c2]
    (cond (or (=* c1 c2)
              (instance? AllValues c2))
          c1

          (instance? ParamConstraint c2)
          (mod-param c2 (GetInnerType (.path c1)))

          (or (instance? DebugConstraint c2)
              (instance? SumConstraint c2))
          (intersect c2 c1)

          (NoValues [c1 c2]))))

(extend-type DebugConstraint
  Stringable
  (show* [c indent]
    (list* "Type of:" (.sym c)
           (map (cata show-full (.constraint c))
                (partial str  "\n  "))))

  Constraint
  (reify-c [c arity loc]
    (for [full-reified (apo (fn [c]
                                (reify-c c arity loc))
                              (.constraint c)
                              se/state-error)]
      (Right (.constraint c))))

  (contents-constraint [c]
    (Right c))

  ConstraintOps
  (extract-field [c fld]
    (.constraint c (extract-field (.constraint c) fld)))

  (intersect-param [c dyn-c]
    (intersect c dyn-c))

  (intersect-fn [c fn-c]
    (intersect c fn-c))

  (intersect-int [c int-c]
    (intersect c int-c))

  (intersect-promise [c promise-c]
    (intersect c promise-c))

  (intersect-agent [c agent-c]
    (intersect c agent-c))

  (intersect-sym [c sym-c]
    (intersect c sym-c))

  (intersect-hash-map [c map-c]
    (intersect c map-c))

  (intersect-list [c list-c]
    (intersect c list-c))

  (intersect-str [c vect-c]
    (intersect c vect-c))

  (intersect-vector [c vect-c]
    (intersect c vect-c))

  (intersect-maybe [c maybe-c]
    (intersect c maybe-c))

  (intersect-reified [c rc]
    (intersect c rc))

  (intersect-reified-val [c rc]
    (intersect c rc))

  (intersect-sum [c sum-c]
    (intersect c sum-c)))

(defn compose-constraints [file-name line-number x y]
  (assert (instance? Constraints x))
  (assert (instance? Constraints y))

  (let [z (intersect x y)]
    (either (and (= bottom-type z)
                 (let [z (either (and (flat-map (get z .constraints)
                                                (fn [constraints]
                                                  (< 1 (count constraints))))
                                      (maybe z))
                                 (NoValues [x y]))]
                   ;; (print-err 'x x)
                   ;; (print-err 'y y)
                   ;; (print-err 'z z)
                   (maybe (conflicting-assertions z file-name line-number))))
            (maybe z))))


;; AllValues                 extract-field
;; NoValues
;; InferredInner
;; CollectionOf
;; SumConstraint             extract-field
;; ParamConstraint           extract-field
;; DynamicFields
;; ReifiedFields
;; GetField                  extract-field
;; SetField                  extract-field
;; SetType
