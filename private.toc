
(defn sym-str [s]
  (either (or (and (instance? Symbol s)
                   (maybe (str "'" s))))
          (str s)))

;; TODO: remove unused types
(def UnknownType (inline C Integer "(Value *)&(Integer){IntegerType, -2, UnknownType};"))
(def IntegerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, IntegerType};"))
(def StringBufferType (inline C Integer "(Value *)&(Integer){IntegerType, -2, StringBufferType};"))
(def SubStringType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SubStringType};"))
(def FnArityType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FnArityType};"))
(def FunctionType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FunctionType};"))
(def MaybeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, MaybeType};"))
(def ListType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ListType};"))
(def VectorType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorType};"))
(def VectorNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, VectorNodeType};"))
(def SymbolType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SymbolType};"))
(def BitmapIndexedType (inline C Integer "(Value *)&(Integer){IntegerType, -2, BitmapIndexedType};"))
(def ArrayNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ArrayNodeType};"))
(def HashCollisionNodeType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashCollisionNodeType};"))
(def PromiseType (inline C Integer "(Value *)&(Integer){IntegerType, -2, PromiseType};"))
(def FutureType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FutureType};"))
(def AgentType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AgentType};"))
(def OpaqueType (inline C Integer "(Value *)&(Integer){IntegerType, -2, OpaqueType};"))
(def NoValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, NoValuesType};"))
(def AllValuesType (inline C Integer "(Value *)&(Integer){IntegerType, -2, AllValuesType};"))
(def ResultConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ResultConstraintType};"))
(def InferredInnerType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InferredInnerType};"))
(def ContentsConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ContentsConstraintType};"))
(def HashSetType (inline C Integer "(Value *)&(Integer){IntegerType, -2, HashSetType};"))
(def ProtoDispatcherType (inline C Integer "(Value *)&(Integer){IntegerType, -2, ProtoDispatcherType};"))
(def FloatType (inline C Integer "(Value *)&(Integer){IntegerType, -2, FloatType};"))
(def SumConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, SumConstraintType};"))
(def TypeOfConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeOfConstraintType};"))
(def InnerTypeOfConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, InnerTypeOfConstraintType};"))
(def DebugConstraintType (inline C Integer "(Value *)&(Integer){IntegerType, -2, DebugConstraintType};"))
(def TypeCount (inline C Integer "(Value *)&(Integer){IntegerType, -2, TypeCount};"))

;; type compoonents
(deftype NoSymbol []
  Stringable
  (string-list [_]
    (list "c/no-symbol"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (instance? NoSymbol y)))

(def TypeSym (any-of NoSymbol
                     Symbol))

(def no-symbol (NoSymbol))

(deftype NoInt []
  Stringable
  (string-list [_]
    (list "c/no-int"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (instance? NoInt y))

  Ord
  (<* [x y]
    (and (instance? Integer y)
         (maybe x))))
(def no-int (NoInt))

(deftype NoString []
  Stringable
  (string-list [_]
    (list "c/no-string"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (instance? NoString y)))

(def no-string (NoString))

(deftype NoTail []
  Stringable
  (string-list [_]
    (list "c/no-tail"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def no-tail (NoTail))

(deftype NoFields []
  Stringable
  (string-list [_]
    (list "c/no-fields")))

(def no-fields (NoFields))

(deftype NoArgs []
  Stringable
  (string-list [_]
    (list "c/no-args"))

  Eq
  (=* [x y]
    (and (instance? NoArgs y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(def no-args (NoArgs))

(deftype Variadic []
  Stringable
  (string-list [_] (list "c/variadic")))

(def variadic (Variadic))

(def ArityRank (any-of Integer
                       Variadic))

(deftype Field [sym]
  (assert (instance? Symbol sym))

  Stringable
  (string-list [_]
    (list (str "(c/Field (symbol \"" sym "\"))")))

  Eq
  (=* [x y]
    (and (instance? Field y)
         (= sym (.sym y))
         (maybe x)))

  Container
  (map [x _]
    x)

  (map [x _ embed]
    (embed x)))

;; universal types
(deftype AllValues [path var]
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "c/top-type"))

  Eq
  (=* [x y]
    (and (instance? AllValues y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype NoValues [constraints]
  Stringable
  (string-list [_]
    (list "(c/NoValues [" (to-str (interpose constraints "\n")) "])"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Eq
  (=* [x y]
    (and (instance? NoValues y)
         (or (and (empty? constraints)
                  (maybe y))
             (maybe x)))))

;; atomic types
(deftype IntegerConstraint [static-value max min path sym var]
  (assert (instance? (any-of Integer
                             NoInt) static-value))
  (assert (instance? (any-of Integer
                             NoInt) max))
  (assert (instance? (any-of Integer
                             NoInt) min))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/IntegerConstraint " (str static-value) " " (str max) " " (str min) " "
          "empty-list "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? IntegerConstraint y)
         (= static-value (.static-value y))
         (= max (.max y))
         (= min (.min y))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype SymbolConstraint [static-value path sym var]
  (assert (instance? TypeSym static-value))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/SymbolConstraint " (sym-str static-value) " "
          "empty-list "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? SymbolConstraint y)
         (= static-value (.static-value y))
         (maybe x)))

  Container
  (map [x _]
    x)

  (map [x _ embed]
    (embed x)))

(deftype OpaqueConstraint [path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/OpaqueConstraint " "empty-list "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? OpaqueConstraint y)
         (maybe x))))

;; atomic and container types
(deftype StrBuffConstraint [static-value path sym var]
  (assert (instance? (any-of String
                             NoString) static-value))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/StrBuffConstraint " (either (map (= static-value no-string) str)
                                          (str "\"" static-value "\"")) " "
          "empty-list "
          ;; (str (cons 'list path)) " "
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? StrBuffConstraint y)
         (= static-value (.static-value y))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype SubStrConstraint [static-value path sym var]
  (assert (instance? (any-of String
                             NoString) static-value))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/SubStrConstraint " (either (map (= static-value no-string) str)
                                         (str "\"" static-value "\"")) " "
          "empty-list "
          ;; (str (cons 'list path)) " "
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? SubStrConstraint y)
         (= static-value (.static-value y))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

;; container types
(deftype ListConstraint [items tail-c path sym var]
  (assert (instance? Vector items))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/ListConstraint [" (to-str (interpose items "\n")) "]\n"
          (str tail-c)
          " "
          "empty-list "
          ;; (str (cons 'list path)) " "
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? ListConstraint y)
         (= items (.items y))
         (= tail-c (.tail-c y))
         (maybe x)))

  Container
  (map [c f]
    (-> c
        (.tail-c (f (.tail-c c)))
        (.items (map (.items c) f))))

  (map [c f embed]
    (for [new-tail-c (f (.tail-c c))
          new-items (map (.items c) f embed)]
      (-> c
          (.tail-c new-tail-c)
          (.items new-items)))))
(def empty-list-constraint)

(deftype VectorConstraint [items tail-c path sym var]
  (assert (instance? Vector items))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/VectorConstraint [" (to-str (interpose items "\n")) "]\n"
          (str tail-c)
          " "
          "empty-list "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? VectorConstraint y)
         (= items (.items y))
         (= tail-c (.tail-c y))
         (maybe x)))

  Container
  (map [c f]
    (-> c
        (.tail-c (f (.tail-c c)))
        (.items (map (.items c) f))))

  (map [c f embed]
    (for [new-tail-c (f (.tail-c c))
          new-items (map (.items c) f embed)]
      (-> c
          (.tail-c new-tail-c)
          (.items new-items)))))

(deftype MaybeConstraint [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/MaybeConstraint " (str contents) "\n"
          "empty-list "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? MaybeConstraint y)
         (= contents (.contents y))
         (maybe x)))

  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (map (f (.contents x))
         (partial .contents x))))

(deftype HashMapConstraint [type-num kv-pairs keys-c vals-c path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/HashMapConstraint " (str type-num) " " (str kv-pairs) " "
          (str keys-c) " " (str vals-c) " "
          "empty-list "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? HashMapConstraint y)
         (= kv-pairs (.kv-pairs y))
         (= keys-c (.keys-c y))
         (= vals-c (.vals-c y))
         (maybe x)))

  Container
  (map [c f]
    (-> c
        (.keys-c (f (.keys-c c)))
        (.vals-c (f (.vals-c c)))
        (.kv-pairs (-> (.kv-pairs c)
                       vec
                       (reduce {} (fn [m [k v]]
                                    (assoc m
                                      (f k) (f v))))))))

  (map [c f embed]
    (for [new-keys (f (.keys-c c))
          new-vals (f (.vals-c c))
          new-kv (-> (.kv-pairs c)
                     vec
                     (map (fn [[key-c val-c]]
                            (for [new-key (f key-c)
                                  new-val (f val-c)]
                              [new-key new-val]))
                          embed))]
      (-> c
          (.keys-c new-keys)
          (.vals-c new-vals)
          (.kv-pairs (reduce new-kv {} (fn [m [k v]]
                                         (assoc m k v))))))))

(deftype AgentConstraint [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/AgentConstraint " (str contents) " "
          "empty-list "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? AgentConstraint y)
         (= contents (.contents y))
         (maybe x)))

  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (map (f (.contents x))
         (partial .contents x))))

(deftype FutureConstraint [path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/FutureConstraint " "empty-list "
          ;; (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? FutureConstraint y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype PromiseConstraint [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/PromiseConstraint " (str contents) " "
          "empty-list "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? PromiseConstraint y)
         (= contents (.contents y))
         (maybe x)))

  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (map (f (.contents x))
         (partial .contents x))))


(deftype fn-arity [arity-id param-consts result-const]
  (assert (instance? TypeSym arity-id))
  (assert (instance? ListConstraint param-consts))

  Stringable
  (string-list [_]
    (list "(c/fn-arity " (str "'" arity-id) "\n" (str param-consts) "\n" (str result-const) ")"))

  Eq
  (=* [x y]
    (and (instance? fn-arity y)
         (= param-consts (.param-consts y))
         (= result-const (.result-const y))
         (maybe x)))

  Container
  (map [x f]
    (let [new-fixed (map (.items param-consts) f)
          new-var (f (.tail-c param-consts))]
      (-> x
          (.param-consts (-> empty-list-constraint
                             (.items new-fixed)
                             (.tail-c new-var)))
          (.result-const (f result-const)))))

  (map [x f embed]
    (for [new-fixed (map (.items param-consts) f embed)
          new-var (f (.tail-c param-consts))
          new-result (f (.result-const x))]
      (-> x
          (.param-consts (-> empty-list-constraint
                             (.items new-fixed)
                             (.tail-c new-var)))
          (.result-const new-result)))))

(deftype FnConstraint [required-arities arities path sym var]
  ;; (assert (instance? (map-of ArityRank fn-arity) arities))
  (assert (instance? (vector-of Integer) required-arities))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/FnConstraint [" (to-str (interpose required-arities " ")) "]"
          "\n" (str arities)
          "\n empty-list "
          ;; "\n" (str (cons 'list path))
           (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? FnConstraint y)
         (=* arities (.arities y))
         (maybe x)))

  Container
  (map [x f]
    (.arities x (map-vals arities f)))

  (map [x f embed]
    (map (contextual-map-vals arities f embed)
         (fn [a]
           (.arities x a)))))

;; product type
(deftype ReifiedConstraint [type-num fields type-sym invoke-fn path sym var]
  (assert (instance? Integer type-num))
  (assert (instance? HashMap fields))
  (assert (instance? FnConstraint invoke-fn))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/ReifiedConstraint " (str type-num) " " (str fields)
          "\n"
          (str " (symbol \"" type-sym "\")")
          "\n" (str invoke-fn)
          ;; (str (interpose (cons 'list path) " "))
          " empty-list "
          " " (sym-str sym) " \"" (str var) "\")" ))

  Eq
  ;; TODO: equality must check the field maps as well
  ;; verify this
  (=* [x y]
    (for [_ (instance? ReifiedConstraint y)
          _ (= fields (.fields y))]
      x))

  Container
  (map [tc f]
    (-> tc
        (.fields (-> (.fields tc)
                     vec
                     (map (fn [[fld fld-c]]
                            [(f fld) (f fld-c)]))
                     (reduce {} (fn [m [k v]]
                                  (assoc m k v)))))
        (.invoke-fn (map (.invoke-fn tc) f))))

  (map [tc f embed]
    (for [new-fields (-> (.fields tc)
                         vec
                         (map (fn [[fld fld-c]]
                                (for [new-fld (f fld)
                                      new-c (f fld-c)]
                                  [new-fld new-c]))
                              embed)
                         (map (fn [new-flds]
                                (reduce new-flds {} (fn [m [k v]]
                                                      (assoc m k v))))))
          new-invoke (map (.invoke-fn tc) f embed)]
      (-> tc
          (.fields new-fields)
          (.invoke-fn new-invoke)))))


;; sum type
(deftype SumConstraint [alts path sym var]
  (assert (instance? Vector alts))
  (assert (instance? (min-count 1) alts))
  (assert (instance? TypeSym sym))
  (assert (instance? (list-of Vector) path))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list (str "(c/SumConstraint\n[" (to-str (interpose alts "\n\n")) "]"
               " empty-list "
               ;; "\n(list" (either (map (first path) (fn [[f l]]
               ;;                             (str "[\"" f "\" " l "]")))
               ;;         "") ") "
               (sym-str sym) " "
               (str "\"" var "\"") ")")))

  Eq
  (=* [x y]
    (and (instance? SumConstraint y)
         (= (count alts) (count (.alts y)))
         (every (.alts y) (fn [c]
                            (some alts (partial =* c))))
         (maybe x)))

  Container
  (map [x f]
    (.alts x (map (.alts x) f)))

  (map [x f embed]
    (-> (.alts x)
        (map f embed)
        (map (partial .alts x)))))

;; type attributes
(deftype CollectionOf [contents path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/CollectionOf\n" (str contents)
          "\nempty-list "
          ;; " (list "
          ;; (either (map (first path) (fn [[f l]]
          ;;                             (str "[\"" f "\" " l "]")))
          ;;         "")
          ;; ") "
          (sym-str sym) " \"" (str var) "\")"))

  Eq
  (=* [x y]
    (and (instance? CollectionOf y)
         (= contents (.contents y))
         (maybe x)))

  Container
  (map [x f]
    (.contents x (f (.contents x))))

  (map [x f embed]
    (-> (.contents x)
        f
        (map (partial .contents x)))))

;; computed types
(deftype ComputedConstraint [mods uses path sym var]
  (assert (instance? TypeSym sym))

  Stringable
  (string-list [_]
    (list "(c/ComputedConstraint "
          "\n[" (to-str (interpose mods "\n"))
          "]\n []"
           " empty-list"
          ;; (str " " (cons 'list path))
          " " (sym-str sym)
          " " (str "\"" var "\"")
          ")"))

  Eq
  (=* [x y]
    (and (instance? ComputedConstraint y)
         (= mods (.mods y))
         (= uses (.uses y))
         (maybe x)))

  Container
  (map [x f]
    (.mods x (map (.mods x) f)))

  (map [x f embed]
    (map (map (.mods x) f embed)
         (fn [new-mods]
           (.mods x new-mods)))))

(deftype ParamConstraint [arity param-index path sym var]
  (assert (instance? TypeSym sym))

  Stringable
  (string-list [_]
    (list "(c/ParamConstraint " (str "'" arity) " " (str param-index)
          " empty-list"
          ;; (str " " (cons 'list path))
          " " (sym-str sym)
          " " (str "\"" var "\"")
          ")"))

  Eq
  (=* [x y]
    (and (instance? ParamConstraint y)
         (or (= arity (.arity y))
             (= (.arity y) arity))
         (= param-index (.param-index y))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype TypeOfConstraint [param-sym path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/TypeOfConstraint " (sym-str param-sym)
          " empty-list "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? TypeOfConstraint y)
         (= param-sym (.param-sym y))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

;; type operations
(deftype InnerTypeOfConstraint [param-sym path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/InnerTypeOfConstraint " (str "'" param-sym) " "
          "empty-list "
          ;; (str (cons 'list path))
          " " (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? InnerTypeOfConstraint y)
         (or (= param-sym (.param-sym y))
             (= (.param-sym y) param-sym))
         (maybe x)))

  Container
  (map [x f]
    (cond (instance? TypeSym param-sym)
          x

          (.param-sym x (f param-sym))))

  (map [x f embed]
    (cond (instance? TypeSym param-sym)
          (embed x)

          (map (f param-sym)
               (partial .param-sym x)))))

(def VectFrom (reify
                Stringable
                (string-list [_]
                  (list "c/VectFrom"))))

(def ListFrom (reify
                Stringable
                (string-list [_]
                  (list "c/ListFrom"))))

(def RestOf (reify
              Stringable
              (string-list [_]
                (list "c/RestOf"))))

(def ButLastOf (reify
              Stringable
              (string-list [_]
                (list "c/ButLastOf"))))

(def FirstOf (reify
               Stringable
               (string-list [_]
                 (list "c/FirstOf"))))

(def LastOf (reify
               Stringable
               (string-list [_]
                 (list "c/LastOf"))))

;; TODO: enum doesn't work
;; (def SeqTypeOps (enum ListFrom VectFrom FirstOf LastOf RestOf ButLastOf))

(deftype ModSeqType [op base-sym path sym var]
  (assert (instance? Symbol base-sym))

  Stringable
  (string-list [_]
    (list "(c/ModSeqType " (str op) " " (str "'" base-sym) " "
          "empty-list "
          ;; (str (cons 'list path))
          (sym-str sym) " \"" (str var) "\")" ))

  Eq
  (=* [x y]
    (and (instance? ModSeqType y)
         (identical op (.op y))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype ArgOf [fn-sym arg-position path sym var]
  (assert (instance? Symbol fn-sym))
  (assert (instance? Integer arg-position))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/ArgOf " (sym-str fn-sym) " " (str arg-position)
          " empty-list"
          ;; (str " " (cons 'list path))
          " " (sym-str sym)
          " " (str "\"" var "\"")
          ")"))

  Eq
  (=* [x y]
    (and (instance? ArgOf y)
         (= arg-position (.arg-position y))
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype ResultOf [fn-sym path sym var]
  (assert (instance? Symbol fn-sym))
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/ResultOf " (sym-str fn-sym)
          " empty-list"
          ;; (str " " (cons 'list path))
          " " (sym-str sym)
          " " (str "\"" var "\"")
          ")"))

  Eq
  (=* [x y]
    (and (instance? ResultOf y)
         (maybe x)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x)))

(deftype CallValue [args path sym var]
  (assert (instance? (list-of Vector) path))
  (assert (instance? TypeSym sym))
  (assert (instance? String var))

  Stringable
  (string-list [_]
    (list "(c/CallValue "
          (either (map (= no-args args) (fn [_]
                                          "c/no-args"))
                  (str "\n[" (to-str (interpose args "\n")) "]"))
          " empty-list"
          ;; (str " " (cons 'list path))
          " " (sym-str sym)
          " " (str "\"" var "\"")
          ")"))

  Eq
  (=* [x y]
    (and (instance? CallValue y)
         (= args (.args y))
         (maybe x)))

  Container
  (map [x f]
    (.args x (map args f)))

  (map [x f embed]
    (map (map args f embed)
         (partial .args x))))

(deftype SetField [fld fld-c]
  (assert (instance? Vector fld))

  Stringable
  (string-list [_]
    (list "(c/SetField " (str fld) " " (str fld-c) ")"))

  Eq
  (=* [x y]
    (and (instance? SetField y)
         (= fld (.fld y))
         (= fld-c (.fld-c y))
         (maybe x)))

  Container
  (map [x f]
    (let [new-fld (map (.fld x) f)]
      (SetField new-fld (f (.fld-c x)))))

  (map [x f embed]
    (for [new-fld (map (.fld x) f)
          new-c (f (.fld-c x))]
      (SetField new-fld new-c))))

(deftype GetField [fld]
  (assert (instance? Vector fld))

  Stringable
  (string-list [_]
    (list "(c/GetField " (str fld) ")"))

  Eq
  (=* [x y]
    (and (instance? GetField y)
         (= fld (.fld y))
         (maybe x)))

  Container
  (map [x f]
    (GetField (f fld)))

  (map [x f embed]
    (map (f fld) GetField)))

(def top-type (AllValues empty-list ""))
(def bottom-type (NoValues []))

(defprotocol Constraint
  (intersect [c1 c2]
;; 'intersect' is commutative and associative
;; defined for almost everything
;; type ops may not be intersected with each other.
;; ComputedConstraint may not be intersected with itself
;; intersecting anything with a ComputedConstraint appends the constraint
;; intersecting anything with a ParamConstraint produces a ComputedConstraint with ParamConstraint first

    ;; 'top-type' is the undefined result
    top-type)
  )

(extend-type AllValues
  Constraint
  (intersect [_ y] y))

(extend-type NoValues
  Constraint
  (intersect [x _] x))

(extend-type IntegerConstraint
  Constraint
  (intersect [x y]
    (cond (= top-type y)
          x

          (= bottom-type y)
          y

          (instance? IntegerConstraint y)
          (let [new-min (either (> (.min x) (.min y))
                                (.min y))
                new-max (either (< (.max x) (.max y))
                                (.max y))
                new-static (or (= no-int (.static-value x) (.static-value y))
                               (flat-map (or (= (.static-value x) (.static-value y))
                                             (= (.static-value y) (.static-value x)))
                                         (fn [new-static]
                                           (and (<= new-min new-static new-max)
                                                (maybe new-static)))))]
            (either (map new-static (fn [new-static]
                                      ;; TODO: use the path from the most restrictive constraint
                                      ;; determined by satisfied-by
                                      (-> x
                                          (.static-value new-static)
                                          (.min new-min)
                                          (.max new-max))))
                    (NoValues [x y])))

          (NoValues [x y]))))

;; misc
;; Going to try and do without these
;; DebugConstraint
;; ResultConstraint

;; 'implies' is used to collapse a ComputedConstraint
;; implies is not commutative or associative
;; implies is the same as intersect for constraints other than type ops
;; for type ops, implies produces the a constraint that will give the resulting constraint

;; 'reify' replaces ParamConstraints with 

